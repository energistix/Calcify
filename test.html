<!DOCTYPE html>
<html lang="en" class="h-full dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
    
    
  <style>/* src/style.css */
@tailwind base;

@tailwind components;

@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 47.4% 11.2%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 47.4% 11.2%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 100% 50%;
    --destructive-foreground: 210 40% 98%;
    --ring: 215 20.2% 65.1%;
    --radius: .5rem;
  }

  .dark {
    --background: 224 71% 4%;
    --foreground: 213 31% 91%;
    --muted: 223 47% 11%;
    --muted-foreground: 215.4 16.3% 56.9%;
    --accent: 216 34% 17%;
    --accent-foreground: 210 40% 98%;
    --popover: 224 71% 4%;
    --popover-foreground: 215 20.2% 65.1%;
    --border: 216 34% 17%;
    --input: 216 34% 17%;
    --card: 224 71% 4%;
    --card-foreground: 213 31% 91%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 1.2%;
    --secondary: 222.2 47.4% 11.2%;
    --secondary-foreground: 210 40% 98%;
    --destructive: 0 63% 31%;
    --destructive-foreground: 210 40% 98%;
    --ring: 216 34% 17%;
  }
}

@layer base {
  @apply border-border;

  @apply font-sans antialiased bg-background text-foreground;
}

* {
  font-family: JetBrainsMono Nerd Font Mono;
}
</style>
  <script type="module">var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/typed-function/lib/umd/typed-function.js
var require_typed_function = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2["'typed'"] = factory());
  })(exports, function() {
    function ok() {
      return true;
    }
    function notOk() {
      return false;
    }
    function undef() {
      return;
    }
    const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
    function create() {
      function isPlainObject2(x) {
        return typeof x === "object" && x !== null && x.constructor === Object;
      }
      const _types = [{
        name: "number",
        test: function(x) {
          return typeof x === "number";
        }
      }, {
        name: "string",
        test: function(x) {
          return typeof x === "string";
        }
      }, {
        name: "boolean",
        test: function(x) {
          return typeof x === "boolean";
        }
      }, {
        name: "Function",
        test: function(x) {
          return typeof x === "function";
        }
      }, {
        name: "Array",
        test: Array.isArray
      }, {
        name: "Date",
        test: function(x) {
          return x instanceof Date;
        }
      }, {
        name: "RegExp",
        test: function(x) {
          return x instanceof RegExp;
        }
      }, {
        name: "Object",
        test: isPlainObject2
      }, {
        name: "null",
        test: function(x) {
          return x === null;
        }
      }, {
        name: "undefined",
        test: function(x) {
          return x === undefined;
        }
      }];
      const anyType = {
        name: "any",
        test: ok,
        isAny: true
      };
      let typeMap;
      let typeList;
      let nConversions = 0;
      let typed = {
        createCount: 0
      };
      function findType(typeName) {
        const type = typeMap.get(typeName);
        if (type) {
          return type;
        }
        let message = 'Unknown type "' + typeName + '"';
        const name = typeName.toLowerCase();
        let otherName;
        for (otherName of typeList) {
          if (otherName.toLowerCase() === name) {
            message += '. Did you mean "' + otherName + '" ?';
            break;
          }
        }
        throw new TypeError(message);
      }
      function addTypes(types) {
        let beforeSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "any";
        const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
        const newTypes = [];
        for (let i = 0;i < types.length; ++i) {
          if (!types[i] || typeof types[i].name !== "string" || typeof types[i].test !== "function") {
            throw new TypeError("Object with properties {name: string, test: function} expected");
          }
          const typeName = types[i].name;
          if (typeMap.has(typeName)) {
            throw new TypeError('Duplicate type name "' + typeName + '"');
          }
          newTypes.push(typeName);
          typeMap.set(typeName, {
            name: typeName,
            test: types[i].test,
            isAny: types[i].isAny,
            index: beforeIndex + i,
            conversionsTo: []
          });
        }
        const affectedTypes = typeList.slice(beforeIndex);
        typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
        for (let i = beforeIndex + newTypes.length;i < typeList.length; ++i) {
          typeMap.get(typeList[i]).index = i;
        }
      }
      function clear() {
        typeMap = new Map;
        typeList = [];
        nConversions = 0;
        addTypes([anyType], false);
      }
      clear();
      addTypes(_types);
      function clearConversions() {
        let typeName;
        for (typeName of typeList) {
          typeMap.get(typeName).conversionsTo = [];
        }
        nConversions = 0;
      }
      function findTypeNames(value) {
        const matches = typeList.filter((name) => {
          const type = typeMap.get(name);
          return !type.isAny && type.test(value);
        });
        if (matches.length) {
          return matches;
        }
        return ["any"];
      }
      function isTypedFunction(entity) {
        return entity && typeof entity === "function" && "_typedFunctionData" in entity;
      }
      function findSignature(fn, signature, options) {
        if (!isTypedFunction(fn)) {
          throw new TypeError(NOT_TYPED_FUNCTION);
        }
        const exact = options && options.exact;
        const stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
        const params = parseSignature(stringSignature);
        const canonicalSignature = stringifyParams(params);
        if (!exact || canonicalSignature in fn.signatures) {
          const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
          if (match) {
            return match;
          }
        }
        const nParams = params.length;
        let remainingSignatures;
        if (exact) {
          remainingSignatures = [];
          let name;
          for (name in fn.signatures) {
            remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name));
          }
        } else {
          remainingSignatures = fn._typedFunctionData.signatures;
        }
        for (let i = 0;i < nParams; ++i) {
          const want = params[i];
          const filteredSignatures = [];
          let possibility;
          for (possibility of remainingSignatures) {
            const have = getParamAtIndex(possibility.params, i);
            if (!have || want.restParam && !have.restParam) {
              continue;
            }
            if (!have.hasAny) {
              const haveTypes = paramTypeSet(have);
              if (want.types.some((wtype) => !haveTypes.has(wtype.name))) {
                continue;
              }
            }
            filteredSignatures.push(possibility);
          }
          remainingSignatures = filteredSignatures;
          if (remainingSignatures.length === 0)
            break;
        }
        let candidate;
        for (candidate of remainingSignatures) {
          if (candidate.params.length <= nParams) {
            return candidate;
          }
        }
        throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
      }
      function find(fn, signature, options) {
        return findSignature(fn, signature, options).implementation;
      }
      function convert(value, typeName) {
        const type = findType(typeName);
        if (type.test(value)) {
          return value;
        }
        const conversions = type.conversionsTo;
        if (conversions.length === 0) {
          throw new Error("There are no conversions to " + typeName + " defined.");
        }
        for (let i = 0;i < conversions.length; i++) {
          const fromType = findType(conversions[i].from);
          if (fromType.test(value)) {
            return conversions[i].convert(value);
          }
        }
        throw new Error("Cannot convert " + value + " to " + typeName);
      }
      function stringifyParams(params) {
        let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ",";
        return params.map((p) => p.name).join(separator);
      }
      function parseParam(param) {
        const restParam = param.indexOf("...") === 0;
        const types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
        const typeDefs = types.split("|").map((s) => findType(s.trim()));
        let hasAny = false;
        let paramName = restParam ? "..." : "";
        const exactTypes = typeDefs.map(function(type) {
          hasAny = type.isAny || hasAny;
          paramName += type.name + "|";
          return {
            name: type.name,
            typeIndex: type.index,
            test: type.test,
            isAny: type.isAny,
            conversion: null,
            conversionIndex: -1
          };
        });
        return {
          types: exactTypes,
          name: paramName.slice(0, -1),
          hasAny,
          hasConversion: false,
          restParam
        };
      }
      function expandParam(param) {
        const typeNames = param.types.map((t) => t.name);
        const matchingConversions = availableConversions(typeNames);
        let hasAny = param.hasAny;
        let newName = param.name;
        const convertibleTypes = matchingConversions.map(function(conversion) {
          const type = findType(conversion.from);
          hasAny = type.isAny || hasAny;
          newName += "|" + conversion.from;
          return {
            name: conversion.from,
            typeIndex: type.index,
            test: type.test,
            isAny: type.isAny,
            conversion,
            conversionIndex: conversion.index
          };
        });
        return {
          types: param.types.concat(convertibleTypes),
          name: newName,
          hasAny,
          hasConversion: convertibleTypes.length > 0,
          restParam: param.restParam
        };
      }
      function paramTypeSet(param) {
        if (!param.typeSet) {
          param.typeSet = new Set;
          param.types.forEach((type) => param.typeSet.add(type.name));
        }
        return param.typeSet;
      }
      function parseSignature(rawSignature) {
        const params = [];
        if (typeof rawSignature !== "string") {
          throw new TypeError("Signatures must be strings");
        }
        const signature = rawSignature.trim();
        if (signature === "") {
          return params;
        }
        const rawParams = signature.split(",");
        for (let i = 0;i < rawParams.length; ++i) {
          const parsedParam = parseParam(rawParams[i].trim());
          if (parsedParam.restParam && i !== rawParams.length - 1) {
            throw new SyntaxError('Unexpected rest parameter "' + rawParams[i] + '": ' + "only allowed for the last parameter");
          }
          if (parsedParam.types.length === 0) {
            return null;
          }
          params.push(parsedParam);
        }
        return params;
      }
      function hasRestParam(params) {
        const param = last(params);
        return param ? param.restParam : false;
      }
      function compileTest(param) {
        if (!param || param.types.length === 0) {
          return ok;
        } else if (param.types.length === 1) {
          return findType(param.types[0].name).test;
        } else if (param.types.length === 2) {
          const test0 = findType(param.types[0].name).test;
          const test1 = findType(param.types[1].name).test;
          return function or(x) {
            return test0(x) || test1(x);
          };
        } else {
          const tests = param.types.map(function(type) {
            return findType(type.name).test;
          });
          return function or(x) {
            for (let i = 0;i < tests.length; i++) {
              if (tests[i](x)) {
                return true;
              }
            }
            return false;
          };
        }
      }
      function compileTests(params) {
        let tests, test0, test1;
        if (hasRestParam(params)) {
          tests = initial(params).map(compileTest);
          const varIndex = tests.length;
          const lastTest = compileTest(last(params));
          const testRestParam = function(args) {
            for (let i = varIndex;i < args.length; i++) {
              if (!lastTest(args[i])) {
                return false;
              }
            }
            return true;
          };
          return function testArgs(args) {
            for (let i = 0;i < tests.length; i++) {
              if (!tests[i](args[i])) {
                return false;
              }
            }
            return testRestParam(args) && args.length >= varIndex + 1;
          };
        } else {
          if (params.length === 0) {
            return function testArgs(args) {
              return args.length === 0;
            };
          } else if (params.length === 1) {
            test0 = compileTest(params[0]);
            return function testArgs(args) {
              return test0(args[0]) && args.length === 1;
            };
          } else if (params.length === 2) {
            test0 = compileTest(params[0]);
            test1 = compileTest(params[1]);
            return function testArgs(args) {
              return test0(args[0]) && test1(args[1]) && args.length === 2;
            };
          } else {
            tests = params.map(compileTest);
            return function testArgs(args) {
              for (let i = 0;i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return args.length === tests.length;
            };
          }
        }
      }
      function getParamAtIndex(params, index) {
        return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;
      }
      function getTypeSetAtIndex(params, index) {
        const param = getParamAtIndex(params, index);
        if (!param) {
          return new Set;
        }
        return paramTypeSet(param);
      }
      function isExactType(type) {
        return type.conversion === null || type.conversion === undefined;
      }
      function mergeExpectedParams(signatures, index) {
        const typeSet = new Set;
        signatures.forEach((signature) => {
          const paramSet = getTypeSetAtIndex(signature.params, index);
          let name;
          for (name of paramSet) {
            typeSet.add(name);
          }
        });
        return typeSet.has("any") ? ["any"] : Array.from(typeSet);
      }
      function createError(name, args, signatures) {
        let err, expected;
        const _name = name || "unnamed";
        let matchingSignatures = signatures;
        let index;
        for (index = 0;index < args.length; index++) {
          const nextMatchingDefs = [];
          matchingSignatures.forEach((signature) => {
            const param = getParamAtIndex(signature.params, index);
            const test = compileTest(param);
            if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {
              nextMatchingDefs.push(signature);
            }
          });
          if (nextMatchingDefs.length === 0) {
            expected = mergeExpectedParams(matchingSignatures, index);
            if (expected.length > 0) {
              const actualTypes = findTypeNames(args[index]);
              err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index + ")");
              err.data = {
                category: "wrongType",
                fn: _name,
                index,
                actual: actualTypes,
                expected
              };
              return err;
            }
          } else {
            matchingSignatures = nextMatchingDefs;
          }
        }
        const lengths = matchingSignatures.map(function(signature) {
          return hasRestParam(signature.params) ? Infinity : signature.params.length;
        });
        if (args.length < Math.min.apply(null, lengths)) {
          expected = mergeExpectedParams(matchingSignatures, index);
          err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
          err.data = {
            category: "tooFewArgs",
            fn: _name,
            index: args.length,
            expected
          };
          return err;
        }
        const maxLength = Math.max.apply(null, lengths);
        if (args.length > maxLength) {
          err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
          err.data = {
            category: "tooManyArgs",
            fn: _name,
            index: args.length,
            expectedLength: maxLength
          };
          return err;
        }
        const argTypes = [];
        for (let i = 0;i < args.length; ++i) {
          argTypes.push(findTypeNames(args[i]).join("|"));
        }
        err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
        err.data = {
          category: "mismatch",
          actual: argTypes
        };
        return err;
      }
      function getLowestTypeIndex(param) {
        let min = typeList.length + 1;
        for (let i = 0;i < param.types.length; i++) {
          if (isExactType(param.types[i])) {
            min = Math.min(min, param.types[i].typeIndex);
          }
        }
        return min;
      }
      function getLowestConversionIndex(param) {
        let min = nConversions + 1;
        for (let i = 0;i < param.types.length; i++) {
          if (!isExactType(param.types[i])) {
            min = Math.min(min, param.types[i].conversionIndex);
          }
        }
        return min;
      }
      function compareParams(param1, param2) {
        if (param1.hasAny) {
          if (!param2.hasAny) {
            return 1;
          }
        } else if (param2.hasAny) {
          return -1;
        }
        if (param1.restParam) {
          if (!param2.restParam) {
            return 1;
          }
        } else if (param2.restParam) {
          return -1;
        }
        if (param1.hasConversion) {
          if (!param2.hasConversion) {
            return 1;
          }
        } else if (param2.hasConversion) {
          return -1;
        }
        const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
        if (typeDiff < 0) {
          return -1;
        }
        if (typeDiff > 0) {
          return 1;
        }
        const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
        if (convDiff < 0) {
          return -1;
        }
        if (convDiff > 0) {
          return 1;
        }
        return 0;
      }
      function compareSignatures(signature1, signature2) {
        const pars1 = signature1.params;
        const pars2 = signature2.params;
        const last1 = last(pars1);
        const last2 = last(pars2);
        const hasRest1 = hasRestParam(pars1);
        const hasRest2 = hasRestParam(pars2);
        if (hasRest1 && last1.hasAny) {
          if (!hasRest2 || !last2.hasAny) {
            return 1;
          }
        } else if (hasRest2 && last2.hasAny) {
          return -1;
        }
        let any1 = 0;
        let conv1 = 0;
        let par;
        for (par of pars1) {
          if (par.hasAny)
            ++any1;
          if (par.hasConversion)
            ++conv1;
        }
        let any2 = 0;
        let conv2 = 0;
        for (par of pars2) {
          if (par.hasAny)
            ++any2;
          if (par.hasConversion)
            ++conv2;
        }
        if (any1 !== any2) {
          return any1 - any2;
        }
        if (hasRest1 && last1.hasConversion) {
          if (!hasRest2 || !last2.hasConversion) {
            return 1;
          }
        } else if (hasRest2 && last2.hasConversion) {
          return -1;
        }
        if (conv1 !== conv2) {
          return conv1 - conv2;
        }
        if (hasRest1) {
          if (!hasRest2) {
            return 1;
          }
        } else if (hasRest2) {
          return -1;
        }
        const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
        if (lengthCriterion !== 0) {
          return lengthCriterion;
        }
        const comparisons = [];
        let tc = 0;
        for (let i = 0;i < pars1.length; ++i) {
          const thisComparison = compareParams(pars1[i], pars2[i]);
          comparisons.push(thisComparison);
          tc += thisComparison;
        }
        if (tc !== 0) {
          return tc;
        }
        let c;
        for (c of comparisons) {
          if (c !== 0) {
            return c;
          }
        }
        return 0;
      }
      function availableConversions(typeNames) {
        if (typeNames.length === 0) {
          return [];
        }
        const types = typeNames.map(findType);
        if (typeNames.length > 1) {
          types.sort((t1, t2) => t1.index - t2.index);
        }
        let matches = types[0].conversionsTo;
        if (typeNames.length === 1) {
          return matches;
        }
        matches = matches.concat([]);
        const knownTypes = new Set(typeNames);
        for (let i = 1;i < types.length; ++i) {
          let newMatch;
          for (newMatch of types[i].conversionsTo) {
            if (!knownTypes.has(newMatch.from)) {
              matches.push(newMatch);
              knownTypes.add(newMatch.from);
            }
          }
        }
        return matches;
      }
      function compileArgsPreprocessing(params, fn) {
        let fnConvert = fn;
        if (params.some((p) => p.hasConversion)) {
          const restParam = hasRestParam(params);
          const compiledConversions = params.map(compileArgConversion);
          fnConvert = function convertArgs() {
            const args = [];
            const last2 = restParam ? arguments.length - 1 : arguments.length;
            for (let i = 0;i < last2; i++) {
              args[i] = compiledConversions[i](arguments[i]);
            }
            if (restParam) {
              args[last2] = arguments[last2].map(compiledConversions[last2]);
            }
            return fn.apply(this, args);
          };
        }
        let fnPreprocess = fnConvert;
        if (hasRestParam(params)) {
          const offset = params.length - 1;
          fnPreprocess = function preprocessRestParams() {
            return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
          };
        }
        return fnPreprocess;
      }
      function compileArgConversion(param) {
        let test0, test1, conversion0, conversion1;
        const tests = [];
        const conversions = [];
        param.types.forEach(function(type) {
          if (type.conversion) {
            tests.push(findType(type.conversion.from).test);
            conversions.push(type.conversion.convert);
          }
        });
        switch (conversions.length) {
          case 0:
            return function convertArg(arg) {
              return arg;
            };
          case 1:
            test0 = tests[0];
            conversion0 = conversions[0];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg);
              }
              return arg;
            };
          case 2:
            test0 = tests[0];
            test1 = tests[1];
            conversion0 = conversions[0];
            conversion1 = conversions[1];
            return function convertArg(arg) {
              if (test0(arg)) {
                return conversion0(arg);
              }
              if (test1(arg)) {
                return conversion1(arg);
              }
              return arg;
            };
          default:
            return function convertArg(arg) {
              for (let i = 0;i < conversions.length; i++) {
                if (tests[i](arg)) {
                  return conversions[i](arg);
                }
              }
              return arg;
            };
        }
      }
      function splitParams(params) {
        function _splitParams(params2, index, paramsSoFar) {
          if (index < params2.length) {
            const param = params2[index];
            let resultingParams = [];
            if (param.restParam) {
              const exactTypes = param.types.filter(isExactType);
              if (exactTypes.length < param.types.length) {
                resultingParams.push({
                  types: exactTypes,
                  name: "..." + exactTypes.map((t) => t.name).join("|"),
                  hasAny: exactTypes.some((t) => t.isAny),
                  hasConversion: false,
                  restParam: true
                });
              }
              resultingParams.push(param);
            } else {
              resultingParams = param.types.map(function(type) {
                return {
                  types: [type],
                  name: type.name,
                  hasAny: type.isAny,
                  hasConversion: type.conversion,
                  restParam: false
                };
              });
            }
            return flatMap(resultingParams, function(nextParam) {
              return _splitParams(params2, index + 1, paramsSoFar.concat([nextParam]));
            });
          } else {
            return [paramsSoFar];
          }
        }
        return _splitParams(params, 0, []);
      }
      function conflicting(params1, params2) {
        const ii = Math.max(params1.length, params2.length);
        for (let i = 0;i < ii; i++) {
          const typeSet1 = getTypeSetAtIndex(params1, i);
          const typeSet2 = getTypeSetAtIndex(params2, i);
          let overlap = false;
          let name;
          for (name of typeSet2) {
            if (typeSet1.has(name)) {
              overlap = true;
              break;
            }
          }
          if (!overlap) {
            return false;
          }
        }
        const len1 = params1.length;
        const len2 = params2.length;
        const restParam1 = hasRestParam(params1);
        const restParam2 = hasRestParam(params2);
        return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
      }
      function clearResolutions(functionList) {
        return functionList.map((fn) => {
          if (isReferToSelf(fn)) {
            return referToSelf(fn.referToSelf.callback);
          }
          if (isReferTo(fn)) {
            return makeReferTo(fn.referTo.references, fn.referTo.callback);
          }
          return fn;
        });
      }
      function collectResolutions(references, functionList, signatureMap) {
        const resolvedReferences = [];
        let reference;
        for (reference of references) {
          let resolution = signatureMap[reference];
          if (typeof resolution !== "number") {
            throw new TypeError('No definition for referenced signature "' + reference + '"');
          }
          resolution = functionList[resolution];
          if (typeof resolution !== "function") {
            return false;
          }
          resolvedReferences.push(resolution);
        }
        return resolvedReferences;
      }
      function resolveReferences(functionList, signatureMap, self2) {
        const resolvedFunctions = clearResolutions(functionList);
        const isResolved = new Array(resolvedFunctions.length).fill(false);
        let leftUnresolved = true;
        while (leftUnresolved) {
          leftUnresolved = false;
          let nothingResolved = true;
          for (let i = 0;i < resolvedFunctions.length; ++i) {
            if (isResolved[i])
              continue;
            const fn = resolvedFunctions[i];
            if (isReferToSelf(fn)) {
              resolvedFunctions[i] = fn.referToSelf.callback(self2);
              resolvedFunctions[i].referToSelf = fn.referToSelf;
              isResolved[i] = true;
              nothingResolved = false;
            } else if (isReferTo(fn)) {
              const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
              if (resolvedReferences) {
                resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences);
                resolvedFunctions[i].referTo = fn.referTo;
                isResolved[i] = true;
                nothingResolved = false;
              } else {
                leftUnresolved = true;
              }
            }
          }
          if (nothingResolved && leftUnresolved) {
            throw new SyntaxError("Circular reference detected in resolving typed.referTo");
          }
        }
        return resolvedFunctions;
      }
      function validateDeprecatedThis(signaturesMap) {
        const deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
        Object.keys(signaturesMap).forEach((signature) => {
          const fn = signaturesMap[signature];
          if (deprecatedThisRegex.test(fn.toString())) {
            throw new SyntaxError("Using `this` to self-reference a function " + "is deprecated since typed-function@3. " + "Use typed.referTo and typed.referToSelf instead.");
          }
        });
      }
      function createTypedFunction(name, rawSignaturesMap) {
        typed.createCount++;
        if (Object.keys(rawSignaturesMap).length === 0) {
          throw new SyntaxError("No signatures provided");
        }
        if (typed.warnAgainstDeprecatedThis) {
          validateDeprecatedThis(rawSignaturesMap);
        }
        const parsedParams = [];
        const originalFunctions = [];
        const signaturesMap = {};
        const preliminarySignatures = [];
        let signature;
        for (signature in rawSignaturesMap) {
          if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
            continue;
          }
          const params = parseSignature(signature);
          if (!params)
            continue;
          parsedParams.forEach(function(pp) {
            if (conflicting(pp, params)) {
              throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
            }
          });
          parsedParams.push(params);
          const functionIndex = originalFunctions.length;
          originalFunctions.push(rawSignaturesMap[signature]);
          const conversionParams = params.map(expandParam);
          let sp;
          for (sp of splitParams(conversionParams)) {
            const spName = stringifyParams(sp);
            preliminarySignatures.push({
              params: sp,
              name: spName,
              fn: functionIndex
            });
            if (sp.every((p) => !p.hasConversion)) {
              signaturesMap[spName] = functionIndex;
            }
          }
        }
        preliminarySignatures.sort(compareSignatures);
        const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
        let s;
        for (s in signaturesMap) {
          if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
            signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
          }
        }
        const signatures = [];
        const internalSignatureMap = new Map;
        for (s of preliminarySignatures) {
          if (!internalSignatureMap.has(s.name)) {
            s.fn = resolvedFunctions[s.fn];
            signatures.push(s);
            internalSignatureMap.set(s.name, s);
          }
        }
        const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
        const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
        const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
        const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
        const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
        const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
        const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
        for (let i = 0;i < signatures.length; ++i) {
          signatures[i].test = compileTests(signatures[i].params);
        }
        const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
        const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
        const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
        const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
        const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
        const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
        const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
        const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
        const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
        const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
        const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
        const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
        for (let i = 0;i < signatures.length; ++i) {
          signatures[i].implementation = compileArgsPreprocessing(signatures[i].params, signatures[i].fn);
        }
        const fn0 = ok0 ? signatures[0].implementation : undef;
        const fn1 = ok1 ? signatures[1].implementation : undef;
        const fn2 = ok2 ? signatures[2].implementation : undef;
        const fn3 = ok3 ? signatures[3].implementation : undef;
        const fn4 = ok4 ? signatures[4].implementation : undef;
        const fn5 = ok5 ? signatures[5].implementation : undef;
        const len0 = ok0 ? signatures[0].params.length : -1;
        const len1 = ok1 ? signatures[1].params.length : -1;
        const len2 = ok2 ? signatures[2].params.length : -1;
        const len3 = ok3 ? signatures[3].params.length : -1;
        const len4 = ok4 ? signatures[4].params.length : -1;
        const len5 = ok5 ? signatures[5].params.length : -1;
        const iStart = allOk ? 6 : 0;
        const iEnd = signatures.length;
        const tests = signatures.map((s2) => s2.test);
        const fns = signatures.map((s2) => s2.implementation);
        const generic = function generic() {
          for (let i = iStart;i < iEnd; i++) {
            if (tests[i](arguments)) {
              return fns[i].apply(this, arguments);
            }
          }
          return typed.onMismatch(name, arguments, signatures);
        };
        function theTypedFn(arg0, arg1) {
          if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
            return fn0.apply(this, arguments);
          }
          if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
            return fn1.apply(this, arguments);
          }
          if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
            return fn2.apply(this, arguments);
          }
          if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
            return fn3.apply(this, arguments);
          }
          if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
            return fn4.apply(this, arguments);
          }
          if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
            return fn5.apply(this, arguments);
          }
          return generic.apply(this, arguments);
        }
        try {
          Object.defineProperty(theTypedFn, "name", {
            value: name
          });
        } catch (err) {
        }
        theTypedFn.signatures = signaturesMap;
        theTypedFn._typedFunctionData = {
          signatures,
          signatureMap: internalSignatureMap
        };
        return theTypedFn;
      }
      function _onMismatch(name, args, signatures) {
        throw createError(name, args, signatures);
      }
      function initial(arr) {
        return slice(arr, 0, arr.length - 1);
      }
      function last(arr) {
        return arr[arr.length - 1];
      }
      function slice(arr, start, end) {
        return Array.prototype.slice.call(arr, start, end);
      }
      function findInArray(arr, test) {
        for (let i = 0;i < arr.length; i++) {
          if (test(arr[i])) {
            return arr[i];
          }
        }
        return;
      }
      function flatMap(arr, callback) {
        return Array.prototype.concat.apply([], arr.map(callback));
      }
      function referTo() {
        const references = initial(arguments).map((s) => stringifyParams(parseSignature(s)));
        const callback = last(arguments);
        if (typeof callback !== "function") {
          throw new TypeError("Callback function expected as last argument");
        }
        return makeReferTo(references, callback);
      }
      function makeReferTo(references, callback) {
        return {
          referTo: {
            references,
            callback
          }
        };
      }
      function referToSelf(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("Callback function expected as first argument");
        }
        return {
          referToSelf: {
            callback
          }
        };
      }
      function isReferTo(objectOrFn) {
        return objectOrFn && typeof objectOrFn.referTo === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
      }
      function isReferToSelf(objectOrFn) {
        return objectOrFn && typeof objectOrFn.referToSelf === "object" && typeof objectOrFn.referToSelf.callback === "function";
      }
      function checkName(nameSoFar, newName) {
        if (!nameSoFar) {
          return newName;
        }
        if (newName && newName !== nameSoFar) {
          const err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
          err.data = {
            actual: newName,
            expected: nameSoFar
          };
          throw err;
        }
        return nameSoFar;
      }
      function getObjectName(obj) {
        let name;
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
            name = checkName(name, obj[key].name);
          }
        }
        return name;
      }
      function mergeSignatures(dest, source) {
        let key;
        for (key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (key in dest) {
              if (source[key] !== dest[key]) {
                const err = new Error('Signature "' + key + '" is defined twice');
                err.data = {
                  signature: key,
                  sourceFunction: source[key],
                  destFunction: dest[key]
                };
                throw err;
              }
            }
            dest[key] = source[key];
          }
        }
      }
      const saveTyped = typed;
      typed = function(maybeName) {
        const named = typeof maybeName === "string";
        const start = named ? 1 : 0;
        let name = named ? maybeName : "";
        const allSignatures = {};
        for (let i = start;i < arguments.length; ++i) {
          const item = arguments[i];
          let theseSignatures = {};
          let thisName;
          if (typeof item === "function") {
            thisName = item.name;
            if (typeof item.signature === "string") {
              theseSignatures[item.signature] = item;
            } else if (isTypedFunction(item)) {
              theseSignatures = item.signatures;
            }
          } else if (isPlainObject2(item)) {
            theseSignatures = item;
            if (!named) {
              thisName = getObjectName(item);
            }
          }
          if (Object.keys(theseSignatures).length === 0) {
            const err = new TypeError("Argument to 'typed' at index " + i + " is not a (typed) function, " + "nor an object with signatures as keys and functions as values.");
            err.data = {
              index: i,
              argument: item
            };
            throw err;
          }
          if (!named) {
            name = checkName(name, thisName);
          }
          mergeSignatures(allSignatures, theseSignatures);
        }
        return createTypedFunction(name || "", allSignatures);
      };
      typed.create = create;
      typed.createCount = saveTyped.createCount;
      typed.onMismatch = _onMismatch;
      typed.throwMismatchError = _onMismatch;
      typed.createError = createError;
      typed.clear = clear;
      typed.clearConversions = clearConversions;
      typed.addTypes = addTypes;
      typed._findType = findType;
      typed.referTo = referTo;
      typed.referToSelf = referToSelf;
      typed.convert = convert;
      typed.findSignature = findSignature;
      typed.find = find;
      typed.isTypedFunction = isTypedFunction;
      typed.warnAgainstDeprecatedThis = true;
      typed.addType = function(type, beforeObjectTest) {
        let before = "any";
        if (beforeObjectTest !== false && typeMap.has("Object")) {
          before = "Object";
        }
        typed.addTypes([type], before);
      };
      function _validateConversion(conversion) {
        if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
          throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
        }
        if (conversion.to === conversion.from) {
          throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
        }
      }
      typed.addConversion = function(conversion) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          override: false
        };
        _validateConversion(conversion);
        const to = findType(conversion.to);
        const existing = to.conversionsTo.find((other) => other.from === conversion.from);
        if (existing) {
          if (options && options.override) {
            typed.removeConversion({
              from: existing.from,
              to: conversion.to,
              convert: existing.convert
            });
          } else {
            throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to.name + '"');
          }
        }
        to.conversionsTo.push({
          from: conversion.from,
          convert: conversion.convert,
          index: nConversions++
        });
      };
      typed.addConversions = function(conversions, options) {
        conversions.forEach((conversion) => typed.addConversion(conversion, options));
      };
      typed.removeConversion = function(conversion) {
        _validateConversion(conversion);
        const to = findType(conversion.to);
        const existingConversion = findInArray(to.conversionsTo, (c) => c.from === conversion.from);
        if (!existingConversion) {
          throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
        }
        if (existingConversion.convert !== conversion.convert) {
          throw new Error("Conversion to remove does not match existing conversion");
        }
        const index = to.conversionsTo.indexOf(existingConversion);
        to.conversionsTo.splice(index, 1);
      };
      typed.resolve = function(tf, argList) {
        if (!isTypedFunction(tf)) {
          throw new TypeError(NOT_TYPED_FUNCTION);
        }
        const sigs = tf._typedFunctionData.signatures;
        for (let i = 0;i < sigs.length; ++i) {
          if (sigs[i].test(argList)) {
            return sigs[i];
          }
        }
        return null;
      };
      return typed;
    }
    var typedFunction = create();
    return typedFunction;
  });
});

// node_modules/javascript-natural-sort/naturalSort.js
var require_naturalSort = __commonJS((exports, module) => {
  module.exports = function naturalSort(a, b) {
    var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i = function(s) {
      return naturalSort.insensitive && ("" + s).toLowerCase() || "" + s;
    }, x = i(a).replace(sre, "") || "", y = i(b).replace(sre, "") || "", xN = x.replace(re, "\x00$1\x00").replace(/\0$/, "").replace(/^\0/, "").split("\x00"), yN = y.replace(re, "\x00$1\x00").replace(/\0$/, "").replace(/^\0/, "").split("\x00"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
    if (yD) {
      if (xD < yD) {
        return -1;
      } else if (xD > yD) {
        return 1;
      }
    }
    for (var cLoc = 0, numS = Math.max(xN.length, yN.length);cLoc < numS; cLoc++) {
      oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
      oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
      if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
        return isNaN(oFxNcL) ? 1 : -1;
      } else if (typeof oFxNcL !== typeof oFyNcL) {
        oFxNcL += "";
        oFyNcL += "";
      }
      if (oFxNcL < oFyNcL) {
        return -1;
      }
      if (oFxNcL > oFyNcL) {
        return 1;
      }
    }
    return 0;
  };
});

// node_modules/escape-latex/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var _extends2 = Object.assign || function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var defaultEscapes = {
    "{": "\\{",
    "}": "\\}",
    "\\": "\\textbackslash{}",
    "#": "\\#",
    $: "\\$",
    "%": "\\%",
    "&": "\\&",
    "^": "\\textasciicircum{}",
    _: "\\_",
    "~": "\\textasciitilde{}"
  };
  var formatEscapes = {
    "–": "\\--",
    "—": "\\---",
    " ": "~",
    "\t": "\\qquad{}",
    "\r\n": "\\newline{}",
    "\n": "\\newline{}"
  };
  var defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes2, formatEscapes2) {
    return _extends2({}, defaultEscapes2, formatEscapes2);
  };
  module.exports = function(str) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;
    var runningStr = String(str);
    var result = "";
    var escapes = escapeMapFn(_extends2({}, defaultEscapes), preserveFormatting ? _extends2({}, formatEscapes) : {});
    var escapeKeys = Object.keys(escapes);
    var _loop = function _loop() {
      var specialCharFound = false;
      escapeKeys.forEach(function(key, index) {
        if (specialCharFound) {
          return;
        }
        if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
          result += escapes[escapeKeys[index]];
          runningStr = runningStr.slice(key.length, runningStr.length);
          specialCharFound = true;
        }
      });
      if (!specialCharFound) {
        result += runningStr.slice(0, 1);
        runningStr = runningStr.slice(1, runningStr.length);
      }
    };
    while (runningStr) {
      _loop();
    }
    return result;
  };
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function Alea(seed) {
      var me = this, mash = Mash();
      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 0.00000000023283064365386963;
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };
      me.c = 1;
      me.s0 = mash(" ");
      me.s1 = mash(" ");
      me.s2 = mash(" ");
      me.s0 -= mash(seed);
      if (me.s0 < 0) {
        me.s0 += 1;
      }
      me.s1 -= mash(seed);
      if (me.s1 < 0) {
        me.s1 += 1;
      }
      me.s2 -= mash(seed);
      if (me.s2 < 0) {
        me.s2 += 1;
      }
      mash = null;
    }
    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }
    function impl(seed, opts) {
      var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
      prng.int32 = function() {
        return xg.next() * 4294967296 | 0;
      };
      prng.double = function() {
        return prng() + (prng() * 2097152 | 0) * 0.00000000000000011102230246251565;
      };
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    function Mash() {
      var n = 4022871197;
      var mash = function(data) {
        data = String(data);
        for (var i = 0;i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 4294967296;
        }
        return (n >>> 0) * 0.00000000023283064365386963;
      };
      return mash;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.alea = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.next = function() {
        var t = me.x ^ me.x << 11;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
      };
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor128 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var t = me.x ^ me.x >>> 2;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        me.w = me.v;
        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
      };
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorwow = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { x: X, i } = me, t, v, w;
        t = X[i];
        t ^= t >>> 7;
        v = t ^ t << 24;
        t = X[i + 1 & 7];
        v ^= t ^ t >>> 10;
        t = X[i + 3 & 7];
        v ^= t ^ t >>> 3;
        t = X[i + 4 & 7];
        v ^= t ^ t << 7;
        t = X[i + 7 & 7];
        t = t ^ t << 13;
        v ^= t ^ t << 9;
        X[i] = v;
        me.i = i + 1 & 7;
        return v;
      };
      function init(me2, seed2) {
        var j, w, X = [];
        if (seed2 === (seed2 | 0)) {
          w = X[0] = seed2;
        } else {
          seed2 = "" + seed2;
          for (j = 0;j < seed2.length; ++j) {
            X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
          }
        }
        while (X.length < 8)
          X.push(0);
        for (j = 0;j < 8 && X[j] === 0; ++j)
          ;
        if (j == 8)
          w = X[7] = -1;
        else
          w = X[j];
        me2.x = X;
        me2.i = 0;
        for (j = 256;j > 0; --j) {
          me2.next();
        }
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorshift7 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { w, X, i } = me, t, v;
        me.w = w = w + 1640531527 | 0;
        v = X[i + 34 & 127];
        t = X[i = i + 1 & 127];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        v = X[i] = v ^ t;
        me.i = i;
        return v + (w ^ w >>> 16) | 0;
      };
      function init(me2, seed2) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed2 === (seed2 | 0)) {
          v = seed2;
          seed2 = null;
        } else {
          seed2 = seed2 + "\x00";
          v = 0;
          limit = Math.max(limit, seed2.length);
        }
        for (i = 0, j = -32;j < limit; ++j) {
          if (seed2)
            v ^= seed2.charCodeAt((j + 32) % seed2.length);
          if (j === 0)
            w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = w + 1640531527 | 0;
            t = X[j & 127] ^= v + w;
            i = t == 0 ? i + 1 : 0;
          }
        }
        if (i >= 128) {
          X[(seed2 && seed2.length || 0) & 127] = -1;
        }
        i = 127;
        for (j = 4 * 128;j > 0; --j) {
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        me2.w = w;
        me2.X = X;
        me2.i = i;
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor4096 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var { b, c, d, a } = me;
        b = b << 25 ^ b >>> 7 ^ c;
        c = c - d | 0;
        d = d << 24 ^ d >>> 8 ^ a;
        a = a - b | 0;
        me.b = b = b << 20 ^ b >>> 12 ^ c;
        me.c = c = c - d | 0;
        me.d = d << 16 ^ c >>> 16 ^ a;
        return me.a = a - b | 0;
      };
      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;
      if (seed === Math.floor(seed)) {
        me.a = seed / 4294967296 | 0;
        me.b = seed | 0;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.tychei = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => cw,
  timingSafeEqual: () => x0,
  scryptSync: () => Id,
  scrypt: () => Td,
  randomUUID: () => lw,
  getRandomValues: () => uw,
  getCurves: () => dw,
  default: () => Wq,
  DEFAULT_ENCODING: () => Ga
});
function dw() {
  return Hq;
}
var pw, Xa, vw, bw, mw, gw, R0 = (t, e2) => () => (t && (e2 = t(t = 0)), e2), T = (t, e2) => () => (e2 || t((e2 = { exports: {} }).exports, e2), e2.exports), Ja = (t, e2) => {
  for (var r in e2)
    Xa(t, r, { get: e2[r], enumerable: true });
}, Ya = (t, e2, r, o) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let f of bw(e2))
      !gw.call(t, f) && f !== r && Xa(t, f, { get: () => e2[f], enumerable: !(o = vw(e2, f)) || o.enumerable });
  return t;
}, ot = (t, e2, r) => (Ya(t, e2, "default"), r && Ya(r, e2, "default")), rn = (t, e2, r) => (r = t != null ? pw(mw(t)) : {}, Ya(e2 || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t)), ur = (t) => Ya(Xa({}, "__esModule", { value: true }), t), Nd, Dd, Ut, Te, on, Ie, ki, W0, $f, pc, Z0, sn, V0, G0, J0, hn, co, Jf, po, Qf, vo, Pc, Oc, th, ph, Qc, np, ap, bh, Ao, Bo, pn, _p, Ep, gh, qp, yh, Op, ko, Tt, Gr, No, Jt, pa, Rh, pr, Y_, Oi, Fi, Ui, k1, yn, Vo, Go, Z1, Xo, Fh, ba, Jh, Dv, Qr, fu, ou, os, eb, cu, lb, bu, vf, S7, db, yi, bf, wb, mu, wu, Mu, Eb, _u, xu, Eu, Au, Ub, Iu, Tu, ar, vs, ku, Yb, Qb, em, im, nm, yf, om, um, dm, pm, bm, Pu, Ou, Fu, ws, Aa, Em, Wu, ju, Ba, Dm, Fm, Es, Hm, Vm, ji, Yu, Ym, Xm, As, tl, ol, rg, ag, hg, hl, pg, dl, kn, cl, bl, Ln, Ds, Lg, Dg, yl, Il, Yg, t2, i2, Ws, Ks, s2, ri, Nl, or, Oa, b2, y2, _2, Pl, Cr, Tf, Cl, N2, Fl, F2, Wl, Z2, V2, Q2, ty, e0, ny, t0, uy, dy, vy, yy, xy, Ey, Iy, o0, td, h0, u0, Kf, d0, c0, nd, Hy, od, hd, Jy, dd, r3, n3, o3, cd, d3, p3, v3, m3, Ha, bd, _3, A3, k3, N3, P32, _d, xd, w0, Ed, j3, Y3, X3, ow, qd, Xt, zq, Ga = "buffer", uw = (t) => crypto.getRandomValues(t), lw = () => crypto.randomUUID(), Hq, x0, Id, Td, cw, Wq;
var init_crypto = __esm(() => {
  pw = Object.create;
  Xa = Object.defineProperty;
  vw = Object.getOwnPropertyDescriptor;
  bw = Object.getOwnPropertyNames;
  mw = Object.getPrototypeOf;
  gw = Object.prototype.hasOwnProperty;
  Nd = T((Qa) => {
    Qa.byteLength = ww;
    Qa.toByteArray = _w;
    Qa.fromByteArray = Ew;
    var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (nn = 0, kd = B0.length;nn < kd; ++nn)
      jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
    var nn, kd;
    lr[45] = 62;
    lr[95] = 63;
    function Ld(t) {
      var e2 = t.length;
      if (e2 % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e2);
      var o = r === e2 ? 0 : 4 - r % 4;
      return [r, o];
    }
    function ww(t) {
      var e2 = Ld(t), r = e2[0], o = e2[1];
      return (r + o) * 3 / 4 - o;
    }
    function Mw(t, e2, r) {
      return (e2 + r) * 3 / 4 - r;
    }
    function _w(t) {
      var e2, r = Ld(t), o = r[0], f = r[1], p = new yw(Mw(t, o, f)), m = 0, y = f > 0 ? o - 4 : o, M;
      for (M = 0;M < y; M += 4)
        e2 = lr[t.charCodeAt(M)] << 18 | lr[t.charCodeAt(M + 1)] << 12 | lr[t.charCodeAt(M + 2)] << 6 | lr[t.charCodeAt(M + 3)], p[m++] = e2 >> 16 & 255, p[m++] = e2 >> 8 & 255, p[m++] = e2 & 255;
      return f === 2 && (e2 = lr[t.charCodeAt(M)] << 2 | lr[t.charCodeAt(M + 1)] >> 4, p[m++] = e2 & 255), f === 1 && (e2 = lr[t.charCodeAt(M)] << 10 | lr[t.charCodeAt(M + 1)] << 4 | lr[t.charCodeAt(M + 2)] >> 2, p[m++] = e2 >> 8 & 255, p[m++] = e2 & 255), p;
    }
    function xw(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function Sw(t, e2, r) {
      for (var o, f = [], p = e2;p < r; p += 3)
        o = (t[p] << 16 & 16711680) + (t[p + 1] << 8 & 65280) + (t[p + 2] & 255), f.push(xw(o));
      return f.join("");
    }
    function Ew(t) {
      for (var e2, r = t.length, o = r % 3, f = [], p = 16383, m = 0, y = r - o;m < y; m += p)
        f.push(Sw(t, m, m + p > y ? y : m + p));
      return o === 1 ? (e2 = t[r - 1], f.push(jr[e2 >> 2] + jr[e2 << 4 & 63] + "==")) : o === 2 && (e2 = (t[r - 2] << 8) + t[r - 1], f.push(jr[e2 >> 10] + jr[e2 >> 4 & 63] + jr[e2 << 2 & 63] + "=")), f.join("");
    }
  });
  Dd = T((q0) => {
    q0.read = function(t, e2, r, o, f) {
      var p, m, y = f * 8 - o - 1, M = (1 << y) - 1, x = M >> 1, S = -7, E = r ? f - 1 : 0, B = r ? -1 : 1, q = t[e2 + E];
      for (E += B, p = q & (1 << -S) - 1, q >>= -S, S += y;S > 0; p = p * 256 + t[e2 + E], E += B, S -= 8)
        ;
      for (m = p & (1 << -S) - 1, p >>= -S, S += o;S > 0; m = m * 256 + t[e2 + E], E += B, S -= 8)
        ;
      if (p === 0)
        p = 1 - x;
      else {
        if (p === M)
          return m ? NaN : (q ? -1 : 1) * (1 / 0);
        m = m + Math.pow(2, o), p = p - x;
      }
      return (q ? -1 : 1) * m * Math.pow(2, p - o);
    };
    q0.write = function(t, e2, r, o, f, p) {
      var m, y, M, x = p * 8 - f - 1, S = (1 << x) - 1, E = S >> 1, B = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = o ? 0 : p - 1, L = o ? 1 : -1, ge = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
      for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (y = isNaN(e2) ? 1 : 0, m = S) : (m = Math.floor(Math.log(e2) / Math.LN2), e2 * (M = Math.pow(2, -m)) < 1 && (m--, M *= 2), m + E >= 1 ? e2 += B / M : e2 += B * Math.pow(2, 1 - E), e2 * M >= 2 && (m++, M /= 2), m + E >= S ? (y = 0, m = S) : m + E >= 1 ? (y = (e2 * M - 1) * Math.pow(2, f), m = m + E) : (y = e2 * Math.pow(2, E - 1) * Math.pow(2, f), m = 0));f >= 8; t[r + q] = y & 255, q += L, y /= 256, f -= 8)
        ;
      for (m = m << f | y, x += f;x > 0; t[r + q] = m & 255, q += L, m /= 256, x -= 8)
        ;
      t[r + q - L] |= ge * 128;
    };
  });
  Ut = T((Xn) => {
    var I0 = Nd(), Gn = Dd(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Xn.Buffer = me;
    Xn.SlowBuffer = Tw;
    Xn.INSPECT_MAX_BYTES = 50;
    var eo = 2147483647;
    Xn.kMaxLength = eo;
    me.TYPED_ARRAY_SUPPORT = Aw();
    !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Aw() {
      try {
        let t = new Uint8Array(1), e2 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e2, Uint8Array.prototype), Object.setPrototypeOf(t, e2), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.byteOffset;
    } });
    function li(t) {
      if (t > eo)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e2 = new Uint8Array(t);
      return Object.setPrototypeOf(e2, me.prototype), e2;
    }
    function me(t, e2, r) {
      if (typeof t == "number") {
        if (typeof e2 == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return N0(t);
      }
      return Ud(t, e2, r);
    }
    me.poolSize = 8192;
    function Ud(t, e2, r) {
      if (typeof t == "string")
        return Bw(t, e2);
      if (ArrayBuffer.isView(t))
        return qw(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr(t, ArrayBuffer) || t && Zr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr(t, SharedArrayBuffer) || t && Zr(t.buffer, SharedArrayBuffer)))
        return k0(t, e2, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o = t.valueOf && t.valueOf();
      if (o != null && o !== t)
        return me.from(o, e2, r);
      let f = Iw(t);
      if (f)
        return f;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return me.from(t[Symbol.toPrimitive]("string"), e2, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    me.from = function(t, e2, r) {
      return Ud(t, e2, r);
    };
    Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(me, Uint8Array);
    function zd(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function Rw(t, e2, r) {
      return zd(t), t <= 0 ? li(t) : e2 !== undefined ? typeof r == "string" ? li(t).fill(e2, r) : li(t).fill(e2) : li(t);
    }
    me.alloc = function(t, e2, r) {
      return Rw(t, e2, r);
    };
    function N0(t) {
      return zd(t), li(t < 0 ? 0 : D0(t) | 0);
    }
    me.allocUnsafe = function(t) {
      return N0(t);
    };
    me.allocUnsafeSlow = function(t) {
      return N0(t);
    };
    function Bw(t, e2) {
      if ((typeof e2 != "string" || e2 === "") && (e2 = "utf8"), !me.isEncoding(e2))
        throw new TypeError("Unknown encoding: " + e2);
      let r = Hd(t, e2) | 0, o = li(r), f = o.write(t, e2);
      return f !== r && (o = o.slice(0, f)), o;
    }
    function T0(t) {
      let e2 = t.length < 0 ? 0 : D0(t.length) | 0, r = li(e2);
      for (let o = 0;o < e2; o += 1)
        r[o] = t[o] & 255;
      return r;
    }
    function qw(t) {
      if (Zr(t, Uint8Array)) {
        let e2 = new Uint8Array(t);
        return k0(e2.buffer, e2.byteOffset, e2.byteLength);
      }
      return T0(t);
    }
    function k0(t, e2, r) {
      if (e2 < 0 || t.byteLength < e2)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e2 + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o;
      return e2 === undefined && r === undefined ? o = new Uint8Array(t) : r === undefined ? o = new Uint8Array(t, e2) : o = new Uint8Array(t, e2, r), Object.setPrototypeOf(o, me.prototype), o;
    }
    function Iw(t) {
      if (me.isBuffer(t)) {
        let e2 = D0(t.length) | 0, r = li(e2);
        return r.length === 0 || t.copy(r, 0, 0, e2), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || C0(t.length) ? li(0) : T0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return T0(t.data);
    }
    function D0(t) {
      if (t >= eo)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo.toString(16) + " bytes");
      return t | 0;
    }
    function Tw(t) {
      return +t != t && (t = 0), me.alloc(+t);
    }
    me.isBuffer = function(e2) {
      return e2 != null && e2._isBuffer === true && e2 !== me.prototype;
    };
    me.compare = function(e2, r) {
      if (Zr(e2, Uint8Array) && (e2 = me.from(e2, e2.offset, e2.byteLength)), Zr(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e2) || !me.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e2 === r)
        return 0;
      let o = e2.length, f = r.length;
      for (let p = 0, m = Math.min(o, f);p < m; ++p)
        if (e2[p] !== r[p]) {
          o = e2[p], f = r[p];
          break;
        }
      return o < f ? -1 : f < o ? 1 : 0;
    };
    me.isEncoding = function(e2) {
      switch (String(e2).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    me.concat = function(e2, r) {
      if (!Array.isArray(e2))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e2.length === 0)
        return me.alloc(0);
      let o;
      if (r === undefined)
        for (r = 0, o = 0;o < e2.length; ++o)
          r += e2[o].length;
      let f = me.allocUnsafe(r), p = 0;
      for (o = 0;o < e2.length; ++o) {
        let m = e2[o];
        if (Zr(m, Uint8Array))
          p + m.length > f.length ? (me.isBuffer(m) || (m = me.from(m)), m.copy(f, p)) : Uint8Array.prototype.set.call(f, m, p);
        else if (me.isBuffer(m))
          m.copy(f, p);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p += m.length;
      }
      return f;
    };
    function Hd(t, e2) {
      if (me.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o = arguments.length > 2 && arguments[2] === true;
      if (!o && r === 0)
        return 0;
      let f = false;
      for (;; )
        switch (e2) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return L0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Xd(t).length;
          default:
            if (f)
              return o ? -1 : L0(t).length;
            e2 = ("" + e2).toLowerCase(), f = true;
        }
    }
    me.byteLength = Hd;
    function kw(t, e2, r) {
      let o = false;
      if ((e2 === undefined || e2 < 0) && (e2 = 0), e2 > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e2 >>>= 0, r <= e2))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return Hw(this, e2, r);
          case "utf8":
          case "utf-8":
            return Kd(this, e2, r);
          case "ascii":
            return Uw(this, e2, r);
          case "latin1":
          case "binary":
            return zw(this, e2, r);
          case "base64":
            return Ow(this, e2, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ww(this, e2, r);
          default:
            if (o)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o = true;
        }
    }
    me.prototype._isBuffer = true;
    function fn(t, e2, r) {
      let o = t[e2];
      t[e2] = t[r], t[r] = o;
    }
    me.prototype.swap16 = function() {
      let e2 = this.length;
      if (e2 % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e2; r += 2)
        fn(this, r, r + 1);
      return this;
    };
    me.prototype.swap32 = function() {
      let e2 = this.length;
      if (e2 % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e2; r += 4)
        fn(this, r, r + 3), fn(this, r + 1, r + 2);
      return this;
    };
    me.prototype.swap64 = function() {
      let e2 = this.length;
      if (e2 % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e2; r += 8)
        fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
      return this;
    };
    me.prototype.toString = function() {
      let e2 = this.length;
      return e2 === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e2) : kw.apply(this, arguments);
    };
    me.prototype.toLocaleString = me.prototype.toString;
    me.prototype.equals = function(e2) {
      if (!me.isBuffer(e2))
        throw new TypeError("Argument must be a Buffer");
      return this === e2 ? true : me.compare(this, e2) === 0;
    };
    me.prototype.inspect = function() {
      let e2 = "", r = Xn.INSPECT_MAX_BYTES;
      return e2 = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e2 += " ... "), "<Buffer " + e2 + ">";
    };
    Pd && (me.prototype[Pd] = me.prototype.inspect);
    me.prototype.compare = function(e2, r, o, f, p) {
      if (Zr(e2, Uint8Array) && (e2 = me.from(e2, e2.offset, e2.byteLength)), !me.isBuffer(e2))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
      if (r === undefined && (r = 0), o === undefined && (o = e2 ? e2.length : 0), f === undefined && (f = 0), p === undefined && (p = this.length), r < 0 || o > e2.length || f < 0 || p > this.length)
        throw new RangeError("out of range index");
      if (f >= p && r >= o)
        return 0;
      if (f >= p)
        return -1;
      if (r >= o)
        return 1;
      if (r >>>= 0, o >>>= 0, f >>>= 0, p >>>= 0, this === e2)
        return 0;
      let m = p - f, y = o - r, M = Math.min(m, y), x = this.slice(f, p), S = e2.slice(r, o);
      for (let E = 0;E < M; ++E)
        if (x[E] !== S[E]) {
          m = x[E], y = S[E];
          break;
        }
      return m < y ? -1 : y < m ? 1 : 0;
    };
    function Wd(t, e2, r, o, f) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f)
          r = 0;
        else
          return -1;
      if (typeof e2 == "string" && (e2 = me.from(e2, o)), me.isBuffer(e2))
        return e2.length === 0 ? -1 : Cd(t, e2, r, o, f);
      if (typeof e2 == "number")
        return e2 = e2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? f ? Uint8Array.prototype.indexOf.call(t, e2, r) : Uint8Array.prototype.lastIndexOf.call(t, e2, r) : Cd(t, [e2], r, o, f);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Cd(t, e2, r, o, f) {
      let p = 1, m = t.length, y = e2.length;
      if (o !== undefined && (o = String(o).toLowerCase(), o === "ucs2" || o === "ucs-2" || o === "utf16le" || o === "utf-16le")) {
        if (t.length < 2 || e2.length < 2)
          return -1;
        p = 2, m /= 2, y /= 2, r /= 2;
      }
      function M(S, E) {
        return p === 1 ? S[E] : S.readUInt16BE(E * p);
      }
      let x;
      if (f) {
        let S = -1;
        for (x = r;x < m; x++)
          if (M(t, x) === M(e2, S === -1 ? 0 : x - S)) {
            if (S === -1 && (S = x), x - S + 1 === y)
              return S * p;
          } else
            S !== -1 && (x -= x - S), S = -1;
      } else
        for (r + y > m && (r = m - y), x = r;x >= 0; x--) {
          let S = true;
          for (let E = 0;E < y; E++)
            if (M(t, x + E) !== M(e2, E)) {
              S = false;
              break;
            }
          if (S)
            return x;
        }
      return -1;
    }
    me.prototype.includes = function(e2, r, o) {
      return this.indexOf(e2, r, o) !== -1;
    };
    me.prototype.indexOf = function(e2, r, o) {
      return Wd(this, e2, r, o, true);
    };
    me.prototype.lastIndexOf = function(e2, r, o) {
      return Wd(this, e2, r, o, false);
    };
    function Lw(t, e2, r, o) {
      r = Number(r) || 0;
      let f = t.length - r;
      o ? (o = Number(o), o > f && (o = f)) : o = f;
      let p = e2.length;
      o > p / 2 && (o = p / 2);
      let m;
      for (m = 0;m < o; ++m) {
        let y = parseInt(e2.substr(m * 2, 2), 16);
        if (C0(y))
          return m;
        t[r + m] = y;
      }
      return m;
    }
    function Nw(t, e2, r, o) {
      return to(L0(e2, t.length - r), t, r, o);
    }
    function Dw(t, e2, r, o) {
      return to(Vw(e2), t, r, o);
    }
    function Pw(t, e2, r, o) {
      return to(Xd(e2), t, r, o);
    }
    function Cw(t, e2, r, o) {
      return to($w(e2, t.length - r), t, r, o);
    }
    me.prototype.write = function(e2, r, o, f) {
      if (r === undefined)
        f = "utf8", o = this.length, r = 0;
      else if (o === undefined && typeof r == "string")
        f = r, o = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o) ? (o = o >>> 0, f === undefined && (f = "utf8")) : (f = o, o = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p = this.length - r;
      if ((o === undefined || o > p) && (o = p), e2.length > 0 && (o < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f || (f = "utf8");
      let m = false;
      for (;; )
        switch (f) {
          case "hex":
            return Lw(this, e2, r, o);
          case "utf8":
          case "utf-8":
            return Nw(this, e2, r, o);
          case "ascii":
          case "latin1":
          case "binary":
            return Dw(this, e2, r, o);
          case "base64":
            return Pw(this, e2, r, o);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Cw(this, e2, r, o);
          default:
            if (m)
              throw new TypeError("Unknown encoding: " + f);
            f = ("" + f).toLowerCase(), m = true;
        }
    };
    me.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Ow(t, e2, r) {
      return e2 === 0 && r === t.length ? I0.fromByteArray(t) : I0.fromByteArray(t.slice(e2, r));
    }
    function Kd(t, e2, r) {
      r = Math.min(t.length, r);
      let o = [], f = e2;
      for (;f < r; ) {
        let p = t[f], m = null, y = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
        if (f + y <= r) {
          let M, x, S, E;
          switch (y) {
            case 1:
              p < 128 && (m = p);
              break;
            case 2:
              M = t[f + 1], (M & 192) === 128 && (E = (p & 31) << 6 | M & 63, E > 127 && (m = E));
              break;
            case 3:
              M = t[f + 1], x = t[f + 2], (M & 192) === 128 && (x & 192) === 128 && (E = (p & 15) << 12 | (M & 63) << 6 | x & 63, E > 2047 && (E < 55296 || E > 57343) && (m = E));
              break;
            case 4:
              M = t[f + 1], x = t[f + 2], S = t[f + 3], (M & 192) === 128 && (x & 192) === 128 && (S & 192) === 128 && (E = (p & 15) << 18 | (M & 63) << 12 | (x & 63) << 6 | S & 63, E > 65535 && E < 1114112 && (m = E));
          }
        }
        m === null ? (m = 65533, y = 1) : m > 65535 && (m -= 65536, o.push(m >>> 10 & 1023 | 55296), m = 56320 | m & 1023), o.push(m), f += y;
      }
      return Fw(o);
    }
    var Od = 4096;
    function Fw(t) {
      let e2 = t.length;
      if (e2 <= Od)
        return String.fromCharCode.apply(String, t);
      let r = "", o = 0;
      for (;o < e2; )
        r += String.fromCharCode.apply(String, t.slice(o, o += Od));
      return r;
    }
    function Uw(t, e2, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e2;f < r; ++f)
        o += String.fromCharCode(t[f] & 127);
      return o;
    }
    function zw(t, e2, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e2;f < r; ++f)
        o += String.fromCharCode(t[f]);
      return o;
    }
    function Hw(t, e2, r) {
      let o = t.length;
      (!e2 || e2 < 0) && (e2 = 0), (!r || r < 0 || r > o) && (r = o);
      let f = "";
      for (let p = e2;p < r; ++p)
        f += Gw[t[p]];
      return f;
    }
    function Ww(t, e2, r) {
      let o = t.slice(e2, r), f = "";
      for (let p = 0;p < o.length - 1; p += 2)
        f += String.fromCharCode(o[p] + o[p + 1] * 256);
      return f;
    }
    me.prototype.slice = function(e2, r) {
      let o = this.length;
      e2 = ~~e2, r = r === undefined ? o : ~~r, e2 < 0 ? (e2 += o, e2 < 0 && (e2 = 0)) : e2 > o && (e2 = o), r < 0 ? (r += o, r < 0 && (r = 0)) : r > o && (r = o), r < e2 && (r = e2);
      let f = this.subarray(e2, r);
      return Object.setPrototypeOf(f, me.prototype), f;
    };
    function Dt(t, e2, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e2 > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    me.prototype.readUintLE = me.prototype.readUIntLE = function(e2, r, o) {
      e2 = e2 >>> 0, r = r >>> 0, o || Dt(e2, r, this.length);
      let f = this[e2], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f += this[e2 + m] * p;
      return f;
    };
    me.prototype.readUintBE = me.prototype.readUIntBE = function(e2, r, o) {
      e2 = e2 >>> 0, r = r >>> 0, o || Dt(e2, r, this.length);
      let f = this[e2 + --r], p = 1;
      for (;r > 0 && (p *= 256); )
        f += this[e2 + --r] * p;
      return f;
    };
    me.prototype.readUint8 = me.prototype.readUInt8 = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 1, this.length), this[e2];
    };
    me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
    };
    me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
    };
    me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + this[e2 + 3] * 16777216;
    };
    me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 4, this.length), this[e2] * 16777216 + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
    };
    me.prototype.readBigUInt64LE = Ti(function(e2) {
      e2 = e2 >>> 0, Yn(e2, "offset");
      let r = this[e2], o = this[e2 + 7];
      (r === undefined || o === undefined) && Vf(e2, this.length - 8);
      let f = r + this[++e2] * 2 ** 8 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 24, p = this[++e2] + this[++e2] * 2 ** 8 + this[++e2] * 2 ** 16 + o * 2 ** 24;
      return BigInt(f) + (BigInt(p) << BigInt(32));
    });
    me.prototype.readBigUInt64BE = Ti(function(e2) {
      e2 = e2 >>> 0, Yn(e2, "offset");
      let r = this[e2], o = this[e2 + 7];
      (r === undefined || o === undefined) && Vf(e2, this.length - 8);
      let f = r * 2 ** 24 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + this[++e2], p = this[++e2] * 2 ** 24 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + o;
      return (BigInt(f) << BigInt(32)) + BigInt(p);
    });
    me.prototype.readIntLE = function(e2, r, o) {
      e2 = e2 >>> 0, r = r >>> 0, o || Dt(e2, r, this.length);
      let f = this[e2], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f += this[e2 + m] * p;
      return p *= 128, f >= p && (f -= Math.pow(2, 8 * r)), f;
    };
    me.prototype.readIntBE = function(e2, r, o) {
      e2 = e2 >>> 0, r = r >>> 0, o || Dt(e2, r, this.length);
      let f = r, p = 1, m = this[e2 + --f];
      for (;f > 0 && (p *= 256); )
        m += this[e2 + --f] * p;
      return p *= 128, m >= p && (m -= Math.pow(2, 8 * r)), m;
    };
    me.prototype.readInt8 = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 1, this.length), this[e2] & 128 ? (255 - this[e2] + 1) * -1 : this[e2];
    };
    me.prototype.readInt16LE = function(e2, r) {
      e2 = e2 >>> 0, r || Dt(e2, 2, this.length);
      let o = this[e2] | this[e2 + 1] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt16BE = function(e2, r) {
      e2 = e2 >>> 0, r || Dt(e2, 2, this.length);
      let o = this[e2 + 1] | this[e2] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt32LE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
    };
    me.prototype.readInt32BE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
    };
    me.prototype.readBigInt64LE = Ti(function(e2) {
      e2 = e2 >>> 0, Yn(e2, "offset");
      let r = this[e2], o = this[e2 + 7];
      (r === undefined || o === undefined) && Vf(e2, this.length - 8);
      let f = this[e2 + 4] + this[e2 + 5] * 2 ** 8 + this[e2 + 6] * 2 ** 16 + (o << 24);
      return (BigInt(f) << BigInt(32)) + BigInt(r + this[++e2] * 2 ** 8 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 24);
    });
    me.prototype.readBigInt64BE = Ti(function(e2) {
      e2 = e2 >>> 0, Yn(e2, "offset");
      let r = this[e2], o = this[e2 + 7];
      (r === undefined || o === undefined) && Vf(e2, this.length - 8);
      let f = (r << 24) + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + this[++e2];
      return (BigInt(f) << BigInt(32)) + BigInt(this[++e2] * 2 ** 24 + this[++e2] * 2 ** 16 + this[++e2] * 2 ** 8 + o);
    });
    me.prototype.readFloatLE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 4, this.length), Gn.read(this, e2, true, 23, 4);
    };
    me.prototype.readFloatBE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 4, this.length), Gn.read(this, e2, false, 23, 4);
    };
    me.prototype.readDoubleLE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 8, this.length), Gn.read(this, e2, true, 52, 8);
    };
    me.prototype.readDoubleBE = function(e2, r) {
      return e2 = e2 >>> 0, r || Dt(e2, 8, this.length), Gn.read(this, e2, false, 52, 8);
    };
    function er(t, e2, r, o, f, p) {
      if (!me.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e2 > f || e2 < p)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o > t.length)
        throw new RangeError("Index out of range");
    }
    me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e2, r, o, f) {
      if (e2 = +e2, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e2, r, o, y, 0);
      }
      let p = 1, m = 0;
      for (this[r] = e2 & 255;++m < o && (p *= 256); )
        this[r + m] = e2 / p & 255;
      return r + o;
    };
    me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e2, r, o, f) {
      if (e2 = +e2, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e2, r, o, y, 0);
      }
      let p = o - 1, m = 1;
      for (this[r + p] = e2 & 255;--p >= 0 && (m *= 256); )
        this[r + p] = e2 / m & 255;
      return r + o;
    };
    me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 1, 255, 0), this[r] = e2 & 255, r + 1;
    };
    me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 2, 65535, 0), this[r] = e2 & 255, this[r + 1] = e2 >>> 8, r + 2;
    };
    me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 2, 65535, 0), this[r] = e2 >>> 8, this[r + 1] = e2 & 255, r + 2;
    };
    me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 4, 4294967295, 0), this[r + 3] = e2 >>> 24, this[r + 2] = e2 >>> 16, this[r + 1] = e2 >>> 8, this[r] = e2 & 255, r + 4;
    };
    me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 4, 4294967295, 0), this[r] = e2 >>> 24, this[r + 1] = e2 >>> 16, this[r + 2] = e2 >>> 8, this[r + 3] = e2 & 255, r + 4;
    };
    function jd(t, e2, r, o, f) {
      Yd(e2, o, f, t, r, 7);
      let p = Number(e2 & BigInt(4294967295));
      t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p;
      let m = Number(e2 >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, r;
    }
    function Zd(t, e2, r, o, f) {
      Yd(e2, o, f, t, r, 7);
      let p = Number(e2 & BigInt(4294967295));
      t[r + 7] = p, p = p >> 8, t[r + 6] = p, p = p >> 8, t[r + 5] = p, p = p >> 8, t[r + 4] = p;
      let m = Number(e2 >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m, m = m >> 8, t[r + 2] = m, m = m >> 8, t[r + 1] = m, m = m >> 8, t[r] = m, r + 8;
    }
    me.prototype.writeBigUInt64LE = Ti(function(e2, r = 0) {
      return jd(this, e2, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeBigUInt64BE = Ti(function(e2, r = 0) {
      return Zd(this, e2, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeIntLE = function(e2, r, o, f) {
      if (e2 = +e2, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e2, r, o, M - 1, -M);
      }
      let p = 0, m = 1, y = 0;
      for (this[r] = e2 & 255;++p < o && (m *= 256); )
        e2 < 0 && y === 0 && this[r + p - 1] !== 0 && (y = 1), this[r + p] = (e2 / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeIntBE = function(e2, r, o, f) {
      if (e2 = +e2, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e2, r, o, M - 1, -M);
      }
      let p = o - 1, m = 1, y = 0;
      for (this[r + p] = e2 & 255;--p >= 0 && (m *= 256); )
        e2 < 0 && y === 0 && this[r + p + 1] !== 0 && (y = 1), this[r + p] = (e2 / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeInt8 = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 1, 127, -128), e2 < 0 && (e2 = 255 + e2 + 1), this[r] = e2 & 255, r + 1;
    };
    me.prototype.writeInt16LE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 2, 32767, -32768), this[r] = e2 & 255, this[r + 1] = e2 >>> 8, r + 2;
    };
    me.prototype.writeInt16BE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 2, 32767, -32768), this[r] = e2 >>> 8, this[r + 1] = e2 & 255, r + 2;
    };
    me.prototype.writeInt32LE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 4, 2147483647, -2147483648), this[r] = e2 & 255, this[r + 1] = e2 >>> 8, this[r + 2] = e2 >>> 16, this[r + 3] = e2 >>> 24, r + 4;
    };
    me.prototype.writeInt32BE = function(e2, r, o) {
      return e2 = +e2, r = r >>> 0, o || er(this, e2, r, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), this[r] = e2 >>> 24, this[r + 1] = e2 >>> 16, this[r + 2] = e2 >>> 8, this[r + 3] = e2 & 255, r + 4;
    };
    me.prototype.writeBigInt64LE = Ti(function(e2, r = 0) {
      return jd(this, e2, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    me.prototype.writeBigInt64BE = Ti(function(e2, r = 0) {
      return Zd(this, e2, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Vd(t, e2, r, o, f, p) {
      if (r + o > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function $d(t, e2, r, o, f) {
      return e2 = +e2, r = r >>> 0, f || Vd(t, e2, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e2, r, o, 23, 4), r + 4;
    }
    me.prototype.writeFloatLE = function(e2, r, o) {
      return $d(this, e2, r, true, o);
    };
    me.prototype.writeFloatBE = function(e2, r, o) {
      return $d(this, e2, r, false, o);
    };
    function Gd(t, e2, r, o, f) {
      return e2 = +e2, r = r >>> 0, f || Vd(t, e2, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e2, r, o, 52, 8), r + 8;
    }
    me.prototype.writeDoubleLE = function(e2, r, o) {
      return Gd(this, e2, r, true, o);
    };
    me.prototype.writeDoubleBE = function(e2, r, o) {
      return Gd(this, e2, r, false, o);
    };
    me.prototype.copy = function(e2, r, o, f) {
      if (!me.isBuffer(e2))
        throw new TypeError("argument should be a Buffer");
      if (o || (o = 0), !f && f !== 0 && (f = this.length), r >= e2.length && (r = e2.length), r || (r = 0), f > 0 && f < o && (f = o), f === o || e2.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o < 0 || o >= this.length)
        throw new RangeError("Index out of range");
      if (f < 0)
        throw new RangeError("sourceEnd out of bounds");
      f > this.length && (f = this.length), e2.length - r < f - o && (f = e2.length - r + o);
      let p = f - o;
      return this === e2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o, f) : Uint8Array.prototype.set.call(e2, this.subarray(o, f), r), p;
    };
    me.prototype.fill = function(e2, r, o, f) {
      if (typeof e2 == "string") {
        if (typeof r == "string" ? (f = r, r = 0, o = this.length) : typeof o == "string" && (f = o, o = this.length), f !== undefined && typeof f != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f == "string" && !me.isEncoding(f))
          throw new TypeError("Unknown encoding: " + f);
        if (e2.length === 1) {
          let m = e2.charCodeAt(0);
          (f === "utf8" && m < 128 || f === "latin1") && (e2 = m);
        }
      } else
        typeof e2 == "number" ? e2 = e2 & 255 : typeof e2 == "boolean" && (e2 = Number(e2));
      if (r < 0 || this.length < r || this.length < o)
        throw new RangeError("Out of range index");
      if (o <= r)
        return this;
      r = r >>> 0, o = o === undefined ? this.length : o >>> 0, e2 || (e2 = 0);
      let p;
      if (typeof e2 == "number")
        for (p = r;p < o; ++p)
          this[p] = e2;
      else {
        let m = me.isBuffer(e2) ? e2 : me.from(e2, f), y = m.length;
        if (y === 0)
          throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
        for (p = 0;p < o - r; ++p)
          this[p + r] = m[p % y];
      }
      return this;
    };
    var $n = {};
    function P0(t, e2, r) {
      $n[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e2.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    P0("ERR_INVALID_ARG_TYPE", function(t, e2) {
      return `The "${t}" argument must be of type number. Received type ${typeof e2}`;
    }, TypeError);
    P0("ERR_OUT_OF_RANGE", function(t, e2, r) {
      let o = `The value of "${t}" is out of range.`, f = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f = Fd(String(r)) : typeof r == "bigint" && (f = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f = Fd(f)), f += "n"), o += ` It must be ${e2}. Received ${f}`, o;
    }, RangeError);
    function Fd(t) {
      let e2 = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e2 = `_${t.slice(r - 3, r)}${e2}`;
      return `${t.slice(0, r)}${e2}`;
    }
    function Kw(t, e2, r) {
      Yn(e2, "offset"), (t[e2] === undefined || t[e2 + r] === undefined) && Vf(e2, t.length - (r + 1));
    }
    function Yd(t, e2, r, o, f, p) {
      if (t > r || t < e2) {
        let m = typeof e2 == "bigint" ? "n" : "", y;
        throw p > 3 ? e2 === 0 || e2 === BigInt(0) ? y = `>= 0${m} and < 2${m} ** ${(p + 1) * 8}${m}` : y = `>= -(2${m} ** ${(p + 1) * 8 - 1}${m}) and < 2 ** ${(p + 1) * 8 - 1}${m}` : y = `>= ${e2}${m} and <= ${r}${m}`, new $n.ERR_OUT_OF_RANGE("value", y, t);
      }
      Kw(o, f, p);
    }
    function Yn(t, e2) {
      if (typeof t != "number")
        throw new $n.ERR_INVALID_ARG_TYPE(e2, "number", t);
    }
    function Vf(t, e2, r) {
      throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e2 < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e2}`, t);
    }
    var jw = /[^+/0-9A-Za-z-_]/g;
    function Zw(t) {
      if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function L0(t, e2) {
      e2 = e2 || 1 / 0;
      let r, o = t.length, f = null, p = [];
      for (let m = 0;m < o; ++m) {
        if (r = t.charCodeAt(m), r > 55295 && r < 57344) {
          if (!f) {
            if (r > 56319) {
              (e2 -= 3) > -1 && p.push(239, 191, 189);
              continue;
            } else if (m + 1 === o) {
              (e2 -= 3) > -1 && p.push(239, 191, 189);
              continue;
            }
            f = r;
            continue;
          }
          if (r < 56320) {
            (e2 -= 3) > -1 && p.push(239, 191, 189), f = r;
            continue;
          }
          r = (f - 55296 << 10 | r - 56320) + 65536;
        } else
          f && (e2 -= 3) > -1 && p.push(239, 191, 189);
        if (f = null, r < 128) {
          if ((e2 -= 1) < 0)
            break;
          p.push(r);
        } else if (r < 2048) {
          if ((e2 -= 2) < 0)
            break;
          p.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e2 -= 3) < 0)
            break;
          p.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e2 -= 4) < 0)
            break;
          p.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p;
    }
    function Vw(t) {
      let e2 = [];
      for (let r = 0;r < t.length; ++r)
        e2.push(t.charCodeAt(r) & 255);
      return e2;
    }
    function $w(t, e2) {
      let r, o, f, p = [];
      for (let m = 0;m < t.length && !((e2 -= 2) < 0); ++m)
        r = t.charCodeAt(m), o = r >> 8, f = r % 256, p.push(f), p.push(o);
      return p;
    }
    function Xd(t) {
      return I0.toByteArray(Zw(t));
    }
    function to(t, e2, r, o) {
      let f;
      for (f = 0;f < o && !(f + r >= e2.length || f >= t.length); ++f)
        e2[f + r] = t[f];
      return f;
    }
    function Zr(t, e2) {
      return t instanceof e2 || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e2.name;
    }
    function C0(t) {
      return t !== t;
    }
    var Gw = function() {
      let t = "0123456789abcdef", e2 = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o = r * 16;
        for (let f = 0;f < 16; ++f)
          e2[o + f] = t[r] + t[f];
      }
      return e2;
    }();
    function Ti(t) {
      return typeof BigInt > "u" ? Yw : t;
    }
    function Yw() {
      throw new Error("BigInt not supported");
    }
  });
  Te = T((O0, Qd) => {
    var ro = Ut(), Vr = ro.Buffer;
    function Jd(t, e2) {
      for (var r in t)
        e2[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro : (Jd(ro, O0), O0.Buffer = an);
    function an(t, e2, r) {
      return Vr(t, e2, r);
    }
    an.prototype = Object.create(Vr.prototype);
    Jd(Vr, an);
    an.from = function(t, e2, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e2, r);
    };
    an.alloc = function(t, e2, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o = Vr(t);
      return e2 !== undefined ? typeof r == "string" ? o.fill(e2, r) : o.fill(e2) : o.fill(0), o;
    };
    an.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    an.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return ro.SlowBuffer(t);
    };
  });
  on = T((Gq, U0) => {
    var F0 = 65536, Xw = 4294967295;
    function Jw() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
    io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
    function e6(t, e2) {
      if (t > Xw)
        throw new RangeError("requested too many random bytes");
      var r = Qw.allocUnsafe(t);
      if (t > 0)
        if (t > F0)
          for (var o = 0;o < t; o += F0)
            io.getRandomValues(r.slice(o, o + F0));
        else
          io.getRandomValues(r);
      return typeof e2 == "function" ? process.nextTick(function() {
        e2(null, r);
      }) : r;
    }
  });
  Ie = T((Yq, z0) => {
    typeof Object.create == "function" ? z0.exports = function(e2, r) {
      r && (e2.super_ = r, e2.prototype = Object.create(r.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
    } : z0.exports = function(e2, r) {
      if (r) {
        e2.super_ = r;
        var o = function() {
        };
        o.prototype = r.prototype, e2.prototype = new o, e2.prototype.constructor = e2;
      }
    };
  });
  ki = T((Xq, H0) => {
    var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e2, r, o) {
      return Function.prototype.apply.call(e2, r, o);
    }, no;
    Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e2) {
      return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
    } : no = function(e2) {
      return Object.getOwnPropertyNames(e2);
    };
    function t6(t) {
      console && console.warn && console.warn(t);
    }
    var rc = Number.isNaN || function(e2) {
      return e2 !== e2;
    };
    function Fe() {
      Fe.init.call(this);
    }
    H0.exports = Fe;
    H0.exports.once = f6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var tc = 10;
    function fo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return tc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || rc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      tc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e2) {
      if (typeof e2 != "number" || e2 < 0 || rc(e2))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
      return this._maxListeners = e2, this;
    };
    function ic(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return ic(this);
    };
    Fe.prototype.emit = function(e2) {
      for (var r = [], o = 1;o < arguments.length; o++)
        r.push(arguments[o]);
      var f = e2 === "error", p = this._events;
      if (p !== undefined)
        f = f && p.error === undefined;
      else if (!f)
        return false;
      if (f) {
        var m;
        if (r.length > 0 && (m = r[0]), m instanceof Error)
          throw m;
        var y = new Error("Unhandled error." + (m ? " (" + m.message + ")" : ""));
        throw y.context = m, y;
      }
      var M = p[e2];
      if (M === undefined)
        return false;
      if (typeof M == "function")
        ec(M, this, r);
      else
        for (var x = M.length, S = sc(M, x), o = 0;o < x; ++o)
          ec(S[o], this, r);
      return true;
    };
    function nc(t, e2, r, o) {
      var f, p, m;
      if (fo(r), p = t._events, p === undefined ? (p = t._events = Object.create(null), t._eventsCount = 0) : (p.newListener !== undefined && (t.emit("newListener", e2, r.listener ? r.listener : r), p = t._events), m = p[e2]), m === undefined)
        m = p[e2] = r, ++t._eventsCount;
      else if (typeof m == "function" ? m = p[e2] = o ? [r, m] : [m, r] : o ? m.unshift(r) : m.push(r), f = ic(t), f > 0 && m.length > f && !m.warned) {
        m.warned = true;
        var y = new Error("Possible EventEmitter memory leak detected. " + m.length + " " + String(e2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y.name = "MaxListenersExceededWarning", y.emitter = t, y.type = e2, y.count = m.length, t6(y);
      }
      return t;
    }
    Fe.prototype.addListener = function(e2, r) {
      return nc(this, e2, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e2, r) {
      return nc(this, e2, r, true);
    };
    function r6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function fc(t, e2, r) {
      var o = { fired: false, wrapFn: undefined, target: t, type: e2, listener: r }, f = r6.bind(o);
      return f.listener = r, o.wrapFn = f, f;
    }
    Fe.prototype.once = function(e2, r) {
      return fo(r), this.on(e2, fc(this, e2, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e2, r) {
      return fo(r), this.prependListener(e2, fc(this, e2, r)), this;
    };
    Fe.prototype.removeListener = function(e2, r) {
      var o, f, p, m, y;
      if (fo(r), f = this._events, f === undefined)
        return this;
      if (o = f[e2], o === undefined)
        return this;
      if (o === r || o.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f[e2], f.removeListener && this.emit("removeListener", e2, o.listener || r));
      else if (typeof o != "function") {
        for (p = -1, m = o.length - 1;m >= 0; m--)
          if (o[m] === r || o[m].listener === r) {
            y = o[m].listener, p = m;
            break;
          }
        if (p < 0)
          return this;
        p === 0 ? o.shift() : i6(o, p), o.length === 1 && (f[e2] = o[0]), f.removeListener !== undefined && this.emit("removeListener", e2, y || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e2) {
      var r, o, f;
      if (o = this._events, o === undefined)
        return this;
      if (o.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o[e2] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o[e2]), this;
      if (arguments.length === 0) {
        var p = Object.keys(o), m;
        for (f = 0;f < p.length; ++f)
          m = p[f], m !== "removeListener" && this.removeAllListeners(m);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o[e2], typeof r == "function")
        this.removeListener(e2, r);
      else if (r !== undefined)
        for (f = r.length - 1;f >= 0; f--)
          this.removeListener(e2, r[f]);
      return this;
    };
    function ac(t, e2, r) {
      var o = t._events;
      if (o === undefined)
        return [];
      var f = o[e2];
      return f === undefined ? [] : typeof f == "function" ? r ? [f.listener || f] : [f] : r ? n6(f) : sc(f, f.length);
    }
    Fe.prototype.listeners = function(e2) {
      return ac(this, e2, true);
    };
    Fe.prototype.rawListeners = function(e2) {
      return ac(this, e2, false);
    };
    Fe.listenerCount = function(t, e2) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e2) : oc.call(t, e2);
    };
    Fe.prototype.listenerCount = oc;
    function oc(t) {
      var e2 = this._events;
      if (e2 !== undefined) {
        var r = e2[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? no(this._events) : [];
    };
    function sc(t, e2) {
      for (var r = new Array(e2), o = 0;o < e2; ++o)
        r[o] = t[o];
      return r;
    }
    function i6(t, e2) {
      for (;e2 + 1 < t.length; e2++)
        t[e2] = t[e2 + 1];
      t.pop();
    }
    function n6(t) {
      for (var e2 = new Array(t.length), r = 0;r < e2.length; ++r)
        e2[r] = t[r].listener || t[r];
      return e2;
    }
    function f6(t, e2) {
      return new Promise(function(r, o) {
        function f(m) {
          t.removeListener(e2, p), o(m);
        }
        function p() {
          typeof t.removeListener == "function" && t.removeListener("error", f), r([].slice.call(arguments));
        }
        hc(t, e2, p, { once: true }), e2 !== "error" && a6(t, f, { once: true });
      });
    }
    function a6(t, e2, r) {
      typeof t.on == "function" && hc(t, "error", e2, r);
    }
    function hc(t, e2, r, o) {
      if (typeof t.on == "function")
        o.once ? t.once(e2, r) : t.on(e2, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e2, function f(p) {
          o.once && t.removeEventListener(e2, f), r(p);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  W0 = T((Jq, uc) => {
    uc.exports = ki().EventEmitter;
  });
  $f = T(() => {
  });
  pc = T((tI, cc) => {
    function lc(t, e2) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e2 && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function o6(t) {
      for (var e2 = 1;e2 < arguments.length; e2++) {
        var r = arguments[e2] != null ? arguments[e2] : {};
        e2 % 2 ? lc(Object(r), true).forEach(function(o) {
          s6(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function s6(t, e2, r) {
      return e2 in t ? Object.defineProperty(t, e2, { value: r, enumerable: true, configurable: true, writable: true }) : t[e2] = r, t;
    }
    function h6(t, e2) {
      if (!(t instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    function dc(t, e2) {
      for (var r = 0;r < e2.length; r++) {
        var o = e2[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function u6(t, e2, r) {
      return e2 && dc(t.prototype, e2), r && dc(t, r), t;
    }
    var l6 = Ut(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
    function p6(t, e2, r) {
      ao.prototype.copy.call(t, e2, r);
    }
    cc.exports = function() {
      function t() {
        h6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return u6(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ao.alloc(0);
        for (var o = ao.allocUnsafe(r >>> 0), f = this.head, p = 0;f; )
          p6(f.data, o, p), p += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = ao.allocUnsafe(r), f = this.head, p = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: c6, value: function(r, o) {
        return K0(this, o6({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  Z0 = T((rI, bc) => {
    function v6(t, e2) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e2 ? e2(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e2 && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc, r, p)) : process.nextTick(vc, r, p) : e2 ? (process.nextTick(oo, r), e2(p)) : process.nextTick(oo, r);
      }), this);
    }
    function vc(t, e2) {
      j0(t, e2), oo(t);
    }
    function oo(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function b6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function j0(t, e2) {
      t.emit("error", e2);
    }
    function m6(t, e2) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e2) : t.emit("error", e2);
    }
    bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
  });
  sn = T((iI, yc) => {
    function g6(t, e2) {
      t.prototype = Object.create(e2.prototype), t.prototype.constructor = t, t.__proto__ = e2;
    }
    var gc = {};
    function dr(t, e2, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e2 == "string" ? e2 : e2(p, m, y);
      }
      var f = function(p) {
        g6(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gc[t] = f;
    }
    function mc(t, e2) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e2, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e2, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e2, " ").concat(t[0]);
      } else
        return "of ".concat(e2, " ").concat(String(t));
    }
    function y6(t, e2, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e2.length) === e2;
    }
    function w6(t, e2, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e2.length, r) === e2;
    }
    function M6(t, e2, r) {
      return typeof r != "number" && (r = 0), r + e2.length > t.length ? false : t.indexOf(e2, r) !== -1;
    }
    dr("ERR_INVALID_OPT_VALUE", function(t, e2) {
      return 'The value "' + e2 + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr("ERR_INVALID_ARG_TYPE", function(t, e2, r) {
      var o;
      typeof e2 == "string" && y6(e2, "not ") ? (o = "must not be", e2 = e2.replace(/^not /, "")) : o = "must be";
      var f;
      if (w6(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mc(e2, "type"));
      else {
        var p = M6(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(mc(e2, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    dr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yc.exports.codes = gc;
  });
  V0 = T((nI, wc) => {
    var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
    function x6(t, e2, r) {
      return t.highWaterMark != null ? t.highWaterMark : e2 ? t[r] : null;
    }
    function S6(t, e2, r, o) {
      var f = x6(e2, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p = o ? r : "highWaterMark";
          throw new _6(p, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wc.exports = { getHighWaterMark: S6 };
  });
  G0 = T((fI, Mc) => {
    Mc.exports = E6;
    function E6(t, e2) {
      if ($0("noDeprecation"))
        return t;
      var r = false;
      function o() {
        if (!r) {
          if ($0("throwDeprecation"))
            throw new Error(e2);
          $0("traceDeprecation") ? console.trace(e2) : console.warn(e2), r = true;
        }
        return t.apply(this, arguments);
      }
      return o;
    }
    function $0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e2 = global.localStorage[t];
      return e2 == null ? false : String(e2).toLowerCase() === "true";
    }
  });
  J0 = T((aI, Rc) => {
    Rc.exports = ht;
    function xc(t) {
      var e2 = this;
      this.next = null, this.entry = null, this.finish = function() {
        J6(e2, t);
      };
    }
    var Qn;
    ht.WritableState = Yf;
    var A6 = { deprecate: G0() }, Sc = W0(), ho = Ut().Buffer, R6 = global.Uint8Array || function() {
    };
    function B6(t) {
      return ho.from(t);
    }
    function q6(t) {
      return ho.isBuffer(t) || t instanceof R6;
    }
    var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li = sn().codes, k6 = Li.ERR_INVALID_ARG_TYPE, L6 = Li.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li.ERR_MULTIPLE_CALLBACK, D6 = Li.ERR_STREAM_CANNOT_PIPE, P6 = Li.ERR_STREAM_DESTROYED, C6 = Li.ERR_STREAM_NULL_VALUES, O6 = Li.ERR_STREAM_WRITE_AFTER_END, F6 = Li.ERR_UNKNOWN_ENCODING, ef = X0.errorOrDestroy;
    Ie()(ht, Sc);
    function U6() {
    }
    function Yf(t, e2, r) {
      Qn = Qn || hn(), t = t || {}, typeof r != "boolean" && (r = e2 instanceof Qn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        V6(e2, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
    }
    Yf.prototype.getBuffer = function() {
      for (var e2 = this.bufferedRequest, r = [];e2; )
        r.push(e2), e2 = e2.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var so;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, { value: function(e2) {
      return so.call(this, e2) ? true : this !== ht ? false : e2 && e2._writableState instanceof Yf;
    } })) : so = function(e2) {
      return e2 instanceof this;
    };
    function ht(t) {
      Qn = Qn || hn();
      var e2 = this instanceof Qn;
      if (!e2 && !so.call(ht, this))
        return new ht(t);
      this._writableState = new Yf(t, this, e2), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc.call(this);
    }
    ht.prototype.pipe = function() {
      ef(this, new D6);
    };
    function z6(t, e2) {
      var r = new O6;
      ef(t, r), process.nextTick(e2, r);
    }
    function H6(t, e2, r, o) {
      var f;
      return r === null ? f = new C6 : typeof r != "string" && !e2.objectMode && (f = new k6("chunk", ["string", "Buffer"], r)), f ? (ef(t, f), process.nextTick(o, f), false) : true;
    }
    ht.prototype.write = function(t, e2, r) {
      var o = this._writableState, f = false, p = !o.objectMode && q6(t);
      return p && !ho.isBuffer(t) && (t = B6(t)), typeof e2 == "function" && (r = e2, e2 = null), p ? e2 = "buffer" : e2 || (e2 = o.defaultEncoding), typeof r != "function" && (r = U6), o.ending ? z6(this, r) : (p || H6(this, o, t, r)) && (o.pendingcb++, f = K6(this, o, p, t, e2, r)), f;
    };
    ht.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
    };
    ht.prototype.setDefaultEncoding = function(e2) {
      if (typeof e2 == "string" && (e2 = e2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase()) > -1))
        throw new F6(e2);
      return this._writableState.defaultEncoding = e2, this;
    };
    Object.defineProperty(ht.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function W6(t, e2, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e2 == "string" && (e2 = ho.from(e2, r)), e2;
    }
    Object.defineProperty(ht.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function K6(t, e2, r, o, f, p) {
      if (!r) {
        var m = W6(e2, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e2.objectMode ? 1 : o.length;
      e2.length += y;
      var M = e2.length < e2.highWaterMark;
      if (M || (e2.needDrain = true), e2.writing || e2.corked) {
        var x = e2.lastBufferedRequest;
        e2.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p, next: null }, x ? x.next = e2.lastBufferedRequest : e2.bufferedRequest = e2.lastBufferedRequest, e2.bufferedRequestCount += 1;
      } else
        Y0(t, e2, false, y, o, f, p);
      return M;
    }
    function Y0(t, e2, r, o, f, p, m) {
      e2.writelen = o, e2.writecb = m, e2.writing = true, e2.sync = true, e2.destroyed ? e2.onwrite(new P6("write")) : r ? t._writev(f, e2.onwrite) : t._write(f, p, e2.onwrite), e2.sync = false;
    }
    function j6(t, e2, r, o, f) {
      --e2.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Gf, t, e2), t._writableState.errorEmitted = true, ef(t, o)) : (f(o), t._writableState.errorEmitted = true, ef(t, o), Gf(t, e2));
    }
    function Z6(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function V6(t, e2) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new N6;
      if (Z6(r), e2)
        j6(t, r, o, e2, f);
      else {
        var p = Ac(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o ? process.nextTick(_c, t, r, p, f) : _c(t, r, p, f);
      }
    }
    function _c(t, e2, r, o) {
      r || $6(t, e2), e2.pendingcb--, o(), Gf(t, e2);
    }
    function $6(t, e2) {
      e2.length === 0 && e2.needDrain && (e2.needDrain = false, t.emit("drain"));
    }
    function Ec(t, e2) {
      e2.bufferProcessing = true;
      var r = e2.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e2.bufferedRequestCount, f = new Array(o), p = e2.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, Y0(t, e2, true, e2.length, f, "", p.finish), e2.pendingcb++, e2.lastBufferedRequest = null, p.next ? (e2.corkedRequestsFree = p.next, p.next = null) : e2.corkedRequestsFree = new xc(e2), e2.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S } = r, E = e2.objectMode ? 1 : M.length;
          if (Y0(t, e2, false, E, M, x, S), r = r.next, e2.bufferedRequestCount--, e2.writing)
            break;
        }
        r === null && (e2.lastBufferedRequest = null);
      }
      e2.bufferedRequest = r, e2.bufferProcessing = false;
    }
    ht.prototype._write = function(t, e2, r) {
      r(new L6("_write()"));
    };
    ht.prototype._writev = null;
    ht.prototype.end = function(t, e2, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e2 = null) : typeof e2 == "function" && (r = e2, e2 = null), t != null && this.write(t, e2), o.corked && (o.corked = 1, this.uncork()), o.ending || X6(this, o, r), this;
    };
    Object.defineProperty(ht.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ac(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function G6(t, e2) {
      t._final(function(r) {
        e2.pendingcb--, r && ef(t, r), e2.prefinished = true, t.emit("prefinish"), Gf(t, e2);
      });
    }
    function Y6(t, e2) {
      !e2.prefinished && !e2.finalCalled && (typeof t._final == "function" && !e2.destroyed ? (e2.pendingcb++, e2.finalCalled = true, process.nextTick(G6, t, e2)) : (e2.prefinished = true, t.emit("prefinish")));
    }
    function Gf(t, e2) {
      var r = Ac(e2);
      if (r && (Y6(t, e2), e2.pendingcb === 0 && (e2.finished = true, t.emit("finish"), e2.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function X6(t, e2, r) {
      e2.ending = true, Gf(t, e2), r && (e2.finished ? process.nextTick(r) : t.once("finish", r)), e2.ended = true, t.writable = false;
    }
    function J6(t, e2, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e2.pendingcb--, f(r), o = o.next;
      }
      e2.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e2) {
      !this._writableState || (this._writableState.destroyed = e2);
    } });
    ht.prototype.destroy = X0.destroy;
    ht.prototype._undestroy = X0.undestroy;
    ht.prototype._destroy = function(t, e2) {
      e2(t);
    };
  });
  hn = T((oI, qc) => {
    var Q6 = Object.keys || function(t) {
      var e2 = [];
      for (var r in t)
        e2.push(r);
      return e2;
    };
    qc.exports = $r;
    var Bc = th(), eh = J0();
    Ie()($r, Bc);
    for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
      lo = Q0[uo], $r.prototype[lo] || ($r.prototype[lo] = eh.prototype[lo]);
    var Q0, lo, uo;
    function $r(t) {
      if (!(this instanceof $r))
        return new $r(t);
      Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
    }
    Object.defineProperty($r.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function eM() {
      this._writableState.ended || process.nextTick(tM, this);
    }
    function tM(t) {
      t.end();
    }
    Object.defineProperty($r.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e2) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
    } });
  });
  co = T((Tc) => {
    var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function rM(t) {
      if (!t)
        return "utf8";
      for (var e2;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e2)
              return;
            t = ("" + t).toLowerCase(), e2 = true;
        }
    }
    function iM(t) {
      var e2 = rM(t);
      if (typeof e2 != "string" && (ih.isEncoding === Ic || !Ic(t)))
        throw new Error("Unknown encoding: " + t);
      return e2 || t;
    }
    Tc.StringDecoder = Xf;
    function Xf(t) {
      this.encoding = iM(t);
      var e2;
      switch (this.encoding) {
        case "utf16le":
          this.text = hM, this.end = uM, e2 = 4;
          break;
        case "utf8":
          this.fillLast = aM, e2 = 4;
          break;
        case "base64":
          this.text = lM, this.end = dM, e2 = 3;
          break;
        default:
          this.write = cM, this.end = pM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e2);
    }
    Xf.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e2, r;
      if (this.lastNeed) {
        if (e2 = this.fillLast(t), e2 === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e2 ? e2 + this.text(t, r) : this.text(t, r) : e2 || "";
    };
    Xf.prototype.end = sM;
    Xf.prototype.text = oM;
    Xf.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function rh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function nM(t, e2, r) {
      var o = e2.length - 1;
      if (o < r)
        return 0;
      var f = rh(e2[o]);
      return f >= 0 ? (f > 0 && (t.lastNeed = f - 1), f) : --o < r || f === -2 ? 0 : (f = rh(e2[o]), f >= 0 ? (f > 0 && (t.lastNeed = f - 2), f) : --o < r || f === -2 ? 0 : (f = rh(e2[o]), f >= 0 ? (f > 0 && (f === 2 ? f = 0 : t.lastNeed = f - 3), f) : 0));
    }
    function fM(t, e2, r) {
      if ((e2[0] & 192) !== 128)
        return t.lastNeed = 0, "�";
      if (t.lastNeed > 1 && e2.length > 1) {
        if ((e2[1] & 192) !== 128)
          return t.lastNeed = 1, "�";
        if (t.lastNeed > 2 && e2.length > 2 && (e2[2] & 192) !== 128)
          return t.lastNeed = 2, "�";
      }
    }
    function aM(t) {
      var e2 = this.lastTotal - this.lastNeed, r = fM(this, t, e2);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e2, 0, t.length), this.lastNeed -= t.length;
    }
    function oM(t, e2) {
      var r = nM(this, t, e2);
      if (!this.lastNeed)
        return t.toString("utf8", e2);
      this.lastTotal = r;
      var o = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o), t.toString("utf8", e2, o);
    }
    function sM(t) {
      var e2 = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e2 + "�" : e2;
    }
    function hM(t, e2) {
      if ((t.length - e2) % 2 === 0) {
        var r = t.toString("utf16le", e2);
        if (r) {
          var o = r.charCodeAt(r.length - 1);
          if (o >= 55296 && o <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e2, t.length - 1);
    }
    function uM(t) {
      var e2 = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e2 + this.lastChar.toString("utf16le", 0, r);
      }
      return e2;
    }
    function lM(t, e2) {
      var r = (t.length - e2) % 3;
      return r === 0 ? t.toString("base64", e2) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e2, t.length - r));
    }
    function dM(t) {
      var e2 = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e2;
    }
    function cM(t) {
      return t.toString(this.encoding);
    }
    function pM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  Jf = {};
  Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
  Qf = R0(() => {
    po = rn(co());
  });
  vo = T((hI, Nc) => {
    var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function vM(t) {
      var e2 = false;
      return function() {
        if (!e2) {
          e2 = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function bM() {
    }
    function mM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Lc(t, e2, r) {
      if (typeof e2 == "function")
        return Lc(t, null, e2);
      e2 || (e2 = {}), r = vM(r || bM);
      var o = e2.readable || e2.readable !== false && t.readable, f = e2.writable || e2.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S = function(L) {
        r.call(t, L);
      }, E = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new kc), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new kc), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return mM(t) ? (t.on("complete", y), t.on("abort", E), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e2.error !== false && t.on("error", S), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S), t.removeListener("close", E);
      };
    }
    Nc.exports = Lc;
  });
  Pc = T((uI, Dc) => {
    var bo;
    function Ni(t, e2, r) {
      return e2 in t ? Object.defineProperty(t, e2, { value: r, enumerable: true, configurable: true, writable: true }) : t[e2] = r, t;
    }
    var gM = vo(), Di = Symbol("lastResolve"), un = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln2 = Symbol("lastPromise"), nh = Symbol("handlePromise"), dn = Symbol("stream");
    function Pi(t, e2) {
      return { value: t, done: e2 };
    }
    function yM(t) {
      var e2 = t[Di];
      if (e2 !== null) {
        var r = t[dn].read();
        r !== null && (t[ln2] = null, t[Di] = null, t[un] = null, e2(Pi(r, false)));
      }
    }
    function wM(t) {
      process.nextTick(yM, t);
    }
    function MM(t, e2) {
      return function(r, o) {
        t.then(function() {
          if (e2[mo]) {
            r(Pi(undefined, true));
            return;
          }
          e2[nh](r, o);
        }, o);
      };
    }
    var _M = Object.getPrototypeOf(function() {
    }), xM = Object.setPrototypeOf((bo = { get stream() {
      return this[dn];
    }, next: function() {
      var e2 = this, r = this[ea];
      if (r !== null)
        return Promise.reject(r);
      if (this[mo])
        return Promise.resolve(Pi(undefined, true));
      if (this[dn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e2[ea] ? y(e2[ea]) : m(Pi(undefined, true));
          });
        });
      var o = this[ln2], f;
      if (o)
        f = new Promise(MM(o, this));
      else {
        var p = this[dn].read();
        if (p !== null)
          return Promise.resolve(Pi(p, false));
        f = new Promise(this[nh]);
      }
      return this[ln2] = f, f;
    } }, Ni(bo, Symbol.asyncIterator, function() {
      return this;
    }), Ni(bo, "return", function() {
      var e2 = this;
      return new Promise(function(r, o) {
        e2[dn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Pi(undefined, true));
        });
      });
    }), bo), _M), SM = function(e2) {
      var r, o = Object.create(xM, (r = {}, Ni(r, dn, { value: e2, writable: true }), Ni(r, Di, { value: null, writable: true }), Ni(r, un, { value: null, writable: true }), Ni(r, ea, { value: null, writable: true }), Ni(r, mo, { value: e2._readableState.endEmitted, writable: true }), Ni(r, nh, { value: function(p, m) {
        var y = o[dn].read();
        y ? (o[ln2] = null, o[Di] = null, o[un] = null, p(Pi(y, false))) : (o[Di] = p, o[un] = m);
      }, writable: true }), r));
      return o[ln2] = null, gM(e2, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[un];
          p !== null && (o[ln2] = null, o[Di] = null, o[un] = null, p(f)), o[ea] = f;
          return;
        }
        var m = o[Di];
        m !== null && (o[ln2] = null, o[Di] = null, o[un] = null, m(Pi(undefined, true))), o[mo] = true;
      }), e2.on("readable", wM.bind(null, o)), o;
    };
    Dc.exports = SM;
  });
  Oc = T((lI, Cc) => {
    Cc.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  th = T((cI, $c) => {
    $c.exports = Ce;
    var tf;
    Ce.ReadableState = Hc;
    var dI = ki().EventEmitter, zc = function(e2, r) {
      return e2.listeners(r).length;
    }, ra = W0(), go = Ut().Buffer, EM = global.Uint8Array || function() {
    };
    function AM(t) {
      return go.from(t);
    }
    function RM(t) {
      return go.isBuffer(t) || t instanceof EM;
    }
    var fh = $f(), Ne;
    fh && fh.debuglog ? Ne = fh.debuglog("stream") : Ne = function() {
    };
    var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
    Ie()(Ce, ra);
    var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
    function DM(t, e2, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e2, r);
      !t._events || !t._events[e2] ? t.on(e2, r) : Array.isArray(t._events[e2]) ? t._events[e2].unshift(r) : t._events[e2] = [r, t._events[e2]];
    }
    function Hc(t, e2, r) {
      tf = tf || hn(), t = t || {}, typeof r != "boolean" && (r = e2 instanceof tf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
    }
    function Ce(t) {
      if (tf = tf || hn(), !(this instanceof Ce))
        return new Ce(t);
      var e2 = this instanceof tf;
      this._readableState = new Hc(t, this, e2), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
    }
    Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e2) {
      !this._readableState || (this._readableState.destroyed = e2);
    } });
    Ce.prototype.destroy = dh.destroy;
    Ce.prototype._undestroy = dh.undestroy;
    Ce.prototype._destroy = function(t, e2) {
      e2(t);
    };
    Ce.prototype.push = function(t, e2) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e2 = e2 || r.defaultEncoding, e2 !== r.encoding && (t = go.from(t, e2), e2 = ""), o = true), Wc(this, t, e2, false, o);
    };
    Ce.prototype.unshift = function(t) {
      return Wc(this, t, null, true, false);
    };
    function Wc(t, e2, r, o, f) {
      Ne("readableAddChunk", e2);
      var p = t._readableState;
      if (e2 === null)
        p.reading = false, OM(t, p);
      else {
        var m;
        if (f || (m = PM(p, e2)), m)
          ta(t, m);
        else if (p.objectMode || e2 && e2.length > 0)
          if (typeof e2 != "string" && !p.objectMode && Object.getPrototypeOf(e2) !== go.prototype && (e2 = AM(e2)), o)
            p.endEmitted ? ta(t, new NM) : hh(t, p, e2, true);
          else if (p.ended)
            ta(t, new kM);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e2 = p.decoder.write(e2), p.objectMode || e2.length !== 0 ? hh(t, p, e2, false) : lh(t, p)) : hh(t, p, e2, false);
          }
        else
          o || (p.reading = false, lh(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function hh(t, e2, r, o) {
      e2.flowing && e2.length === 0 && !e2.sync ? (e2.awaitDrain = 0, t.emit("data", r)) : (e2.length += e2.objectMode ? 1 : r.length, o ? e2.buffer.unshift(r) : e2.buffer.push(r), e2.needReadable && wo(t)), lh(t, e2);
    }
    function PM(t, e2) {
      var r;
      return !RM(e2) && typeof e2 != "string" && e2 !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e2)), r;
    }
    Ce.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce.prototype.setEncoding = function(t) {
      rf || (rf = (Qf(), ur(Jf)).StringDecoder);
      var e2 = new rf(t);
      this._readableState.decoder = e2, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e2.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Fc = 1073741824;
    function CM(t) {
      return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Uc(t, e2) {
      return t <= 0 || e2.length === 0 && e2.ended ? 0 : e2.objectMode ? 1 : t !== t ? e2.flowing && e2.length ? e2.buffer.head.data.length : e2.length : (t > e2.highWaterMark && (e2.highWaterMark = CM(t)), t <= e2.length ? t : e2.ended ? e2.length : (e2.needReadable = true, 0));
    }
    Ce.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e2 = this._readableState, r = t;
      if (t !== 0 && (e2.emittedReadable = false), t === 0 && e2.needReadable && ((e2.highWaterMark !== 0 ? e2.length >= e2.highWaterMark : e2.length > 0) || e2.ended))
        return Ne("read: emitReadable", e2.length, e2.ended), e2.length === 0 && e2.ended ? uh(this) : wo(this), null;
      if (t = Uc(t, e2), t === 0 && e2.ended)
        return e2.length === 0 && uh(this), null;
      var o = e2.needReadable;
      Ne("need readable", o), (e2.length === 0 || e2.length - t < e2.highWaterMark) && (o = true, Ne("length less than watermark", o)), e2.ended || e2.reading ? (o = false, Ne("reading or ended", o)) : o && (Ne("do read"), e2.reading = true, e2.sync = true, e2.length === 0 && (e2.needReadable = true), this._read(e2.highWaterMark), e2.sync = false, e2.reading || (t = Uc(r, e2)));
      var f;
      return t > 0 ? f = Zc(t, e2) : f = null, f === null ? (e2.needReadable = e2.length <= e2.highWaterMark, t = 0) : (e2.length -= t, e2.awaitDrain = 0), e2.length === 0 && (e2.ended || (e2.needReadable = true), r !== t && e2.ended && uh(this)), f !== null && this.emit("data", f), f;
    };
    function OM(t, e2) {
      if (Ne("onEofChunk"), !e2.ended) {
        if (e2.decoder) {
          var r = e2.decoder.end();
          r && r.length && (e2.buffer.push(r), e2.length += e2.objectMode ? 1 : r.length);
        }
        e2.ended = true, e2.sync ? wo(t) : (e2.needReadable = false, e2.emittedReadable || (e2.emittedReadable = true, Kc(t)));
      }
    }
    function wo(t) {
      var e2 = t._readableState;
      Ne("emitReadable", e2.needReadable, e2.emittedReadable), e2.needReadable = false, e2.emittedReadable || (Ne("emitReadable", e2.flowing), e2.emittedReadable = true, process.nextTick(Kc, t));
    }
    function Kc(t) {
      var e2 = t._readableState;
      Ne("emitReadable_", e2.destroyed, e2.length, e2.ended), !e2.destroyed && (e2.length || e2.ended) && (t.emit("readable"), e2.emittedReadable = false), e2.needReadable = !e2.flowing && !e2.ended && e2.length <= e2.highWaterMark, ch(t);
    }
    function lh(t, e2) {
      e2.readingMore || (e2.readingMore = true, process.nextTick(FM, t, e2));
    }
    function FM(t, e2) {
      for (;!e2.reading && !e2.ended && (e2.length < e2.highWaterMark || e2.flowing && e2.length === 0); ) {
        var r = e2.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e2.length)
          break;
      }
      e2.readingMore = false;
    }
    Ce.prototype._read = function(t) {
      ta(this, new LM("_read()"));
    };
    Ce.prototype.pipe = function(t, e2) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, Ne("pipe count=%d opts=%j", o.pipesCount, e2);
      var f = (!e2 || e2.end !== false) && t !== process.stdout && t !== process.stderr, p = f ? y : ge;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, N) {
        Ne("onunpipe"), _e === r && N && N.hasUnpiped === false && (N.hasUnpiped = true, S());
      }
      function y() {
        Ne("onend"), t.end();
      }
      var M = UM(r);
      t.on("drain", M);
      var x = false;
      function S() {
        Ne("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        Ne("ondata");
        var N = t.write(_e);
        Ne("dest.write", N), N === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Vc(o.pipes, t) !== -1) && !x && (Ne("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        Ne("onerror", _e), ge(), t.removeListener("error", B), zc(t, "error") === 0 && ta(t, _e);
      }
      DM(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        Ne("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function UM(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc(t, "data") && (r.flowing = true, ch(t));
      };
    }
    Ce.prototype.unpipe = function(t) {
      var e2 = this._readableState, r = { hasUnpiped: false };
      if (e2.pipesCount === 0)
        return this;
      if (e2.pipesCount === 1)
        return t && t !== e2.pipes ? this : (t || (t = e2.pipes), e2.pipes = null, e2.pipesCount = 0, e2.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e2;
        e2.pipes = null, e2.pipesCount = 0, e2.flowing = false;
        for (var p = 0;p < f; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Vc(e2.pipes, t);
      return m === -1 ? this : (e2.pipes.splice(m, 1), e2.pipesCount -= 1, e2.pipesCount === 1 && (e2.pipes = e2.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce.prototype.on = function(t, e2) {
      var r = ra.prototype.on.call(this, t, e2), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Ne("on readable", o.length, o.reading), o.length ? wo(this) : o.reading || process.nextTick(zM, this)), r;
    };
    Ce.prototype.addListener = Ce.prototype.on;
    Ce.prototype.removeListener = function(t, e2) {
      var r = ra.prototype.removeListener.call(this, t, e2);
      return t === "readable" && process.nextTick(jc, this), r;
    };
    Ce.prototype.removeAllListeners = function(t) {
      var e2 = ra.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(jc, this), e2;
    };
    function jc(t) {
      var e2 = t._readableState;
      e2.readableListening = t.listenerCount("readable") > 0, e2.resumeScheduled && !e2.paused ? e2.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function zM(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
    };
    function HM(t, e2) {
      e2.resumeScheduled || (e2.resumeScheduled = true, process.nextTick(WM, t, e2));
    }
    function WM(t, e2) {
      Ne("resume", e2.reading), e2.reading || t.read(0), e2.resumeScheduled = false, t.emit("resume"), ch(t), e2.flowing && !e2.reading && t.read(0);
    }
    Ce.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ch(t) {
      var e2 = t._readableState;
      for (Ne("flow", e2.flowing);e2.flowing && t.read() !== null; )
        ;
    }
    Ce.prototype.wrap = function(t) {
      var e2 = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e2.push(m);
        }
        e2.push(null);
      }), t.on("data", function(m) {
        if (Ne("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e2.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p = 0;p < sh.length; p++)
        t.on(sh[p], this.emit.bind(this, sh[p]));
      return this._read = function(m) {
        Ne("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
      return ah === undefined && (ah = Pc()), ah(this);
    });
    Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e2) {
      this._readableState && (this._readableState.flowing = e2);
    } });
    Ce._fromList = Zc;
    Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Zc(t, e2) {
      if (e2.length === 0)
        return null;
      var r;
      return e2.objectMode ? r = e2.buffer.shift() : !t || t >= e2.length ? (e2.decoder ? r = e2.buffer.join("") : e2.buffer.length === 1 ? r = e2.buffer.first() : r = e2.buffer.concat(e2.length), e2.buffer.clear()) : r = e2.buffer.consume(t, e2.decoder), r;
    }
    function uh(t) {
      var e2 = t._readableState;
      Ne("endReadable", e2.endEmitted), e2.endEmitted || (e2.ended = true, process.nextTick(KM, e2, t));
    }
    function KM(t, e2) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e2.readable = false, e2.emit("end"), t.autoDestroy)) {
        var r = e2._writableState;
        (!r || r.autoDestroy && r.finished) && e2.destroy();
      }
    }
    typeof Symbol == "function" && (Ce.from = function(t, e2) {
      return oh === undefined && (oh = Oc()), oh(Ce, t, e2);
    });
    function Vc(t, e2) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e2)
          return r;
      return -1;
    }
  });
  ph = T((pI, Yc) => {
    Yc.exports = di;
    var Mo = sn().codes, jM = Mo.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo.ERR_MULTIPLE_CALLBACK, VM = Mo.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
    Ie()(di, _o);
    function GM(t, e2) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new ZM);
      r.writechunk = null, r.writecb = null, e2 != null && this.push(e2), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function di(t) {
      if (!(this instanceof di))
        return new di(t);
      _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
    }
    function YM() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e2, r) {
        Gc(t, e2, r);
      }) : Gc(this, null, null);
    }
    di.prototype.push = function(t, e2) {
      return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e2);
    };
    di.prototype._transform = function(t, e2, r) {
      r(new jM("_transform()"));
    };
    di.prototype._write = function(t, e2, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e2, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    di.prototype._read = function(t) {
      var e2 = this._transformState;
      e2.writechunk !== null && !e2.transforming ? (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform)) : e2.needTransform = true;
    };
    di.prototype._destroy = function(t, e2) {
      _o.prototype._destroy.call(this, t, function(r) {
        e2(r);
      });
    };
    function Gc(t, e2, r) {
      if (e2)
        return t.emit("error", e2);
      if (r != null && t.push(r), t._writableState.length)
        throw new $M;
      if (t._transformState.transforming)
        throw new VM;
      return t.push(null);
    }
  });
  Qc = T((vI, Jc) => {
    Jc.exports = ia;
    var Xc = ph();
    Ie()(ia, Xc);
    function ia(t) {
      if (!(this instanceof ia))
        return new ia(t);
      Xc.call(this, t);
    }
    ia.prototype._transform = function(t, e2, r) {
      r(null, t);
    };
  });
  np = T((bI, ip) => {
    var vh;
    function XM(t) {
      var e2 = false;
      return function() {
        e2 || (e2 = true, t.apply(undefined, arguments));
      };
    }
    var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
    function ep(t) {
      if (t)
        throw t;
    }
    function e4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function t4(t, e2, r, o) {
      o = XM(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), vh === undefined && (vh = vo()), vh(t, { readable: e2, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p = false;
      return function(m) {
        if (!f && !p) {
          if (p = true, e4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new QM("pipe"));
        }
      };
    }
    function tp(t) {
      t();
    }
    function r4(t, e2) {
      return t.pipe(e2);
    }
    function i4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
    }
    function n4() {
      for (var t = arguments.length, e2 = new Array(t), r = 0;r < t; r++)
        e2[r] = arguments[r];
      var o = i4(e2);
      if (Array.isArray(e2[0]) && (e2 = e2[0]), e2.length < 2)
        throw new JM("streams");
      var f, p = e2.map(function(m, y) {
        var M = y < e2.length - 1, x = y > 0;
        return t4(m, M, x, function(S) {
          f || (f = S), S && p.forEach(tp), !M && (p.forEach(tp), o(f));
        });
      });
      return e2.reduce(r4);
    }
    ip.exports = n4;
  });
  ap = T((cr, fp) => {
    cr = fp.exports = th();
    cr.Stream = cr;
    cr.Readable = cr;
    cr.Writable = J0();
    cr.Duplex = hn();
    cr.Transform = ph();
    cr.PassThrough = Qc();
    cr.finished = vo();
    cr.pipeline = np();
  });
  bh = T((mI, sp) => {
    var xo = Te().Buffer, op = ap().Transform, f4 = Ie();
    function a4(t, e2) {
      if (!xo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e2 + " must be a string or a buffer");
    }
    function Ci(t) {
      op.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    f4(Ci, op);
    Ci.prototype._transform = function(t, e2, r) {
      var o = null;
      try {
        this.update(t, e2);
      } catch (f) {
        o = f;
      }
      r(o);
    };
    Ci.prototype._flush = function(t) {
      var e2 = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e2 = r;
      }
      t(e2);
    };
    Ci.prototype.update = function(t, e2) {
      if (a4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      xo.isBuffer(t) || (t = xo.from(t, e2));
      for (var r = this._block, o = 0;this._blockOffset + t.length - o >= this._blockSize; ) {
        for (var f = this._blockOffset;f < this._blockSize; )
          r[f++] = t[o++];
        this._update(), this._blockOffset = 0;
      }
      for (;o < t.length; )
        r[this._blockOffset++] = t[o++];
      for (var p = 0, m = t.length * 8;m > 0; ++p)
        this._length[p] += m, m = this._length[p] / 4294967296 | 0, m > 0 && (this._length[p] -= 4294967296 * m);
      return this;
    };
    Ci.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    Ci.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e2 = this._digest();
      t !== undefined && (e2 = e2.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e2;
    };
    Ci.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    sp.exports = Ci;
  });
  Ao = T((gI, up) => {
    var o4 = Ie(), hp = bh(), s4 = Te().Buffer, h4 = new Array(16);
    function So() {
      hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    o4(So, hp);
    So.prototype._update = function() {
      for (var t = h4, e2 = 0;e2 < 16; ++e2)
        t[e2] = this._block.readInt32LE(e2 * 4);
      var r = this._a, o = this._b, f = this._c, p = this._d;
      r = jt(r, o, f, p, t[0], 3614090360, 7), p = jt(p, r, o, f, t[1], 3905402710, 12), f = jt(f, p, r, o, t[2], 606105819, 17), o = jt(o, f, p, r, t[3], 3250441966, 22), r = jt(r, o, f, p, t[4], 4118548399, 7), p = jt(p, r, o, f, t[5], 1200080426, 12), f = jt(f, p, r, o, t[6], 2821735955, 17), o = jt(o, f, p, r, t[7], 4249261313, 22), r = jt(r, o, f, p, t[8], 1770035416, 7), p = jt(p, r, o, f, t[9], 2336552879, 12), f = jt(f, p, r, o, t[10], 4294925233, 17), o = jt(o, f, p, r, t[11], 2304563134, 22), r = jt(r, o, f, p, t[12], 1804603682, 7), p = jt(p, r, o, f, t[13], 4254626195, 12), f = jt(f, p, r, o, t[14], 2792965006, 17), o = jt(o, f, p, r, t[15], 1236535329, 22), r = Zt(r, o, f, p, t[1], 4129170786, 5), p = Zt(p, r, o, f, t[6], 3225465664, 9), f = Zt(f, p, r, o, t[11], 643717713, 14), o = Zt(o, f, p, r, t[0], 3921069994, 20), r = Zt(r, o, f, p, t[5], 3593408605, 5), p = Zt(p, r, o, f, t[10], 38016083, 9), f = Zt(f, p, r, o, t[15], 3634488961, 14), o = Zt(o, f, p, r, t[4], 3889429448, 20), r = Zt(r, o, f, p, t[9], 568446438, 5), p = Zt(p, r, o, f, t[14], 3275163606, 9), f = Zt(f, p, r, o, t[3], 4107603335, 14), o = Zt(o, f, p, r, t[8], 1163531501, 20), r = Zt(r, o, f, p, t[13], 2850285829, 5), p = Zt(p, r, o, f, t[2], 4243563512, 9), f = Zt(f, p, r, o, t[7], 1735328473, 14), o = Zt(o, f, p, r, t[12], 2368359562, 20), r = Vt(r, o, f, p, t[5], 4294588738, 4), p = Vt(p, r, o, f, t[8], 2272392833, 11), f = Vt(f, p, r, o, t[11], 1839030562, 16), o = Vt(o, f, p, r, t[14], 4259657740, 23), r = Vt(r, o, f, p, t[1], 2763975236, 4), p = Vt(p, r, o, f, t[4], 1272893353, 11), f = Vt(f, p, r, o, t[7], 4139469664, 16), o = Vt(o, f, p, r, t[10], 3200236656, 23), r = Vt(r, o, f, p, t[13], 681279174, 4), p = Vt(p, r, o, f, t[0], 3936430074, 11), f = Vt(f, p, r, o, t[3], 3572445317, 16), o = Vt(o, f, p, r, t[6], 76029189, 23), r = Vt(r, o, f, p, t[9], 3654602809, 4), p = Vt(p, r, o, f, t[12], 3873151461, 11), f = Vt(f, p, r, o, t[15], 530742520, 16), o = Vt(o, f, p, r, t[2], 3299628645, 23), r = $t(r, o, f, p, t[0], 4096336452, 6), p = $t(p, r, o, f, t[7], 1126891415, 10), f = $t(f, p, r, o, t[14], 2878612391, 15), o = $t(o, f, p, r, t[5], 4237533241, 21), r = $t(r, o, f, p, t[12], 1700485571, 6), p = $t(p, r, o, f, t[3], 2399980690, 10), f = $t(f, p, r, o, t[10], 4293915773, 15), o = $t(o, f, p, r, t[1], 2240044497, 21), r = $t(r, o, f, p, t[8], 1873313359, 6), p = $t(p, r, o, f, t[15], 4264355552, 10), f = $t(f, p, r, o, t[6], 2734768916, 15), o = $t(o, f, p, r, t[13], 1309151649, 21), r = $t(r, o, f, p, t[4], 4149444226, 6), p = $t(p, r, o, f, t[11], 3174756917, 10), f = $t(f, p, r, o, t[2], 718787259, 15), o = $t(o, f, p, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o | 0, this._c = this._c + f | 0, this._d = this._d + p | 0;
    };
    So.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Eo(t, e2) {
      return t << e2 | t >>> 32 - e2;
    }
    function jt(t, e2, r, o, f, p, m) {
      return Eo(t + (e2 & r | ~e2 & o) + f + p | 0, m) + e2 | 0;
    }
    function Zt(t, e2, r, o, f, p, m) {
      return Eo(t + (e2 & o | r & ~o) + f + p | 0, m) + e2 | 0;
    }
    function Vt(t, e2, r, o, f, p, m) {
      return Eo(t + (e2 ^ r ^ o) + f + p | 0, m) + e2 | 0;
    }
    function $t(t, e2, r, o, f, p, m) {
      return Eo(t + (r ^ (e2 | ~o)) + f + p | 0, m) + e2 | 0;
    }
    up.exports = So;
  });
  Bo = T((yI, mp) => {
    var mh = Ut().Buffer, u4 = Ie(), bp = bh(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function Ro() {
      bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    u4(Ro, bp);
    Ro.prototype._update = function() {
      for (var t = l4, e2 = 0;e2 < 16; ++e2)
        t[e2] = this._block.readInt32LE(e2 * 4);
      for (var r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._a | 0, M = this._b | 0, x = this._c | 0, S = this._d | 0, E = this._e | 0, B = 0;B < 80; B += 1) {
        var q, L;
        B < 16 ? (q = lp(r, o, f, p, m, t[na[B]], sa[0], aa[B]), L = vp(y, M, x, S, E, t[fa[B]], ha[0], oa[B])) : B < 32 ? (q = dp(r, o, f, p, m, t[na[B]], sa[1], aa[B]), L = pp(y, M, x, S, E, t[fa[B]], ha[1], oa[B])) : B < 48 ? (q = cp(r, o, f, p, m, t[na[B]], sa[2], aa[B]), L = cp(y, M, x, S, E, t[fa[B]], ha[2], oa[B])) : B < 64 ? (q = pp(r, o, f, p, m, t[na[B]], sa[3], aa[B]), L = dp(y, M, x, S, E, t[fa[B]], ha[3], oa[B])) : (q = vp(r, o, f, p, m, t[na[B]], sa[4], aa[B]), L = lp(y, M, x, S, E, t[fa[B]], ha[4], oa[B])), r = m, m = p, p = cn(f, 10), f = o, o = q, y = E, E = S, S = cn(x, 10), x = M, M = L;
      }
      var ge = this._b + f + S | 0;
      this._b = this._c + p + E | 0, this._c = this._d + m + y | 0, this._d = this._e + r + M | 0, this._e = this._a + o + x | 0, this._a = ge;
    };
    Ro.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = mh.alloc ? mh.alloc(20) : new mh(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function cn(t, e2) {
      return t << e2 | t >>> 32 - e2;
    }
    function lp(t, e2, r, o, f, p, m, y) {
      return cn(t + (e2 ^ r ^ o) + p + m | 0, y) + f | 0;
    }
    function dp(t, e2, r, o, f, p, m, y) {
      return cn(t + (e2 & r | ~e2 & o) + p + m | 0, y) + f | 0;
    }
    function cp(t, e2, r, o, f, p, m, y) {
      return cn(t + ((e2 | ~r) ^ o) + p + m | 0, y) + f | 0;
    }
    function pp(t, e2, r, o, f, p, m, y) {
      return cn(t + (e2 & o | r & ~o) + p + m | 0, y) + f | 0;
    }
    function vp(t, e2, r, o, f, p, m, y) {
      return cn(t + (e2 ^ (r | ~o)) + p + m | 0, y) + f | 0;
    }
    mp.exports = Ro;
  });
  pn = T((wI, yp) => {
    var gp = Te().Buffer;
    function qo(t, e2) {
      this._block = gp.alloc(t), this._finalSize = e2, this._blockSize = t, this._len = 0;
    }
    qo.prototype.update = function(t, e2) {
      typeof t == "string" && (e2 = e2 || "utf8", t = gp.from(t, e2));
      for (var r = this._block, o = this._blockSize, f = t.length, p = this._len, m = 0;m < f; ) {
        for (var y = p % o, M = Math.min(f - m, o - y), x = 0;x < M; x++)
          r[y + x] = t[m + x];
        p += M, m += M, p % o === 0 && this._update(r);
      }
      return this._len += f, this;
    };
    qo.prototype.digest = function(t) {
      var e2 = this._len % this._blockSize;
      this._block[e2] = 128, this._block.fill(0, e2 + 1), e2 >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o = (r & 4294967295) >>> 0, f = (r - o) / 4294967296;
        this._block.writeUInt32BE(f, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
      }
      this._update(this._block);
      var p = this._hash();
      return t ? p.toString(t) : p;
    };
    qo.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    yp.exports = qo;
  });
  _p = T((MI, Mp) => {
    var d4 = Ie(), wp = pn(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v4 = new Array(80);
    function ua() {
      this.init(), this._w = v4, wp.call(this, 64, 56);
    }
    d4(ua, wp);
    ua.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function b4(t) {
      return t << 5 | t >>> 27;
    }
    function m4(t) {
      return t << 30 | t >>> 2;
    }
    function g4(t, e2, r, o) {
      return t === 0 ? e2 & r | ~e2 & o : t === 2 ? e2 & r | e2 & o | r & o : e2 ^ r ^ o;
    }
    ua.prototype._update = function(t) {
      for (var e2 = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e2[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e2[y] = e2[y - 3] ^ e2[y - 8] ^ e2[y - 14] ^ e2[y - 16];
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S = b4(r) + g4(x, o, f, p) + m + e2[M] + p4[x] | 0;
        m = p, p = f, f = m4(o), o = r, r = S;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    ua.prototype._hash = function() {
      var t = c4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Mp.exports = ua;
  });
  Ep = T((_I, Sp) => {
    var y4 = Ie(), xp = pn(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
    function la() {
      this.init(), this._w = _4, xp.call(this, 64, 56);
    }
    y4(la, xp);
    la.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function x4(t) {
      return t << 1 | t >>> 31;
    }
    function S4(t) {
      return t << 5 | t >>> 27;
    }
    function E4(t) {
      return t << 30 | t >>> 2;
    }
    function A4(t, e2, r, o) {
      return t === 0 ? e2 & r | ~e2 & o : t === 2 ? e2 & r | e2 & o | r & o : e2 ^ r ^ o;
    }
    la.prototype._update = function(t) {
      for (var e2 = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e2[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e2[y] = x4(e2[y - 3] ^ e2[y - 8] ^ e2[y - 14] ^ e2[y - 16]);
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S = S4(r) + A4(x, o, f, p) + m + e2[M] + M4[x] | 0;
        m = p, p = f, f = E4(o), o = r, r = S;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    la.prototype._hash = function() {
      var t = w4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Sp.exports = la;
  });
  gh = T((xI, Rp) => {
    var R4 = Ie(), Ap = pn(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I4 = new Array(64);
    function da() {
      this.init(), this._w = I4, Ap.call(this, 64, 56);
    }
    R4(da, Ap);
    da.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function T4(t, e2, r) {
      return r ^ t & (e2 ^ r);
    }
    function k4(t, e2, r) {
      return t & e2 | r & (t | e2);
    }
    function L4(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function N4(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function D4(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function P42(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    da.prototype._update = function(t) {
      for (var e2 = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._f | 0, M = this._g | 0, x = this._h | 0, S = 0;S < 16; ++S)
        e2[S] = t.readInt32BE(S * 4);
      for (;S < 64; ++S)
        e2[S] = P42(e2[S - 2]) + e2[S - 7] + D4(e2[S - 15]) + e2[S - 16] | 0;
      for (var E = 0;E < 64; ++E) {
        var B = x + N4(m) + T4(m, y, M) + q4[E] + e2[E] | 0, q = L4(r) + k4(r, o, f) | 0;
        x = M, M = y, y = m, m = p + B | 0, p = f, f = o, o = r, r = B + q | 0;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0, this._f = y + this._f | 0, this._g = M + this._g | 0, this._h = x + this._h | 0;
    };
    da.prototype._hash = function() {
      var t = B4.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Rp.exports = da;
  });
  qp = T((SI, Bp) => {
    var C4 = Ie(), O4 = gh(), F4 = pn(), U4 = Te().Buffer, z4 = new Array(64);
    function Io() {
      this.init(), this._w = z4, F4.call(this, 64, 56);
    }
    C4(Io, O4);
    Io.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Io.prototype._hash = function() {
      var t = U4.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Bp.exports = Io;
  });
  yh = T((EI, Pp) => {
    var H4 = Ie(), Dp = pn(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K4 = new Array(160);
    function ca() {
      this.init(), this._w = K4, Dp.call(this, 128, 112);
    }
    H4(ca, Dp);
    ca.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Tp(t, e2, r) {
      return r ^ t & (e2 ^ r);
    }
    function kp(t, e2, r) {
      return t & e2 | r & (t | e2);
    }
    function Lp(t, e2) {
      return (t >>> 28 | e2 << 4) ^ (e2 >>> 2 | t << 30) ^ (e2 >>> 7 | t << 25);
    }
    function Np(t, e2) {
      return (t >>> 14 | e2 << 18) ^ (t >>> 18 | e2 << 14) ^ (e2 >>> 9 | t << 23);
    }
    function j4(t, e2) {
      return (t >>> 1 | e2 << 31) ^ (t >>> 8 | e2 << 24) ^ t >>> 7;
    }
    function Z4(t, e2) {
      return (t >>> 1 | e2 << 31) ^ (t >>> 8 | e2 << 24) ^ (t >>> 7 | e2 << 25);
    }
    function V4(t, e2) {
      return (t >>> 19 | e2 << 13) ^ (e2 >>> 29 | t << 3) ^ t >>> 6;
    }
    function $4(t, e2) {
      return (t >>> 19 | e2 << 13) ^ (e2 >>> 29 | t << 3) ^ (t >>> 6 | e2 << 26);
    }
    function Pt(t, e2) {
      return t >>> 0 < e2 >>> 0 ? 1 : 0;
    }
    ca.prototype._update = function(t) {
      for (var e2 = this._w, r = this._ah | 0, o = this._bh | 0, f = this._ch | 0, p = this._dh | 0, m = this._eh | 0, y = this._fh | 0, M = this._gh | 0, x = this._hh | 0, S = this._al | 0, E = this._bl | 0, B = this._cl | 0, q = this._dl | 0, L = this._el | 0, ge = this._fl | 0, _e = this._gl | 0, N = this._hl | 0, we = 0;we < 32; we += 2)
        e2[we] = t.readInt32BE(we * 4), e2[we + 1] = t.readInt32BE(we * 4 + 4);
      for (;we < 160; we += 2) {
        var ye = e2[we - 30], xe = e2[we - 15 * 2 + 1], Re = j4(ye, xe), Ee = Z4(xe, ye);
        ye = e2[we - 2 * 2], xe = e2[we - 2 * 2 + 1];
        var Ae = V4(ye, xe), P5 = $4(xe, ye), Se = e2[we - 7 * 2], v = e2[we - 7 * 2 + 1], i = e2[we - 16 * 2], a = e2[we - 16 * 2 + 1], h = Ee + v | 0, s = Re + Se + Pt(h, Ee) | 0;
        h = h + P5 | 0, s = s + Ae + Pt(h, P5) | 0, h = h + a | 0, s = s + i + Pt(h, a) | 0, e2[we] = s, e2[we + 1] = h;
      }
      for (var u = 0;u < 160; u += 2) {
        s = e2[u], h = e2[u + 1];
        var c = kp(r, o, f), b = kp(S, E, B), l = Lp(r, S), n = Lp(S, r), d = Np(m, L), w = Np(L, m), g = Ip[u], _ = Ip[u + 1], A = Tp(m, y, M), R = Tp(L, ge, _e), I = N + w | 0, Me = x + d + Pt(I, N) | 0;
        I = I + R | 0, Me = Me + A + Pt(I, R) | 0, I = I + _ | 0, Me = Me + g + Pt(I, _) | 0, I = I + h | 0, Me = Me + s + Pt(I, h) | 0;
        var k = n + b | 0, D = l + c + Pt(k, n) | 0;
        x = M, N = _e, M = y, _e = ge, y = m, ge = L, L = q + I | 0, m = p + Me + Pt(L, q) | 0, p = f, q = B, f = o, B = E, o = r, E = S, S = I + k | 0, r = Me + D + Pt(S, I) | 0;
      }
      this._al = this._al + S | 0, this._bl = this._bl + E | 0, this._cl = this._cl + B | 0, this._dl = this._dl + q | 0, this._el = this._el + L | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e | 0, this._hl = this._hl + N | 0, this._ah = this._ah + r + Pt(this._al, S) | 0, this._bh = this._bh + o + Pt(this._bl, E) | 0, this._ch = this._ch + f + Pt(this._cl, B) | 0, this._dh = this._dh + p + Pt(this._dl, q) | 0, this._eh = this._eh + m + Pt(this._el, L) | 0, this._fh = this._fh + y + Pt(this._fl, ge) | 0, this._gh = this._gh + M + Pt(this._gl, _e) | 0, this._hh = this._hh + x + Pt(this._hl, N) | 0;
    };
    ca.prototype._hash = function() {
      var t = W4.allocUnsafe(64);
      function e2(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e2(this._ah, this._al, 0), e2(this._bh, this._bl, 8), e2(this._ch, this._cl, 16), e2(this._dh, this._dl, 24), e2(this._eh, this._el, 32), e2(this._fh, this._fl, 40), e2(this._gh, this._gl, 48), e2(this._hh, this._hl, 56), t;
    };
    Pp.exports = ca;
  });
  Op = T((AI, Cp) => {
    var G4 = Ie(), Y4 = yh(), X4 = pn(), J4 = Te().Buffer, Q4 = new Array(160);
    function To() {
      this.init(), this._w = Q4, X4.call(this, 128, 112);
    }
    G4(To, Y4);
    To.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    To.prototype._hash = function() {
      var t = J4.allocUnsafe(48);
      function e2(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e2(this._ah, this._al, 0), e2(this._bh, this._bl, 8), e2(this._ch, this._cl, 16), e2(this._dh, this._dl, 24), e2(this._eh, this._el, 32), e2(this._fh, this._fl, 40), t;
    };
    Cp.exports = To;
  });
  ko = T((ci, Fp) => {
    var ci = Fp.exports = function(e2) {
      e2 = e2.toLowerCase();
      var r = ci[e2];
      if (!r)
        throw new Error(e2 + " is not supported (we accept pull requests)");
      return new r;
    };
    ci.sha = _p();
    ci.sha1 = Ep();
    ci.sha224 = qp();
    ci.sha256 = gh();
    ci.sha384 = Op();
    ci.sha512 = yh();
  });
  Tt = T((RI, Up) => {
    Up.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e2) {
      return t.includes(e2);
    }, ArrayPrototypeIndexOf(t, e2) {
      return t.indexOf(e2);
    }, ArrayPrototypeJoin(t, e2) {
      return t.join(e2);
    }, ArrayPrototypeMap(t, e2) {
      return t.map(e2);
    }, ArrayPrototypePop(t, e2) {
      return t.pop(e2);
    }, ArrayPrototypePush(t, e2) {
      return t.push(e2);
    }, ArrayPrototypeSlice(t, e2, r) {
      return t.slice(e2, r);
    }, Error, FunctionPrototypeCall(t, e2, ...r) {
      return t.call(e2, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e2) {
      return Function.prototype[Symbol.hasInstance].call(t, e2);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e2) {
      return Object.defineProperties(t, e2);
    }, ObjectDefineProperty(t, e2, r) {
      return Object.defineProperty(t, e2, r);
    }, ObjectGetOwnPropertyDescriptor(t, e2) {
      return Object.getOwnPropertyDescriptor(t, e2);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e2) {
      return Object.setPrototypeOf(t, e2);
    }, Promise, PromisePrototypeCatch(t, e2) {
      return t.catch(e2);
    }, PromisePrototypeThen(t, e2, r) {
      return t.then(e2, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e2) {
      return t.test(e2);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e2, r) {
      return t.slice(e2, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e2, r) {
      return t.set(e2, r);
    }, Uint8Array };
  });
  Gr = T((BI, Mh) => {
    var e_ = Ut(), t_ = Object.getPrototypeOf(async function() {
    }).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e2) {
      return e2 instanceof zp;
    } : function(e2) {
      return false;
    }, wh = class extends Error {
      constructor(e2) {
        if (!Array.isArray(e2))
          throw new TypeError(`Expected input to be an Array, got ${typeof e2}`);
        let r = "";
        for (let o = 0;o < e2.length; o++)
          r += `    ${e2[o].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e2;
      }
    };
    Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
      let e2 = false;
      return function(...r) {
        e2 || (e2 = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e2;
      return { promise: new Promise((o, f) => {
        t = o, e2 = f;
      }), resolve: t, reject: e2 };
    }, promisify(t) {
      return new Promise((e2, r) => {
        t((o, ...f) => o ? r(o) : e2(...f));
      });
    }, debuglog() {
      return function() {
      };
    }, format(t, ...e2) {
      return t.replace(/%([sdifj])/g, function(...[r, o]) {
        let f = e2.shift();
        return o === "f" ? f.toFixed(6) : o === "j" ? JSON.stringify(f) : o === "s" && typeof f == "object" ? `${f.constructor !== Object ? f.constructor.name : ""} {}`.trim() : f.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof t_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: r_ };
    Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  No = T((qI, Lo) => {
    var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Lo.exports = Hp;
    Lo.exports.AbortSignal = i_;
    Lo.exports.default = Hp;
  });
  Jt = T((II, jp) => {
    var { format: n_, inspect: Do, AggregateError: f_ } = Gr(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
    function vn(t, e2) {
      if (!t)
        throw new Po.ERR_INTERNAL_ASSERTION(e2);
    }
    function Wp(t) {
      let e2 = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e2 = `_${t.slice(r - 3, r)}${e2}`;
      return `${t.slice(0, r)}${e2}`;
    }
    function l_(t, e2, r) {
      if (typeof e2 == "function")
        return vn(e2.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e2.length}).`), e2(...r);
      let o = (e2.match(/%[dfijoOs]/g) || []).length;
      return vn(o === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o}).`), r.length === 0 ? e2 : n_(e2, ...r);
    }
    function zt(t, e2, r) {
      r || (r = Error);

      class o extends r {
        constructor(...p) {
          super(l_(t, e2, p));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o.prototype.code = t, o.prototype[o_] = true, Po[t] = o;
    }
    function Kp(t) {
      let e2 = u_ + t.name;
      return Object.defineProperty(t, "name", { value: e2 }), t;
    }
    function d_(t, e2) {
      if (t && e2 && t !== e2) {
        if (Array.isArray(e2.errors))
          return e2.errors.push(t), e2;
        let r = new a_([e2, t], e2.message);
        return r.code = e2.code, r;
      }
      return t || e2;
    }
    var _h = class extends Error {
      constructor(e2 = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e2, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e2, r) => {
      vn(typeof t == "string", "'name' must be a string"), Array.isArray(e2) || (e2 = [e2]);
      let o = "The ";
      t.endsWith(" argument") ? o += `${t} ` : o += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o += "must be ";
      let f = [], p = [], m = [];
      for (let M of e2)
        vn(typeof M == "string", "All expected entries have to be of type string"), s_.includes(M) ? f.push(M.toLowerCase()) : h_.test(M) ? p.push(M) : (vn(M !== "object", 'The value "object" should be written as "Object"'), m.push(M));
      if (p.length > 0) {
        let M = f.indexOf("object");
        M !== -1 && (f.splice(f, M, 1), p.push("Object"));
      }
      if (f.length > 0) {
        switch (f.length) {
          case 1:
            o += `of type ${f[0]}`;
            break;
          case 2:
            o += `one of type ${f[0]} or ${f[1]}`;
            break;
          default: {
            let M = f.pop();
            o += `one of type ${f.join(", ")}, or ${M}`;
          }
        }
        (p.length > 0 || m.length > 0) && (o += " or ");
      }
      if (p.length > 0) {
        switch (p.length) {
          case 1:
            o += `an instance of ${p[0]}`;
            break;
          case 2:
            o += `an instance of ${p[0]} or ${p[1]}`;
            break;
          default: {
            let M = p.pop();
            o += `an instance of ${p.join(", ")}, or ${M}`;
          }
        }
        m.length > 0 && (o += " or ");
      }
      switch (m.length) {
        case 0:
          break;
        case 1:
          m[0].toLowerCase() !== m[0] && (o += "an "), o += `${m[0]}`;
          break;
        case 2:
          o += `one of ${m[0]} or ${m[1]}`;
          break;
        default: {
          let M = m.pop();
          o += `one of ${m.join(", ")}, or ${M}`;
        }
      }
      if (r == null)
        o += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y;
        (y = r.constructor) !== null && y !== undefined && y.name ? o += `. Received an instance of ${r.constructor.name}` : o += `. Received ${Do(r, { depth: -1 })}`;
      } else {
        let M = Do(r, { colors: false });
        M.length > 25 && (M = `${M.slice(0, 25)}...`), o += `. Received type ${typeof r} (${M})`;
      }
      return o;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e2, r = "is invalid") => {
      let o = Do(e2);
      return o.length > 128 && (o = o.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e2, r) => {
      var o;
      let f = r != null && (o = r.constructor) !== null && o !== undefined && o.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e2}" function but got ${f}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      vn(t.length > 0, "At least one arg needs to be specified");
      let e2, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o) => `"${o}"`).join(" or "), r) {
        case 1:
          e2 += `The ${t[0]} argument`;
          break;
        case 2:
          e2 += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o = t.pop();
            e2 += `The ${t.join(", ")}, and ${o} arguments`;
          }
          break;
      }
      return `${e2} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e2, r) => {
      vn(e2, 'Missing "range" argument');
      let o;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = Wp(String(r)) : typeof r == "bigint" ? (o = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o = Wp(o)), o += "n") : o = Do(r), `The value of "${t}" is out of range. It must be ${e2}. Received ${o}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    jp.exports = { AbortError: _h, aggregateTwoErrors: Kp(d_), hideStackFrames: Kp, codes: Po };
  });
  pa = T((TI, Qp) => {
    var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt(), { hideStackFrames: Ir, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr().types, Vp = {};
    function R_(t) {
      return t === (t | 0);
    }
    function B_(t) {
      return t === t >>> 0;
    }
    var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
    function T_(t, e2, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (y_(q_, t) === null)
          throw new Co(e2, t, I_);
        t = m_(t, 8);
      }
      return Xp(t, e2), t;
    }
    var k_ = Ir((t, e2, r = b_, o = v_) => {
      if (typeof t != "number")
        throw new tr(e2, "number", t);
      if (!Sh(t))
        throw new bn(e2, "an integer", t);
      if (t < r || t > o)
        throw new bn(e2, `>= ${r} && <= ${o}`, t);
    }), L_ = Ir((t, e2, r = -2147483648, o = 2147483647) => {
      if (typeof t != "number")
        throw new tr(e2, "number", t);
      if (!Sh(t))
        throw new bn(e2, "an integer", t);
      if (t < r || t > o)
        throw new bn(e2, `>= ${r} && <= ${o}`, t);
    }), Xp = Ir((t, e2, r = false) => {
      if (typeof t != "number")
        throw new tr(e2, "number", t);
      if (!Sh(t))
        throw new bn(e2, "an integer", t);
      let o = r ? 1 : 0, f = 4294967295;
      if (t < o || t > f)
        throw new bn(e2, `>= ${o} && <= ${f}`, t);
    });
    function Jp(t, e2) {
      if (typeof t != "string")
        throw new tr(e2, "string", t);
    }
    function N_(t, e2, r = undefined, o) {
      if (typeof t != "number")
        throw new tr(e2, "number", t);
      if (r != null && t < r || o != null && t > o || (r != null || o != null) && p_(t))
        throw new bn(e2, `${r != null ? `>= ${r}` : ""}${r != null && o != null ? " && " : ""}${o != null ? `<= ${o}` : ""}`, t);
    }
    var D_ = Ir((t, e2, r) => {
      if (!Gp(r, t)) {
        let o = Yp(c_(r, (p) => typeof p == "string" ? `'${p}'` : w_(p)), ", "), f = "must be one of: " + o;
        throw new Co(e2, t, f);
      }
    });
    function P_(t, e2) {
      if (typeof t != "boolean")
        throw new tr(e2, "boolean", t);
    }
    function xh(t, e2, r) {
      return t == null || !g_(t, e2) ? r : t[e2];
    }
    var C_ = Ir((t, e2, r = null) => {
      let o = xh(r, "allowArray", false), f = xh(r, "allowFunction", false);
      if (!xh(r, "nullable", false) && t === null || !o && $p(t) || typeof t != "object" && (!f || typeof t != "function"))
        throw new tr(e2, "Object", t);
    }), O_ = Ir((t, e2, r = 0) => {
      if (!$p(t))
        throw new tr(e2, "Array", t);
      if (t.length < r) {
        let o = `must be longer than ${r}`;
        throw new Co(e2, t, o);
      }
    });
    function F_(t, e2 = "signal") {
      if (Jp(t, e2), Vp[t] === undefined)
        throw Vp[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
    }
    var U_ = Ir((t, e2 = "buffer") => {
      if (!A_(t))
        throw new tr(e2, ["Buffer", "TypedArray", "DataView"], t);
    });
    function z_(t, e2) {
      let r = S_(e2), o = t.length;
      if (r === "hex" && o % 2 !== 0)
        throw new Co("encoding", e2, `is invalid for data of length ${o}`);
    }
    function H_(t, e2 = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new x_(e2, t, r);
      return t | 0;
    }
    var W_ = Ir((t, e2) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new tr(e2, "AbortSignal", t);
    }), K_ = Ir((t, e2) => {
      if (typeof t != "function")
        throw new tr(e2, "Function", t);
    }), j_ = Ir((t, e2) => {
      if (typeof t != "function" || E_(t))
        throw new tr(e2, "Function", t);
    }), Z_ = Ir((t, e2) => {
      if (t !== undefined)
        throw new tr(e2, "undefined", t);
    });
    function V_(t, e2, r) {
      if (!Gp(r, t))
        throw new tr(e2, `('${Yp(r, "|")}')`, t);
    }
    Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
  });
  Rh = T((kI, i1) => {
    var dt = i1.exports = {}, Yr, Xr;
    function Eh() {
      throw new Error("setTimeout has not been defined");
    }
    function Ah() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr = setTimeout : Yr = Eh;
      } catch {
        Yr = Eh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
      } catch {
        Xr = Ah;
      }
    })();
    function e1(t) {
      if (Yr === setTimeout)
        return setTimeout(t, 0);
      if ((Yr === Eh || !Yr) && setTimeout)
        return Yr = setTimeout, setTimeout(t, 0);
      try {
        return Yr(t, 0);
      } catch {
        try {
          return Yr.call(null, t, 0);
        } catch {
          return Yr.call(this, t, 0);
        }
      }
    }
    function $_(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Ah || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var pi2 = [], nf = false, mn, Oo = -1;
    function G_() {
      !nf || !mn || (nf = false, mn.length ? pi2 = mn.concat(pi2) : Oo = -1, pi2.length && t1());
    }
    function t1() {
      if (!nf) {
        var t = e1(G_);
        nf = true;
        for (var e2 = pi2.length;e2; ) {
          for (mn = pi2, pi2 = [];++Oo < e2; )
            mn && mn[Oo].run();
          Oo = -1, e2 = pi2.length;
        }
        mn = null, nf = false, $_(t);
      }
    }
    dt.nextTick = function(t) {
      var e2 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e2[r - 1] = arguments[r];
      pi2.push(new r1(t, e2)), pi2.length === 1 && !nf && e1(t1);
    };
    function r1(t, e2) {
      this.fun = t, this.array = e2;
    }
    r1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt.title = "browser";
    dt.browser = true;
    dt.env = {};
    dt.argv = [];
    dt.version = "";
    dt.versions = {};
    function vi() {
    }
    dt.on = vi;
    dt.addListener = vi;
    dt.once = vi;
    dt.off = vi;
    dt.removeListener = vi;
    dt.removeAllListeners = vi;
    dt.emit = vi;
    dt.prependListener = vi;
    dt.prependOnceListener = vi;
    dt.listeners = function(t) {
      return [];
    };
    dt.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt.cwd = function() {
      return "/";
    };
    dt.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt.umask = function() {
      return 0;
    };
  });
  pr = {};
  Ja(pr, { default: () => Y_ });
  Oi = R0(() => {
    ot(pr, rn(Rh()));
    Y_ = rn(Rh());
  });
  Fi = T((NI, v1) => {
    var { Symbol: Fo, SymbolAsyncIterator: n16, SymbolIterator: f1 } = Tt(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
    function Uo(t, e2 = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e2 || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function zo(t) {
      var e2;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e2 = t._writableState) === null || e2 === undefined ? undefined : e2.writable) !== false));
    }
    function X_(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function gn(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function J_(t, e2) {
      return t == null ? false : e2 === true ? typeof t[n16] == "function" : e2 === false ? typeof t[f1] == "function" : typeof t[n16] == "function" || typeof t[f1] == "function";
    }
    function Ho(t) {
      if (!gn(t))
        return null;
      let { _writableState: e2, _readableState: r } = t, o = e2 || r;
      return !!(t.destroyed || t[a1] || o != null && o.destroyed);
    }
    function h1(t) {
      if (!zo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e2 = t._writableState;
      return e2 != null && e2.errored ? false : typeof e2?.ended != "boolean" ? null : e2.ended;
    }
    function Q_(t, e2) {
      if (!zo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e2 === false && r.ended === true && r.length === 0);
    }
    function e8(t) {
      if (!Uo(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e2 = t._readableState;
      return !e2 || e2.errored ? false : typeof e2?.ended != "boolean" ? null : e2.ended;
    }
    function u1(t, e2) {
      if (!Uo(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e2 === false && r.ended === true && r.length === 0);
    }
    function l1(t) {
      return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
    }
    function d1(t) {
      return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
    }
    function t8(t, e2) {
      return gn(t) ? Ho(t) ? true : !(e2?.readable !== false && l1(t) || e2?.writable !== false && d1(t)) : null;
    }
    function r8(t) {
      var e2, r;
      return gn(t) ? t.writableErrored ? t.writableErrored : (e2 = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e2 !== undefined ? e2 : null : null;
    }
    function i8(t) {
      var e2, r;
      return gn(t) ? t.readableErrored ? t.readableErrored : (e2 = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e2 !== undefined ? e2 : null : null;
    }
    function n8(t) {
      if (!gn(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e2, _readableState: r } = t;
      return typeof e2?.closed == "boolean" || typeof r?.closed == "boolean" ? e2?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
    }
    function c1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function p1(t) {
      return typeof t._sent100 == "boolean" && c1(t);
    }
    function f8(t) {
      var e2;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e2 = t.req) === null || e2 === undefined ? undefined : e2.upgradeOrConnect) === undefined;
    }
    function a8(t) {
      if (!gn(t))
        return null;
      let { _writableState: e2, _readableState: r } = t, o = e2 || r;
      return !o && p1(t) || !!(o && o.autoDestroy && o.emitClose && o.closed === false);
    }
    function o8(t) {
      var e2;
      return !!(t && ((e2 = t[s1]) !== null && e2 !== undefined ? e2 : t.readableDidRead || t.readableAborted));
    }
    function s8(t) {
      var e2, r, o, f, p, m, y, M, x, S;
      return !!(t && ((e2 = (r = (o = (f = (p = (m = t[o1]) !== null && m !== undefined ? m : t.readableErrored) !== null && p !== undefined ? p : t.writableErrored) !== null && f !== undefined ? f : (y = t._readableState) === null || y === undefined ? undefined : y.errorEmitted) !== null && o !== undefined ? o : (M = t._writableState) === null || M === undefined ? undefined : M.errorEmitted) !== null && r !== undefined ? r : (x = t._readableState) === null || x === undefined ? undefined : x.errored) !== null && e2 !== undefined ? e2 : (S = t._writableState) === null || S === undefined ? undefined : S.errored));
    }
    v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
  });
  Ui = T((DI, Ih) => {
    var ff = (Oi(), ur(pr)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
    function M8(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var _8 = () => {
    };
    function S1(t, e2, r) {
      var o, f;
      arguments.length === 2 ? (r = e2, e2 = m1) : e2 == null ? e2 = m1 : p8(e2, "options"), c8(r, "callback"), d8(e2.signal, "options.signal"), r = g1(r);
      let p = (o = e2.readable) !== null && o !== undefined ? o : qh(t), m = (f = e2.writable) !== null && f !== undefined ? f : _1(t);
      if (!y8(t))
        throw new l8("stream", "Stream", t);
      let { _writableState: y, _readableState: M } = t, x = () => {
        t.writable || B();
      }, S = w8(t) && qh(t) === p && _1(t) === m, E = x1(t, false), B = () => {
        E = true, t.destroyed && (S = false), !(S && (!t.readable || p)) && (!p || q) && r.call(t);
      }, q = w1(t, false), L = () => {
        q = true, t.destroyed && (S = false), !(S && (!t.writable || m)) && (!m || E) && r.call(t);
      }, ge = (xe) => {
        r.call(t, xe);
      }, _e = b8(t), N = () => {
        _e = true;
        let xe = g8(t) || m8(t);
        if (xe && typeof xe != "boolean")
          return r.call(t, xe);
        if (p && !q && qh(t, true) && !w1(t, false))
          return r.call(t, new b1);
        if (m && !E && !x1(t, false))
          return r.call(t, new b1);
        r.call(t);
      }, we = () => {
        t.req.on("finish", B);
      };
      M8(t) ? (t.on("complete", B), S || t.on("abort", N), t.req ? we() : t.on("request", we)) : m && !y && (t.on("end", x), t.on("close", x)), !S && typeof t.aborted == "boolean" && t.on("aborted", N), t.on("end", L), t.on("finish", B), e2.error !== false && t.on("error", ge), t.on("close", N), _e ? ff.nextTick(N) : y != null && y.errorEmitted || M != null && M.errorEmitted ? S || ff.nextTick(N) : (!p && (!S || y1(t)) && (E || M1(t) === false) || !m && (!S || M1(t)) && (q || y1(t) === false) || M && t.req && t.aborted) && ff.nextTick(N);
      let ye = () => {
        r = _8, t.removeListener("aborted", N), t.removeListener("complete", B), t.removeListener("abort", N), t.removeListener("request", we), t.req && t.req.removeListener("finish", B), t.removeListener("end", x), t.removeListener("close", x), t.removeListener("finish", B), t.removeListener("end", L), t.removeListener("error", ge), t.removeListener("close", N);
      };
      if (e2.signal && !_e) {
        let xe = () => {
          let Re = r;
          ye(), Re.call(t, new h8(undefined, { cause: e2.signal.reason }));
        };
        if (e2.signal.aborted)
          ff.nextTick(xe);
        else {
          let Re = r;
          r = g1((...Ee) => {
            e2.signal.removeEventListener("abort", xe), Re.apply(t, Ee);
          }), e2.signal.addEventListener("abort", xe);
        }
      }
      return ye;
    }
    function x8(t, e2) {
      return new v8((r, o) => {
        S1(t, e2, (f) => {
          f ? o(f) : r();
        });
      });
    }
    Ih.exports = S1;
    Ih.exports.finished = x8;
  });
  k1 = T((PI2, Lh) => {
    var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt(), Wo = q1("kEmpty"), R1 = q1("kEof");
    function Ko(t, e2) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      e2 != null && of(e2, "options"), e2?.signal != null && af(e2.signal, "options.signal");
      let r = 1;
      return e2?.concurrency != null && (r = I8(e2.concurrency)), A8(r, "concurrency", 1), async function* () {
        var f, p;
        let m = new B1, y = this, M = [], x = m.signal, S = { signal: x }, E = () => m.abort();
        e2 != null && (f = e2.signal) !== null && f !== undefined && f.aborted && E(), e2 == null || (p = e2.signal) === null || p === undefined || p.addEventListener("abort", E);
        let B, q, L = false;
        function ge() {
          L = true;
        }
        async function _e() {
          try {
            for await (let ye of y) {
              var N;
              if (L)
                return;
              if (x.aborted)
                throw new Jr;
              try {
                ye = t(ye, S);
              } catch (xe) {
                ye = A1(xe);
              }
              ye !== Wo && (typeof ((N = ye) === null || N === undefined ? undefined : N.catch) == "function" && ye.catch(ge), M.push(ye), B && (B(), B = null), !L && M.length && M.length >= r && await new E1((xe) => {
                q = xe;
              }));
            }
            M.push(R1);
          } catch (ye) {
            let xe = A1(ye);
            L8(xe, undefined, ge), M.push(xe);
          } finally {
            var we;
            L = true, B && (B(), B = null), e2 == null || (we = e2.signal) === null || we === undefined || we.removeEventListener("abort", E);
          }
        }
        _e();
        try {
          for (;; ) {
            for (;M.length > 0; ) {
              let N = await M[0];
              if (N === R1)
                return;
              if (x.aborted)
                throw new Jr;
              N !== Wo && (yield N), M.shift(), q && (q(), q = null);
            }
            await new E1((N) => {
              B = N;
            });
          }
        } finally {
          m.abort(), L = true, q && (q(), q = null);
        }
      }.call(this);
    }
    function N8(t = undefined) {
      return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f of this) {
          var o;
          if (t != null && (o = t.signal) !== null && o !== undefined && o.aborted)
            throw new Jr({ cause: t.signal.reason });
          yield [r++, f];
        }
      }.call(this);
    }
    async function I1(t, e2 = undefined) {
      for await (let r of kh.call(this, t, e2))
        return true;
      return false;
    }
    async function D8(t, e2 = undefined) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      return !await I1.call(this, async (...r) => !await t(...r), e2);
    }
    async function P8(t, e2) {
      for await (let r of kh.call(this, t, e2))
        return r;
    }
    async function C8(t, e2) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f), Wo;
      }
      for await (let o of Ko.call(this, r, e2))
        ;
    }
    function kh(t, e2) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f) ? o : Wo;
      }
      return Ko.call(this, r, e2);
    }
    var Th = class extends S8 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function O8(t, e2, r) {
      var o;
      if (typeof t != "function")
        throw new va("reducer", ["Function", "AsyncFunction"], t);
      r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
      let f = arguments.length > 1;
      if (r != null && (o = r.signal) !== null && o !== undefined && o.aborted) {
        let x = new Jr(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await B8(this.destroy(x)), x;
      }
      let p = new B1, m = p.signal;
      if (r != null && r.signal) {
        let x = { once: true, [R8]: this };
        r.signal.addEventListener("abort", () => p.abort(), x);
      }
      let y = false;
      try {
        for await (let x of this) {
          var M;
          if (y = true, r != null && (M = r.signal) !== null && M !== undefined && M.aborted)
            throw new Jr;
          f ? e2 = await t(e2, x, { signal: m }) : (e2 = x, f = true);
        }
        if (!y && !f)
          throw new Th;
      } finally {
        p.abort();
      }
      return e2;
    }
    async function F8(t) {
      t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
      let e2 = [];
      for await (let o of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new Jr(undefined, { cause: t.signal.reason });
        q8(e2, o);
      }
      return e2;
    }
    function U8(t, e2) {
      let r = Ko.call(this, t, e2);
      return async function* () {
        for await (let f of r)
          yield* f;
      }.call(this);
    }
    function T1(t) {
      if (t = T8(t), k8(t))
        return 0;
      if (t < 0)
        throw new E8("number", ">= 0", t);
      return t;
    }
    function z8(t, e2 = undefined) {
      return e2 != null && of(e2, "options"), e2?.signal != null && af(e2.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e2 != null && (o = e2.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p of this) {
          var f;
          if (e2 != null && (f = e2.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          t-- <= 0 && (yield p);
        }
      }.call(this);
    }
    function H8(t, e2 = undefined) {
      return e2 != null && of(e2, "options"), e2?.signal != null && af(e2.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e2 != null && (o = e2.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p of this) {
          var f;
          if (e2 != null && (f = e2.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          if (t-- > 0)
            yield p;
          else
            return;
        }
      }.call(this);
    }
    Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
    Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
  });
  yn = T((CI, U1) => {
    var zi = (Oi(), ur(pr)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
    function C1(t, e2, r) {
      t && (t.stack, e2 && !e2.errored && (e2.errored = t), r && !r.errored && (r.errored = t));
    }
    function Y8(t, e2) {
      let r = this._readableState, o = this._writableState, f = o || r;
      return o && o.destroyed || r && r.destroyed ? (typeof e2 == "function" && e2(), this) : (C1(t, o, r), o && (o.destroyed = true), r && (r.destroyed = true), f.constructed ? L1(this, t, e2) : this.once(P1, function(p) {
        L1(this, W8(p, t), e2);
      }), this);
    }
    function L1(t, e2, r) {
      let o = false;
      function f(p) {
        if (o)
          return;
        o = true;
        let { _readableState: m, _writableState: y } = t;
        C1(p, y, m), y && (y.closed = true), m && (m.closed = true), typeof r == "function" && r(p), p ? zi.nextTick(X8, t, p) : zi.nextTick(O1, t);
      }
      try {
        t._destroy(e2 || null, f);
      } catch (p) {
        f(p);
      }
    }
    function X8(t, e2) {
      Dh(t, e2), O1(t);
    }
    function O1(t) {
      let { _readableState: e2, _writableState: r } = t;
      r && (r.closeEmitted = true), e2 && (e2.closeEmitted = true), (r && r.emitClose || e2 && e2.emitClose) && t.emit("close");
    }
    function Dh(t, e2) {
      let { _readableState: r, _writableState: o } = t;
      o && o.errorEmitted || r && r.errorEmitted || (o && (o.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e2));
    }
    function J8() {
      let t = this._readableState, e2 = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e2 && (e2.constructed = true, e2.destroyed = false, e2.closed = false, e2.closeEmitted = false, e2.errored = null, e2.errorEmitted = false, e2.finalCalled = false, e2.prefinished = false, e2.ended = e2.writable === false, e2.ending = e2.writable === false, e2.finished = e2.writable === false);
    }
    function Ph(t, e2, r) {
      let { _readableState: o, _writableState: f } = t;
      if (f && f.destroyed || o && o.destroyed)
        return this;
      o && o.autoDestroy || f && f.autoDestroy ? t.destroy(e2) : e2 && (e2.stack, f && !f.errored && (f.errored = e2), o && !o.errored && (o.errored = e2), r ? zi.nextTick(Dh, t, e2) : Dh(t, e2));
    }
    function Q8(t, e2) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o } = t;
      r && (r.constructed = false), o && (o.constructed = false), t.once(Nh, e2), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
    }
    function e5(t) {
      let e2 = false;
      function r(o) {
        if (e2) {
          Ph(t, o ?? new K8);
          return;
        }
        e2 = true;
        let { _readableState: f, _writableState: p } = t, m = p || f;
        f && (f.constructed = true), p && (p.constructed = true), m.destroyed ? t.emit(P1, o) : o ? Ph(t, o, true) : zi.nextTick(t5, t);
      }
      try {
        t._construct(r);
      } catch (o) {
        r(o);
      }
    }
    function t5(t) {
      t.emit(Nh);
    }
    function N1(t) {
      return t && t.setHeader && typeof t.abort == "function";
    }
    function F1(t) {
      t.emit("close");
    }
    function r5(t, e2) {
      t.emit("error", e2), zi.nextTick(F1, t);
    }
    function i5(t, e2) {
      !t || V8(t) || (!e2 && !$8(t) && (e2 = new j8), G8(t) ? (t.socket = null, t.destroy(e2)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e2) : typeof t.close == "function" ? t.close() : e2 ? zi.nextTick(r5, t, e2) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
    }
    U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
  });
  Vo = T((OI, H1) => {
    var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt(), { EventEmitter: jo } = ki();
    function Zo(t) {
      jo.call(this, t);
    }
    z1(Zo.prototype, jo.prototype);
    z1(Zo, jo);
    Zo.prototype.pipe = function(t, e2) {
      let r = this;
      function o(S) {
        t.writable && t.write(S) === false && r.pause && r.pause();
      }
      r.on("data", o);
      function f() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f), !t._isStdio && (!e2 || e2.end !== false) && (r.on("end", m), r.on("close", y));
      let p = false;
      function m() {
        p || (p = true, t.end());
      }
      function y() {
        p || (p = true, typeof t.destroy == "function" && t.destroy());
      }
      function M(S) {
        x(), jo.listenerCount(this, "error") === 0 && this.emit("error", S);
      }
      Ch(r, "error", M), Ch(t, "error", M);
      function x() {
        r.removeListener("data", o), t.removeListener("drain", f), r.removeListener("end", m), r.removeListener("close", y), r.removeListener("error", M), t.removeListener("error", M), r.removeListener("end", x), r.removeListener("close", x), t.removeListener("close", x);
      }
      return r.on("end", x), r.on("close", x), t.on("close", x), t.emit("pipe", r), t;
    };
    function Ch(t, e2, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e2, r);
      !t._events || !t._events[e2] ? t.on(e2, r) : n5(t._events[e2]) ? t._events[e2].unshift(r) : t._events[e2] = [r, t._events[e2]];
    }
    H1.exports = { Stream: Zo, prependListener: Ch };
  });
  Go = T((FI, $o) => {
    var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e2) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new W1(e2, "AbortSignal", t);
    };
    function h5(t) {
      return !!(t && typeof t.pipe == "function");
    }
    $o.exports.addAbortSignal = function(e2, r) {
      if (s5(e2, "signal"), !h5(r))
        throw new W1("stream", "stream.Stream", r);
      return $o.exports.addAbortSignalNoValidate(e2, r);
    };
    $o.exports.addAbortSignalNoValidate = function(t, e2) {
      if (typeof t != "object" || !("aborted" in t))
        return e2;
      let r = () => {
        e2.destroy(new f5(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), o5(e2, () => t.removeEventListener("abort", r))), e2;
    };
  });
  Z1 = T((zI, j1) => {
    var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt(), { Buffer: Oh } = Ut(), { inspect: d5 } = Gr();
    j1.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e2) {
        let r = { data: e2, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e2) {
        let r = { data: e2, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e2 = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e2;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e2) {
        if (this.length === 0)
          return "";
        let r = this.head, o = "" + r.data;
        for (;(r = r.next) !== null; )
          o += e2 + r.data;
        return o;
      }
      concat(e2) {
        if (this.length === 0)
          return Oh.alloc(0);
        let r = Oh.allocUnsafe(e2 >>> 0), o = this.head, f = 0;
        for (;o; )
          Yo(r, o.data, f), f += o.data.length, o = o.next;
        return r;
      }
      consume(e2, r) {
        let o = this.head.data;
        if (e2 < o.length) {
          let f = o.slice(0, e2);
          return this.head.data = o.slice(e2), f;
        }
        return e2 === o.length ? this.shift() : r ? this._getString(e2) : this._getBuffer(e2);
      }
      first() {
        return this.head.data;
      }
      *[u5]() {
        for (let e2 = this.head;e2; e2 = e2.next)
          yield e2.data;
      }
      _getString(e2) {
        let r = "", o = this.head, f = 0;
        do {
          let p = o.data;
          if (e2 > p.length)
            r += p, e2 -= p.length;
          else {
            e2 === p.length ? (r += p, ++f, o.next ? this.head = o.next : this.head = this.tail = null) : (r += K1(p, 0, e2), this.head = o, o.data = K1(p, e2));
            break;
          }
          ++f;
        } while ((o = o.next) !== null);
        return this.length -= f, r;
      }
      _getBuffer(e2) {
        let r = Oh.allocUnsafe(e2), o = e2, f = this.head, p = 0;
        do {
          let m = f.data;
          if (e2 > m.length)
            Yo(r, m, o - e2), e2 -= m.length;
          else {
            e2 === m.length ? (Yo(r, m, o - e2), ++p, f.next ? this.head = f.next : this.head = this.tail = null) : (Yo(r, new l5(m.buffer, m.byteOffset, e2), o - e2), this.head = f, f.data = m.slice(e2));
            break;
          }
          ++p;
        } while ((f = f.next) !== null);
        return this.length -= p, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e2, r) {
        return d5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Xo = T((HI, $1) => {
    var { MathFloor: c5, NumberIsInteger: p5 } = Tt(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
    function b5(t, e2, r) {
      return t.highWaterMark != null ? t.highWaterMark : e2 ? t[r] : null;
    }
    function V1(t) {
      return t ? 16 : 16 * 1024;
    }
    function m5(t, e2, r, o) {
      let f = b5(e2, o, r);
      if (f != null) {
        if (!p5(f) || f < 0) {
          let p = o ? `options.${r}` : "options.highWaterMark";
          throw new v5(p, f);
        }
        return c5(f);
      }
      return V1(t.objectMode);
    }
    $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
  });
  Fh = T((WI, J1) => {
    var G1 = (Oi(), ur(pr)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt(), { Buffer: y5 } = Ut(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
    function _5(t, e2, r) {
      let o;
      if (typeof e2 == "string" || e2 instanceof y5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e2), this.push(null);
        } });
      let f;
      if (e2 && e2[Y1])
        f = true, o = e2[Y1]();
      else if (e2 && e2[X1])
        f = false, o = e2[X1]();
      else
        throw new w5("iterable", ["Iterable"], e2);
      let p = new t({ objectMode: true, highWaterMark: 1, ...r }), m = false;
      p._read = function() {
        m || (m = true, M());
      }, p._destroy = function(x, S) {
        g5(y(x), () => G1.nextTick(S, x), (E) => G1.nextTick(S, E || x));
      };
      async function y(x) {
        let S = x != null, E = typeof o.throw == "function";
        if (S && E) {
          let { value: B, done: q } = await o.throw(x);
          if (await B, q)
            return;
        }
        if (typeof o.return == "function") {
          let { value: B } = await o.return();
          await B;
        }
      }
      async function M() {
        for (;; ) {
          try {
            let { value: x, done: S } = f ? await o.next() : o.next();
            if (S)
              p.push(null);
            else {
              let E = x && typeof x.then == "function" ? await x : x;
              if (E === null)
                throw m = false, new M5;
              if (p.push(E))
                continue;
              m = false;
            }
          } catch (x) {
            p.destroy(x);
          }
          break;
        }
      }
      return p;
    }
    J1.exports = _5;
  });
  ba = T((KI, lv) => {
    var Tr = (Oi(), ur(pr)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E5, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt();
    lv.exports = Le;
    Le.ReadableState = jh;
    var { EventEmitter: k5 } = ki(), { Stream: Hi, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut(), { addAbortSignal: N5 } = Go(), D5 = Ui(), Pe = Gr().debuglog("stream", (t) => {
      Pe = t;
    }), P5 = Z1(), hf = yn(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
    rv(Le.prototype, Hi.prototype);
    rv(Le, Hi);
    var zh = () => {
    }, { errorOrDestroy: sf } = hf;
    function jh(t, e2, r) {
      typeof r != "boolean" && (r = e2 instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e2 = this instanceof Qr();
      this._readableState = new jh(t, this, e2), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e2 && N5(t.signal, this)), Hi.call(this, t), hf.construct(this, () => {
        this._readableState.needReadable && Jo(this, this._readableState);
      });
    }
    Le.prototype.destroy = hf.destroy;
    Le.prototype._undestroy = hf.undestroy;
    Le.prototype._destroy = function(t, e2) {
      e2(t);
    };
    Le.prototype[k5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e2) {
      return nv(this, t, e2, false);
    };
    Le.prototype.unshift = function(t, e2) {
      return nv(this, t, e2, true);
    };
    function nv(t, e2, r, o) {
      Pe("readableAddChunk", e2);
      let f = t._readableState, p;
      if (f.objectMode || (typeof e2 == "string" ? (r = r || f.defaultEncoding, f.encoding !== r && (o && f.encoding ? e2 = Uh.from(e2, r).toString(f.encoding) : (e2 = Uh.from(e2, r), r = ""))) : e2 instanceof Uh ? r = "" : Hi._isUint8Array(e2) ? (e2 = Hi._uint8ArrayToBuffer(e2), r = "") : e2 != null && (p = new F5("chunk", ["string", "Buffer", "Uint8Array"], e2))), p)
        sf(t, p);
      else if (e2 === null)
        f.reading = false, $5(t, f);
      else if (f.objectMode || e2 && e2.length > 0)
        if (o)
          if (f.endEmitted)
            sf(t, new W5);
          else {
            if (f.destroyed || f.errored)
              return false;
            Hh(t, f, e2, true);
          }
        else if (f.ended)
          sf(t, new H5);
        else {
          if (f.destroyed || f.errored)
            return false;
          f.reading = false, f.decoder && !r ? (e2 = f.decoder.write(e2), f.objectMode || e2.length !== 0 ? Hh(t, f, e2, false) : Jo(t, f)) : Hh(t, f, e2, false);
        }
      else
        o || (f.reading = false, Jo(t, f));
      return !f.ended && (f.length < f.highWaterMark || f.length === 0);
    }
    function Hh(t, e2, r, o) {
      e2.flowing && e2.length === 0 && !e2.sync && t.listenerCount("data") > 0 ? (e2.multiAwaitDrain ? e2.awaitDrainWriters.clear() : e2.awaitDrainWriters = null, e2.dataEmitted = true, t.emit("data", r)) : (e2.length += e2.objectMode ? 1 : r.length, o ? e2.buffer.unshift(r) : e2.buffer.push(r), e2.needReadable && Qo(t)), Jo(t, e2);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[wn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e2 = new iv(t);
      this._readableState.decoder = e2, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o = "";
      for (let f of r)
        o += e2.write(f);
      return r.clear(), o !== "" && r.push(o), this._readableState.length = o.length, this;
    };
    var Z5 = 1073741824;
    function V5(t) {
      if (t > Z5)
        throw new z5("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function ev(t, e2) {
      return t <= 0 || e2.length === 0 && e2.ended ? 0 : e2.objectMode ? 1 : E5(t) ? e2.flowing && e2.length ? e2.buffer.first().length : e2.length : t <= e2.length ? t : e2.ended ? e2.length : 0;
    }
    Le.prototype.read = function(t) {
      Pe("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
      let e2 = this._readableState, r = t;
      if (t > e2.highWaterMark && (e2.highWaterMark = V5(t)), t !== 0 && (e2.emittedReadable = false), t === 0 && e2.needReadable && ((e2.highWaterMark !== 0 ? e2.length >= e2.highWaterMark : e2.length > 0) || e2.ended))
        return Pe("read: emitReadable", e2.length, e2.ended), e2.length === 0 && e2.ended ? Wh(this) : Qo(this), null;
      if (t = ev(t, e2), t === 0 && e2.ended)
        return e2.length === 0 && Wh(this), null;
      let o = e2.needReadable;
      if (Pe("need readable", o), (e2.length === 0 || e2.length - t < e2.highWaterMark) && (o = true, Pe("length less than watermark", o)), e2.ended || e2.reading || e2.destroyed || e2.errored || !e2.constructed)
        o = false, Pe("reading, ended or constructing", o);
      else if (o) {
        Pe("do read"), e2.reading = true, e2.sync = true, e2.length === 0 && (e2.needReadable = true);
        try {
          this._read(e2.highWaterMark);
        } catch (p) {
          sf(this, p);
        }
        e2.sync = false, e2.reading || (t = ev(r, e2));
      }
      let f;
      return t > 0 ? f = hv(t, e2) : f = null, f === null ? (e2.needReadable = e2.length <= e2.highWaterMark, t = 0) : (e2.length -= t, e2.multiAwaitDrain ? e2.awaitDrainWriters.clear() : e2.awaitDrainWriters = null), e2.length === 0 && (e2.ended || (e2.needReadable = true), r !== t && e2.ended && Wh(this)), f !== null && !e2.errorEmitted && !e2.closeEmitted && (e2.dataEmitted = true, this.emit("data", f)), f;
    };
    function $5(t, e2) {
      if (Pe("onEofChunk"), !e2.ended) {
        if (e2.decoder) {
          let r = e2.decoder.end();
          r && r.length && (e2.buffer.push(r), e2.length += e2.objectMode ? 1 : r.length);
        }
        e2.ended = true, e2.sync ? Qo(t) : (e2.needReadable = false, e2.emittedReadable = true, fv(t));
      }
    }
    function Qo(t) {
      let e2 = t._readableState;
      Pe("emitReadable", e2.needReadable, e2.emittedReadable), e2.needReadable = false, e2.emittedReadable || (Pe("emitReadable", e2.flowing), e2.emittedReadable = true, Tr.nextTick(fv, t));
    }
    function fv(t) {
      let e2 = t._readableState;
      Pe("emitReadable_", e2.destroyed, e2.length, e2.ended), !e2.destroyed && !e2.errored && (e2.length || e2.ended) && (t.emit("readable"), e2.emittedReadable = false), e2.needReadable = !e2.flowing && !e2.ended && e2.length <= e2.highWaterMark, ov(t);
    }
    function Jo(t, e2) {
      !e2.readingMore && e2.constructed && (e2.readingMore = true, Tr.nextTick(G5, t, e2));
    }
    function G5(t, e2) {
      for (;!e2.reading && !e2.ended && (e2.length < e2.highWaterMark || e2.flowing && e2.length === 0); ) {
        let r = e2.length;
        if (Pe("maybeReadMore read 0"), t.read(0), r === e2.length)
          break;
      }
      e2.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new U5("_read()");
    };
    Le.prototype.pipe = function(t, e2) {
      let r = this, o = this._readableState;
      o.pipes.length === 1 && (o.multiAwaitDrain || (o.multiAwaitDrain = true, o.awaitDrainWriters = new q5(o.awaitDrainWriters ? [o.awaitDrainWriters] : []))), o.pipes.push(t), Pe("pipe count=%d opts=%j", o.pipes.length, e2);
      let p = (!e2 || e2.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y : _e;
      o.endEmitted ? Tr.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(N, we) {
        Pe("onunpipe"), N === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S());
      }
      function y() {
        Pe("onend"), t.end();
      }
      let M, x = false;
      function S() {
        Pe("cleanup"), t.removeListener("close", L), t.removeListener("finish", ge), M && t.removeListener("drain", M), t.removeListener("error", q), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", _e), r.removeListener("data", B), x = true, M && o.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M();
      }
      function E() {
        x || (o.pipes.length === 1 && o.pipes[0] === t ? (Pe("false write response, pause", 0), o.awaitDrainWriters = t, o.multiAwaitDrain = false) : o.pipes.length > 1 && o.pipes.includes(t) && (Pe("false write response, pause", o.awaitDrainWriters.size), o.awaitDrainWriters.add(t)), r.pause()), M || (M = Y5(r, t), t.on("drain", M));
      }
      r.on("data", B);
      function B(N) {
        Pe("ondata");
        let we = t.write(N);
        Pe("dest.write", we), we === false && E();
      }
      function q(N) {
        if (Pe("onerror", N), _e(), t.removeListener("error", q), t.listenerCount("error") === 0) {
          let we = t._writableState || t._readableState;
          we && !we.errorEmitted ? sf(t, N) : t.emit("error", N);
        }
      }
      L5(t, "error", q);
      function L() {
        t.removeListener("finish", ge), _e();
      }
      t.once("close", L);
      function ge() {
        Pe("onfinish"), t.removeListener("close", L), _e();
      }
      t.once("finish", ge);
      function _e() {
        Pe("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o.flowing && E() : o.flowing || (Pe("pipe resume"), r.resume()), t;
    };
    function Y5(t, e2) {
      return function() {
        let o = t._readableState;
        o.awaitDrainWriters === e2 ? (Pe("pipeOnDrain", 1), o.awaitDrainWriters = null) : o.multiAwaitDrain && (Pe("pipeOnDrain", o.awaitDrainWriters.size), o.awaitDrainWriters.delete(e2)), (!o.awaitDrainWriters || o.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e2 = this._readableState, r = { hasUnpiped: false };
      if (e2.pipes.length === 0)
        return this;
      if (!t) {
        let f = e2.pipes;
        e2.pipes = [], this.pause();
        for (let p = 0;p < f.length; p++)
          f[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o = x5(e2.pipes, t);
      return o === -1 ? this : (e2.pipes.splice(o, 1), e2.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e2) {
      let r = Hi.prototype.on.call(this, t, e2), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Pe("on readable", o.length, o.reading), o.length ? Qo(this) : o.reading || Tr.nextTick(X5, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e2) {
      let r = Hi.prototype.removeListener.call(this, t, e2);
      return t === "readable" && Tr.nextTick(av, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e2 = Hi.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e2;
    };
    function av(t) {
      let e2 = t._readableState;
      e2.readableListening = t.listenerCount("readable") > 0, e2.resumeScheduled && e2[wn] === false ? e2.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e2.readableListening || (e2.flowing = null);
    }
    function X5(t) {
      Pe("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (Pe("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
    };
    function J5(t, e2) {
      e2.resumeScheduled || (e2.resumeScheduled = true, Tr.nextTick(Q5, t, e2));
    }
    function Q5(t, e2) {
      Pe("resume", e2.reading), e2.reading || t.read(0), e2.resumeScheduled = false, t.emit("resume"), ov(t), e2.flowing && !e2.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return Pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
    };
    function ov(t) {
      let e2 = t._readableState;
      for (Pe("flow", e2.flowing);e2.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e2 = false;
      t.on("data", (o) => {
        !this.push(o) && t.pause && (e2 = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o) => {
        sf(this, o);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e2 && t.resume && (e2 = false, t.resume());
      };
      let r = R5(t);
      for (let o = 1;o < r.length; o++) {
        let f = r[o];
        this[f] === undefined && typeof t[f] == "function" && (this[f] = t[f].bind(t));
      }
      return this;
    };
    Le.prototype[I5] = function() {
      return sv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && K5(t, "options"), sv(this, t);
    };
    function sv(t, e2) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = ex(t, e2);
      return r.stream = t, r;
    }
    async function* ex(t, e2) {
      let r = zh;
      function o(m) {
        this === t ? (r(), r = zh) : r = m;
      }
      t.on("readable", o);
      let f, p = D5(t, { writable: false }, (m) => {
        f = m ? Q1(f, m) : null, r(), r = zh;
      });
      try {
        for (;; ) {
          let m = t.destroyed ? null : t.read();
          if (m !== null)
            yield m;
          else {
            if (f)
              throw f;
            if (f === null)
              return;
            await new B5(o);
          }
        }
      } catch (m) {
        throw f = Q1(f, m), f;
      } finally {
        (f || e2?.destroyOnReturn !== false) && (f === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o), p());
      }
    }
    tv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    tv(jh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[wn] !== false;
    }, set(t) {
      this[wn] = !!t;
    } } });
    Le._fromList = hv;
    function hv(t, e2) {
      if (e2.length === 0)
        return null;
      let r;
      return e2.objectMode ? r = e2.buffer.shift() : !t || t >= e2.length ? (e2.decoder ? r = e2.buffer.join("") : e2.buffer.length === 1 ? r = e2.buffer.first() : r = e2.buffer.concat(e2.length), e2.buffer.clear()) : r = e2.buffer.consume(t, e2.decoder), r;
    }
    function Wh(t) {
      let e2 = t._readableState;
      Pe("endReadable", e2.endEmitted), e2.endEmitted || (e2.ended = true, Tr.nextTick(tx, e2, t));
    }
    function tx(t, e2) {
      if (Pe("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e2.emit("end"), e2.writable && e2.allowHalfOpen === false)
          Tr.nextTick(rx, e2);
        else if (t.autoDestroy) {
          let r = e2._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e2.destroy();
        }
      }
    }
    function rx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e2) {
      return j5(Le, t, e2);
    };
    var Kh;
    function uv() {
      return Kh === undefined && (Kh = {}), Kh;
    }
    Le.fromWeb = function(t, e2) {
      return uv().newStreamReadableFromReadableStream(t, e2);
    };
    Le.toWeb = function(t, e2) {
      return uv().newReadableStreamFromStreamReadable(t, e2);
    };
    Le.wrap = function(t, e2) {
      var r, o;
      return new Le({ objectMode: (r = (o = t.readableObjectMode) !== null && o !== undefined ? o : t.objectMode) !== null && r !== undefined ? r : true, ...e2, destroy(f, p) {
        hf.destroyer(t, f), p(f);
      } }).wrap(t);
    };
  });
  Jh = T((jI, xv) => {
    var Mn = (Oi(), ur(pr)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt();
    xv.exports = st;
    st.WritableState = ya;
    var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut(), is = yn(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
    mv(st.prototype, ma.prototype);
    mv(st, ma);
    function $h() {
    }
    var lf = ax("kOnFinished");
    function ya(t, e2, r) {
      typeof r != "boolean" && (r = e2 instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e2), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
    }
    function rs(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    ya.prototype.getBuffer = function() {
      return pv(this.buffered, this.bufferedIndex);
    };
    bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st(t) {
      let e2 = this instanceof Qr();
      if (!e2 && !vv(st, this))
        return new st(t);
      this._writableState = new ya(t, this, e2), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
        let r = this._writableState;
        r.writing || Yh(this, r), Xh(this, r);
      });
    }
    bv(st, ox, { __proto__: null, value: function(t) {
      return vv(this, t) ? true : this !== st ? false : t && t._writableState instanceof ya;
    } });
    st.prototype.pipe = function() {
      uf(this, new px);
    };
    function wv(t, e2, r, o) {
      let f = t._writableState;
      if (typeof r == "function")
        o = r, r = f.defaultEncoding;
      else {
        if (!r)
          r = f.defaultEncoding;
        else if (r !== "buffer" && !es.isEncoding(r))
          throw new yv(r);
        typeof o != "function" && (o = $h);
      }
      if (e2 === null)
        throw new bx;
      if (!f.objectMode)
        if (typeof e2 == "string")
          f.decodeStrings !== false && (e2 = es.from(e2, r), r = "buffer");
        else if (e2 instanceof es)
          r = "buffer";
        else if (ma._isUint8Array(e2))
          e2 = ma._uint8ArrayToBuffer(e2), r = "buffer";
        else
          throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e2);
      let p;
      return f.ending ? p = new mx : f.destroyed && (p = new ga("write")), p ? (Mn.nextTick(o, p), uf(t, p, true), p) : (f.pendingcb++, gx(t, f, e2, r, o));
    }
    st.prototype.write = function(t, e2, r) {
      return wv(this, t, e2, r) === true;
    };
    st.prototype.cork = function() {
      this._writableState.corked++;
    };
    st.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || Yh(this, t));
    };
    st.prototype.setDefaultEncoding = function(e2) {
      if (typeof e2 == "string" && (e2 = fx(e2)), !es.isEncoding(e2))
        throw new yv(e2);
      return this._writableState.defaultEncoding = e2, this;
    };
    function gx(t, e2, r, o, f) {
      let p = e2.objectMode ? 1 : r.length;
      e2.length += p;
      let m = e2.length < e2.highWaterMark;
      return m || (e2.needDrain = true), e2.writing || e2.corked || e2.errored || !e2.constructed ? (e2.buffered.push({ chunk: r, encoding: o, callback: f }), e2.allBuffers && o !== "buffer" && (e2.allBuffers = false), e2.allNoop && f !== $h && (e2.allNoop = false)) : (e2.writelen = p, e2.writecb = f, e2.writing = true, e2.sync = true, t._write(r, o, e2.onwrite), e2.sync = false), m && !e2.errored && !e2.destroyed;
    }
    function dv(t, e2, r, o, f, p, m) {
      e2.writelen = o, e2.writecb = m, e2.writing = true, e2.sync = true, e2.destroyed ? e2.onwrite(new ga("write")) : r ? t._writev(f, e2.onwrite) : t._write(f, p, e2.onwrite), e2.sync = false;
    }
    function cv(t, e2, r, o) {
      --e2.pendingcb, o(r), Gh(e2), uf(t, r);
    }
    function yx(t, e2) {
      let r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function") {
        uf(t, new gv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e2 ? (e2.stack, r.errored || (r.errored = e2), t._readableState && !t._readableState.errored && (t._readableState.errored = e2), o ? Mn.nextTick(cv, t, r, e2, f) : cv(t, r, e2, f)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f));
    }
    function wx({ stream: t, state: e2, count: r, cb: o }) {
      return e2.afterWriteTickInfo = null, Mv(t, e2, r, o);
    }
    function Mv(t, e2, r, o) {
      for (!e2.ending && !t.destroyed && e2.length === 0 && e2.needDrain && (e2.needDrain = false, t.emit("drain"));r-- > 0; )
        e2.pendingcb--, o();
      e2.destroyed && Gh(e2), Xh(t, e2);
    }
    function Gh(t) {
      if (t.writing)
        return;
      for (let f = t.bufferedIndex;f < t.buffered.length; ++f) {
        var e2;
        let { chunk: p, callback: m } = t.buffered[f], y = t.objectMode ? 1 : p.length;
        t.length -= y, m((e2 = t.errored) !== null && e2 !== undefined ? e2 : new ga("write"));
      }
      let r = t[lf].splice(0);
      for (let f = 0;f < r.length; f++) {
        var o;
        r[f]((o = t.errored) !== null && o !== undefined ? o : new ga("end"));
      }
      rs(t);
    }
    function Yh(t, e2) {
      if (e2.corked || e2.bufferProcessing || e2.destroyed || !e2.constructed)
        return;
      let { buffered: r, bufferedIndex: o, objectMode: f } = e2, p = r.length - o;
      if (!p)
        return;
      let m = o;
      if (e2.bufferProcessing = true, p > 1 && t._writev) {
        e2.pendingcb -= p - 1;
        let y = e2.allNoop ? $h : (x) => {
          for (let S = m;S < r.length; ++S)
            r[S].callback(x);
        }, M = e2.allNoop && m === 0 ? r : pv(r, m);
        M.allBuffers = e2.allBuffers, dv(t, e2, true, e2.length, M, "", y), rs(e2);
      } else {
        do {
          let { chunk: y, encoding: M, callback: x } = r[m];
          r[m++] = null;
          let S = f ? 1 : y.length;
          dv(t, e2, false, S, y, M, x);
        } while (m < r.length && !e2.writing);
        m === r.length ? rs(e2) : m > 256 ? (r.splice(0, m), e2.bufferedIndex = 0) : e2.bufferedIndex = m;
      }
      e2.bufferProcessing = false;
    }
    st.prototype._write = function(t, e2, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e2 }], r);
      else
        throw new cx("_write()");
    };
    st.prototype._writev = null;
    st.prototype.end = function(t, e2, r) {
      let o = this._writableState;
      typeof t == "function" ? (r = t, t = null, e2 = null) : typeof e2 == "function" && (r = e2, e2 = null);
      let f;
      if (t != null) {
        let p = wv(this, t, e2);
        p instanceof ix && (f = p);
      }
      return o.corked && (o.corked = 1, this.uncork()), f || (!o.errored && !o.ending ? (o.ending = true, Xh(this, o, true), o.ended = true) : o.finished ? f = new vx("end") : o.destroyed && (f = new ga("end"))), typeof r == "function" && (f || o.finished ? Mn.nextTick(r, f) : o[lf].push(r)), this;
    };
    function ts(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Mx(t, e2) {
      let r = false;
      function o(f) {
        if (r) {
          uf(t, f ?? gv());
          return;
        }
        if (r = true, e2.pendingcb--, f) {
          let p = e2[lf].splice(0);
          for (let m = 0;m < p.length; m++)
            p[m](f);
          uf(t, f, e2.sync);
        } else
          ts(e2) && (e2.prefinished = true, t.emit("prefinish"), e2.pendingcb++, Mn.nextTick(Vh, t, e2));
      }
      e2.sync = true, e2.pendingcb++;
      try {
        t._final(o);
      } catch (f) {
        o(f);
      }
      e2.sync = false;
    }
    function _x(t, e2) {
      !e2.prefinished && !e2.finalCalled && (typeof t._final == "function" && !e2.destroyed ? (e2.finalCalled = true, Mx(t, e2)) : (e2.prefinished = true, t.emit("prefinish")));
    }
    function Xh(t, e2, r) {
      ts(e2) && (_x(t, e2), e2.pendingcb === 0 && (r ? (e2.pendingcb++, Mn.nextTick((o, f) => {
        ts(f) ? Vh(o, f) : f.pendingcb--;
      }, t, e2)) : ts(e2) && (e2.pendingcb++, Vh(t, e2))));
    }
    function Vh(t, e2) {
      e2.pendingcb--, e2.finished = true;
      let r = e2[lf].splice(0);
      for (let o = 0;o < r.length; o++)
        r[o]();
      if (t.emit("finish"), e2.autoDestroy) {
        let o = t._readableState;
        (!o || o.autoDestroy && (o.endEmitted || o.readable === false)) && t.destroy();
      }
    }
    nx(st.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var xx = is.destroy;
    st.prototype.destroy = function(t, e2) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e2), this;
    };
    st.prototype._undestroy = is.undestroy;
    st.prototype._destroy = function(t, e2) {
      e2(t);
    };
    st.prototype[sx.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var Zh;
    function _v() {
      return Zh === undefined && (Zh = {}), Zh;
    }
    st.fromWeb = function(t, e2) {
      return _v().newStreamWritableFromWritableStream(t, e2);
    };
    st.toWeb = function(t) {
      return _v().newWritableStreamFromStreamWritable(t);
    };
  });
  Dv = T((ZI, Nv) => {
    var Qh = (Oi(), ur(pr)), Sx = Ut(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn(), Ix = Qr(), Tx = ba(), { createDeferredPromise: qv } = Gr(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e2) {
      return e2 instanceof Tv;
    } : function(e2) {
      return false;
    }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt(), _n = class extends Ix {
      constructor(e2) {
        super(e2), e2?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e2?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Nv.exports = function t(e2, r) {
      if (Bx(e2))
        return e2;
      if (Ev(e2))
        return ns({ readable: e2 });
      if (Av(e2))
        return ns({ writable: e2 });
      if (Rx(e2))
        return ns({ writable: false, readable: false });
      if (typeof e2 == "function") {
        let { value: f, write: p, final: m, destroy: y } = Nx(e2);
        if (Sv(f))
          return Iv(_n, f, { objectMode: true, write: p, final: m, destroy: y });
        let M = f?.then;
        if (typeof M == "function") {
          let x, S = kv(M, f, (E) => {
            if (E != null)
              throw new Bv("nully", "body", E);
          }, (E) => {
            df(x, E);
          });
          return x = new _n({ objectMode: true, readable: false, write: p, final(E) {
            m(async () => {
              try {
                await S, Qh.nextTick(E, null);
              } catch (B) {
                Qh.nextTick(E, B);
              }
            });
          }, destroy: y });
        }
        throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f);
      }
      if (kx(e2))
        return t(e2.arrayBuffer());
      if (Sv(e2))
        return Iv(_n, e2, { objectMode: true, writable: false });
      if (typeof e2?.writable == "object" || typeof e2?.readable == "object") {
        let f = e2 != null && e2.readable ? Ev(e2?.readable) ? e2?.readable : t(e2.readable) : undefined, p = e2 != null && e2.writable ? Av(e2?.writable) ? e2?.writable : t(e2.writable) : undefined;
        return ns({ readable: f, writable: p });
      }
      let o = e2?.then;
      if (typeof o == "function") {
        let f;
        return kv(o, e2, (p) => {
          p != null && f.push(p), f.push(null);
        }, (p) => {
          df(f, p);
        }), f = new _n({ objectMode: true, writable: false, read() {
        } });
      }
      throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e2);
    };
    function Nx(t) {
      let { promise: e2, resolve: r } = qv(), o = new Lx, f = o.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m = e2;
          e2 = null;
          let { chunk: y, done: M, cb: x } = await m;
          if (Qh.nextTick(x), M)
            return;
          if (f.aborted)
            throw new Lv(undefined, { cause: f.reason });
          ({ promise: e2, resolve: r } = qv()), yield y;
        }
      }(), { signal: f }), write(m, y, M) {
        let x = r;
        r = null, x({ chunk: m, done: false, cb: M });
      }, final(m) {
        let y = r;
        r = null, y({ done: true, cb: m });
      }, destroy(m, y) {
        o.abort(), y(m);
      } };
    }
    function ns(t) {
      let e2 = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o = !!Ex(e2), f = !!Ax(r), p, m, y, M, x;
      function S(E) {
        let B = M;
        M = null, B ? B(E) : E ? x.destroy(E) : !o && !f && x.destroy();
      }
      return x = new _n({ readableObjectMode: !!(e2 != null && e2.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o, writable: f }), f && (Rv(r, (E) => {
        f = false, E && df(e2, E), S(E);
      }), x._write = function(E, B, q) {
        r.write(E, B) ? q() : p = q;
      }, x._final = function(E) {
        r.end(), m = E;
      }, r.on("drain", function() {
        if (p) {
          let E = p;
          p = null, E();
        }
      }), r.on("finish", function() {
        if (m) {
          let E = m;
          m = null, E();
        }
      })), o && (Rv(e2, (E) => {
        o = false, E && df(e2, E), S(E);
      }), e2.on("readable", function() {
        if (y) {
          let E = y;
          y = null, E();
        }
      }), e2.on("end", function() {
        x.push(null);
      }), x._read = function() {
        for (;; ) {
          let E = e2.read();
          if (E === null) {
            y = x._read;
            return;
          }
          if (!x.push(E))
            return;
        }
      }), x._destroy = function(E, B) {
        !E && M !== null && (E = new Lv), y = null, p = null, m = null, M === null ? B(E) : (M = B, df(r, E), df(e2, E));
      }, x;
    }
  });
  Qr = T((VI, Ov) => {
    var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt();
    Ov.exports = kr;
    var ru = ba(), vr = Jh();
    Pv(kr.prototype, ru.prototype);
    Pv(kr, ru);
    {
      let t = Px(vr.prototype);
      for (let e2 = 0;e2 < t.length; e2++) {
        let r = t[e2];
        kr.prototype[r] || (kr.prototype[r] = vr.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      ru.call(this, t), vr.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Dx(kr.prototype, { writable: { __proto__: null, ...bi(vr.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi(vr.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi(vr.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi(vr.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi(vr.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi(vr.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi(vr.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi(vr.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi(vr.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var eu;
    function Cv() {
      return eu === undefined && (eu = {}), eu;
    }
    kr.fromWeb = function(t, e2) {
      return Cv().newStreamDuplexFromReadableWritablePair(t, e2);
    };
    kr.toWeb = function(t) {
      return Cv().newReadableWritablePairFromDuplex(t);
    };
    var tu;
    kr.from = function(t) {
      return tu || (tu = Dv()), tu(t, "body");
    };
  });
  fu = T(($I, Uv) => {
    var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt();
    Uv.exports = mi;
    var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr(), { getHighWaterMark: Fx } = Xo();
    Fv(mi.prototype, nu.prototype);
    Fv(mi, nu);
    var wa = Cx("kCallback");
    function mi(t) {
      if (!(this instanceof mi))
        return new mi(t);
      let e2 = t ? Fx(this, t, "readableHighWaterMark", true) : null;
      e2 === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e2, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
    }
    function iu(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e2, r) => {
        if (e2) {
          t ? t(e2) : this.destroy(e2);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function Ux() {
      this._final !== iu && iu.call(this);
    }
    mi.prototype._final = iu;
    mi.prototype._transform = function(t, e2, r) {
      throw new Ox("_transform()");
    };
    mi.prototype._write = function(t, e2, r) {
      let o = this._readableState, f = this._writableState, p = o.length;
      this._transform(t, e2, (m, y) => {
        if (m) {
          r(m);
          return;
        }
        y != null && this.push(y), f.ended || p === o.length || o.length < o.highWaterMark ? r() : this[wa] = r;
      });
    };
    mi.prototype._read = function() {
      if (this[wa]) {
        let t = this[wa];
        this[wa] = null, t();
      }
    };
  });
  ou = T((GI, Hv) => {
    var { ObjectSetPrototypeOf: zv } = Tt();
    Hv.exports = cf;
    var au = fu();
    zv(cf.prototype, au.prototype);
    zv(cf, au);
    function cf(t) {
      if (!(this instanceof cf))
        return new cf(t);
      au.call(this, t);
    }
    cf.prototype._transform = function(t, e2, r) {
      r(null, t);
    };
  });
  os = T((YI, Gv) => {
    var fs = (Oi(), ur(pr)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt(), as = Ui(), { once: Kx } = Gr(), jx = yn(), Wv = Qr(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu, lu;
    function jv(t, e2, r) {
      let o = false;
      t.on("close", () => {
        o = true;
      });
      let f = as(t, { readable: e2, writable: r }, (p) => {
        o = !p;
      });
      return { destroy: (p) => {
        o || (o = true, jx.destroyer(t, p || new $x("pipe")));
      }, cleanup: f };
    }
    function e7(t) {
      return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function t7(t) {
      if (pf(t))
        return t;
      if (du(t))
        return r7(t);
      throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* r7(t) {
      lu || (lu = ba()), yield* lu.prototype[Wx].call(t);
    }
    async function Zv(t, e2, r, { end: o }) {
      let f, p = null, m = (x) => {
        if (x && (f = x), p) {
          let S = p;
          p = null, S();
        }
      }, y = () => new Hx((x, S) => {
        f ? S(f) : p = () => {
          f ? S(f) : x();
        };
      });
      e2.on("drain", m);
      let M = as(e2, { readable: false }, m);
      try {
        e2.writableNeedDrain && await y();
        for await (let x of t)
          e2.write(x) || await y();
        o && e2.end(), await y(), r();
      } catch (x) {
        r(f !== x ? Zx(f, x) : x);
      } finally {
        M(), e2.off("drain", m);
      }
    }
    function i7(...t) {
      return $v(t, Kx(e7(t)));
    }
    function $v(t, e2, r) {
      if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
        throw new Vx("streams");
      let o = new Qx, f = o.signal, p = r?.signal, m = [];
      Jx(p, "options.signal");
      function y() {
        q(new Yx);
      }
      p?.addEventListener("abort", y);
      let M, x, S = [], E = 0;
      function B(N) {
        q(N, --E === 0);
      }
      function q(N, we) {
        if (N && (!M || M.code === "ERR_STREAM_PREMATURE_CLOSE") && (M = N), !(!M && !we)) {
          for (;S.length; )
            S.shift()(M);
          p?.removeEventListener("abort", y), o.abort(), we && (M || m.forEach((ye) => ye()), fs.nextTick(e2, M, x));
        }
      }
      let L;
      for (let N = 0;N < t.length; N++) {
        let we = t[N], ye = N < t.length - 1, xe = N > 0, Re = ye || r?.end !== false, Ee = N === t.length - 1;
        if (Kv(we)) {
          let Ae = function(P5) {
            P5 && P5.name !== "AbortError" && P5.code !== "ERR_STREAM_PREMATURE_CLOSE" && B(P5);
          };
          var _e = Ae;
          if (Re) {
            let { destroy: P5, cleanup: Se } = jv(we, ye, xe);
            S.push(P5), hu(we) && Ee && m.push(Se);
          }
          we.on("error", Ae), hu(we) && Ee && m.push(() => {
            we.removeListener("error", Ae);
          });
        }
        if (N === 0)
          if (typeof we == "function") {
            if (L = we({ signal: f }), !pf(L))
              throw new su("Iterable, AsyncIterable or Stream", "source", L);
          } else
            pf(we) || du(we) ? L = we : L = Wv.from(we);
        else if (typeof we == "function")
          if (L = t7(L), L = we(L, { signal: f }), ye) {
            if (!pf(L, true))
              throw new su("AsyncIterable", `transform[${N - 1}]`, L);
          } else {
            var ge;
            uu || (uu = ou());
            let Ae = new uu({ objectMode: true }), P5 = (ge = L) === null || ge === undefined ? undefined : ge.then;
            if (typeof P5 == "function")
              E++, P5.call(L, (i) => {
                x = i, i != null && Ae.write(i), Re && Ae.end(), fs.nextTick(B);
              }, (i) => {
                Ae.destroy(i), fs.nextTick(B, i);
              });
            else if (pf(L, true))
              E++, Zv(L, Ae, B, { end: Re });
            else
              throw new su("AsyncIterable or Promise", "destination", L);
            L = Ae;
            let { destroy: Se, cleanup: v } = jv(L, false, true);
            S.push(Se), Ee && m.push(v);
          }
        else if (Kv(we)) {
          if (du(L)) {
            E += 2;
            let Ae = n7(L, we, B, { end: Re });
            hu(we) && Ee && m.push(Ae);
          } else if (pf(L))
            E++, Zv(L, we, B, { end: Re });
          else
            throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L);
          L = we;
        } else
          L = Wv.from(we);
      }
      return (f != null && f.aborted || p != null && p.aborted) && fs.nextTick(y), L;
    }
    function n7(t, e2, r, { end: o }) {
      let f = false;
      return e2.on("close", () => {
        f || r(new Gx);
      }), t.pipe(e2, { end: o }), o ? t.once("end", () => {
        f = true, e2.end();
      }) : r(), as(t, { readable: true, writable: false }, (p) => {
        let m = t._readableState;
        p && p.code === "ERR_STREAM_PREMATURE_CLOSE" && m && m.ended && !m.errored && !m.errorEmitted ? t.once("end", r).once("error", r) : r(p);
      }), as(e2, { readable: false, writable: true }, r);
    }
    Gv.exports = { pipelineImpl: $v, pipeline: i7 };
  });
  eb = T((XI, Qv) => {
    var { pipeline: f7 } = os(), ss = Qr(), { destroyer: a7 } = yn(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
    Qv.exports = function(...e2) {
      if (e2.length === 0)
        throw new h7("streams");
      if (e2.length === 1)
        return ss.from(e2[0]);
      let r = [...e2];
      if (typeof e2[0] == "function" && (e2[0] = ss.from(e2[0])), typeof e2[e2.length - 1] == "function") {
        let q = e2.length - 1;
        e2[q] = ss.from(e2[q]);
      }
      for (let q = 0;q < e2.length; ++q)
        if (!!o7(e2[q])) {
          if (q < e2.length - 1 && !Yv(e2[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be readable");
          if (q > 0 && !Xv(e2[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be writable");
        }
      let o, f, p, m, y;
      function M(q) {
        let L = m;
        m = null, L ? L(q) : q ? y.destroy(q) : !B && !E && y.destroy();
      }
      let x = e2[0], S = f7(e2, M), E = !!Xv(x), B = !!Yv(S);
      return y = new ss({ writableObjectMode: !!(x != null && x.writableObjectMode), readableObjectMode: !!(S != null && S.writableObjectMode), writable: E, readable: B }), E && (y._write = function(q, L, ge) {
        x.write(q, L) ? ge() : o = ge;
      }, y._final = function(q) {
        x.end(), f = q;
      }, x.on("drain", function() {
        if (o) {
          let q = o;
          o = null, q();
        }
      }), S.on("finish", function() {
        if (f) {
          let q = f;
          f = null, q();
        }
      })), B && (S.on("readable", function() {
        if (p) {
          let q = p;
          p = null, q();
        }
      }), S.on("end", function() {
        y.push(null);
      }), y._read = function() {
        for (;; ) {
          let q = S.read();
          if (q === null) {
            p = y._read;
            return;
          }
          if (!y.push(q))
            return;
        }
      }), y._destroy = function(q, L) {
        !q && m !== null && (q = new s7), p = null, o = null, f = null, m === null ? L(q) : (m = L, a7(S, q));
      }, y;
    };
  });
  cu = T((JI, tb) => {
    var { ArrayPrototypePop: u7, Promise: l7 } = Tt(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
    function b7(...t) {
      return new l7((e2, r) => {
        let o, f, p = t[t.length - 1];
        if (p && typeof p == "object" && !c7(p) && !d7(p)) {
          let m = u7(t);
          o = m.signal, f = m.end;
        }
        p7(t, (m, y) => {
          m ? r(m) : e2(y);
        }, { signal: o, end: f });
      });
    }
    tb.exports = { finished: v7, pipeline: b7 };
  });
  lb = T((QI, ub) => {
    var { Buffer: m7 } = Ut(), { ObjectDefineProperty: gi, ObjectKeys: nb, ReflectApply: fb } = Tt(), { promisify: { custom: ab } } = Gr(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k1(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn(), hb = Ui(), pu = cu(), vu = Fi(), ct = ub.exports = Vo().Stream;
    ct.isDisturbed = vu.isDisturbed;
    ct.isErrored = vu.isErrored;
    ct.isReadable = vu.isReadable;
    ct.Readable = ba();
    for (let t of nb(rb)) {
      let r = function(...o) {
        if (new.target)
          throw ob();
        return ct.Readable.from(fb(e2, this, o));
      };
      M7 = r;
      let e2 = rb[t];
      gi(r, "name", { __proto__: null, value: e2.name }), gi(r, "length", { __proto__: null, value: e2.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    for (let t of nb(ib)) {
      let r = function(...f) {
        if (new.target)
          throw ob();
        return fb(e2, this, f);
      };
      M7 = r;
      let e2 = ib[t];
      gi(r, "name", { __proto__: null, value: e2.name }), gi(r, "length", { __proto__: null, value: e2.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    ct.Writable = Jh();
    ct.Duplex = Qr();
    ct.Transform = fu();
    ct.PassThrough = ou();
    ct.pipeline = sb;
    var { addAbortSignal: w7 } = Go();
    ct.addAbortSignal = w7;
    ct.finished = hb;
    ct.destroy = y7;
    ct.compose = g7;
    gi(ct, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return pu;
    } });
    gi(sb, ab, { __proto__: null, enumerable: true, get() {
      return pu.pipeline;
    } });
    gi(hb, ab, { __proto__: null, enumerable: true, get() {
      return pu.finished;
    } });
    ct.Stream = ct;
    ct._isUint8Array = function(e2) {
      return e2 instanceof Uint8Array;
    };
    ct._uint8ArrayToBuffer = function(e2) {
      return m7.from(e2.buffer, e2.byteOffset, e2.byteLength);
    };
  });
  bu = T((eT, pt) => {
    var Lt = lb(), _7 = cu(), x7 = Lt.Readable.destroy;
    pt.exports = Lt.Readable;
    pt.exports._uint8ArrayToBuffer = Lt._uint8ArrayToBuffer;
    pt.exports._isUint8Array = Lt._isUint8Array;
    pt.exports.isDisturbed = Lt.isDisturbed;
    pt.exports.isErrored = Lt.isErrored;
    pt.exports.isReadable = Lt.isReadable;
    pt.exports.Readable = Lt.Readable;
    pt.exports.Writable = Lt.Writable;
    pt.exports.Duplex = Lt.Duplex;
    pt.exports.Transform = Lt.Transform;
    pt.exports.PassThrough = Lt.PassThrough;
    pt.exports.addAbortSignal = Lt.addAbortSignal;
    pt.exports.finished = Lt.finished;
    pt.exports.destroy = Lt.destroy;
    pt.exports.destroy = x7;
    pt.exports.pipeline = Lt.pipeline;
    pt.exports.compose = Lt.compose;
    Object.defineProperty(Lt, "promises", { configurable: true, enumerable: true, get() {
      return _7;
    } });
    pt.exports.Stream = Lt.Stream;
    pt.exports.default = pt.exports;
  });
  vf = {};
  Ja(vf, { default: () => S7 });
  db = R0(() => {
    ot(vf, rn(bu()));
    S7 = rn(bu());
  });
  yi = T((rT, vb) => {
    var cb = Te().Buffer, pb = (db(), ur(vf)).Transform, E7 = co().StringDecoder, A7 = Ie();
    function Lr(t) {
      pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A7(Lr, pb);
    Lr.prototype.update = function(t, e2, r) {
      typeof t == "string" && (t = cb.from(t, e2));
      var o = this._update(t);
      return this.hashMode ? this : (r && (o = this._toString(o, r)), o);
    };
    Lr.prototype.setAutoPadding = function() {
    };
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e2, r) {
      var o;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f) {
        o = f;
      } finally {
        r(o);
      }
    };
    Lr.prototype._flush = function(t) {
      var e2;
      try {
        this.push(this.__final());
      } catch (r) {
        e2 = r;
      }
      t(e2);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e2 = this.__final() || cb.alloc(0);
      return t && (e2 = this._toString(e2, t, true)), e2;
    };
    Lr.prototype._toString = function(t, e2, r) {
      if (this._decoder || (this._decoder = new E7(e2), this._encoding = e2), this._encoding !== e2)
        throw new Error("can't switch encodings");
      var o = this._decoder.write(t);
      return r && (o += this._decoder.end()), o;
    };
    vb.exports = Lr;
  });
  bf = T((iT, mb) => {
    var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi();
    function hs(t) {
      bb.call(this, "digest"), this._hash = t;
    }
    R7(hs, bb);
    hs.prototype._update = function(t) {
      this._hash.update(t);
    };
    hs.prototype._final = function() {
      return this._hash.digest();
    };
    mb.exports = function(e2) {
      return e2 = e2.toLowerCase(), e2 === "md5" ? new B7 : e2 === "rmd160" || e2 === "ripemd160" ? new q7 : new hs(I7(e2));
    };
  });
  wb = T((nT, yb) => {
    var T7 = Ie(), xn = Te().Buffer, gb = yi(), k7 = xn.alloc(128), mf = 64;
    function us(t, e2) {
      gb.call(this, "digest"), typeof e2 == "string" && (e2 = xn.from(e2)), this._alg = t, this._key = e2, e2.length > mf ? e2 = t(e2) : e2.length < mf && (e2 = xn.concat([e2, k7], mf));
      for (var r = this._ipad = xn.allocUnsafe(mf), o = this._opad = xn.allocUnsafe(mf), f = 0;f < mf; f++)
        r[f] = e2[f] ^ 54, o[f] = e2[f] ^ 92;
      this._hash = [r];
    }
    T7(us, gb);
    us.prototype._update = function(t) {
      this._hash.push(t);
    };
    us.prototype._final = function() {
      var t = this._alg(xn.concat(this._hash));
      return this._alg(xn.concat([this._opad, t]));
    };
    yb.exports = us;
  });
  mu = T((fT, Mb) => {
    var L7 = Ao();
    Mb.exports = function(t) {
      return new L7().update(t).digest();
    };
  });
  wu = T((aT, xb) => {
    var N7 = Ie(), D7 = wb(), _b = yi(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
    function _a(t, e2) {
      _b.call(this, "digest"), typeof e2 == "string" && (e2 = Ma.from(e2));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e2, e2.length > r) {
        var o = t === "rmd160" ? new gu : yu(t);
        e2 = o.update(e2).digest();
      } else
        e2.length < r && (e2 = Ma.concat([e2, C7], r));
      for (var f = this._ipad = Ma.allocUnsafe(r), p = this._opad = Ma.allocUnsafe(r), m = 0;m < r; m++)
        f[m] = e2[m] ^ 54, p[m] = e2[m] ^ 92;
      this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f);
    }
    N7(_a, _b);
    _a.prototype._update = function(t) {
      this._hash.update(t);
    };
    _a.prototype._final = function() {
      var t = this._hash.digest(), e2 = this._alg === "rmd160" ? new gu : yu(this._alg);
      return e2.update(this._opad).update(t).digest();
    };
    xb.exports = function(e2, r) {
      return e2 = e2.toLowerCase(), e2 === "rmd160" || e2 === "ripemd160" ? new _a("rmd160", r) : e2 === "md5" ? new D7(P7, r) : new _a(e2, r);
    };
  });
  Mu = T((oT, O7) => {
    O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Eb = T((sT, Sb) => {
    Sb.exports = Mu();
  });
  _u = T((hT, Ab) => {
    var F7 = Math.pow(2, 30) - 1;
    Ab.exports = function(t, e2) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e2 != "number")
        throw new TypeError("Key length not a number");
      if (e2 < 0 || e2 > F7 || e2 !== e2)
        throw new TypeError("Bad key length");
    };
  });
  xu = T((uT, Bb) => {
    var ls;
    global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
    var Rb;
    Bb.exports = ls;
  });
  Eu = T((lT, qb) => {
    var Su = Te().Buffer;
    qb.exports = function(t, e2, r) {
      if (Su.isBuffer(t))
        return t;
      if (typeof t == "string")
        return Su.from(t, e2);
      if (ArrayBuffer.isView(t))
        return Su.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Au = T((dT, Lb) => {
    var U7 = mu(), z7 = Bo(), H7 = ko(), Sn = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu(), K7 = Sn.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function kb(t, e2, r) {
      var o = j7(t), f = t === "sha512" || t === "sha384" ? 128 : 64;
      e2.length > f ? e2 = o(e2) : e2.length < f && (e2 = Sn.concat([e2, K7], f));
      for (var p = Sn.allocUnsafe(f + ds[t]), m = Sn.allocUnsafe(f + ds[t]), y = 0;y < f; y++)
        p[y] = e2[y] ^ 54, m[y] = e2[y] ^ 92;
      var M = Sn.allocUnsafe(f + r + 4);
      p.copy(M, 0, 0, f), this.ipad1 = M, this.ipad2 = p, this.opad = m, this.alg = t, this.blocksize = f, this.hash = o, this.size = ds[t];
    }
    kb.prototype.run = function(t, e2) {
      t.copy(e2, this.blocksize);
      var r = this.hash(e2);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function j7(t) {
      function e2(o) {
        return H7(t).update(o).digest();
      }
      function r(o) {
        return new z7().update(o).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e2;
    }
    function Z7(t, e2, r, o, f) {
      W7(r, o), t = Tb(t, Ib, "Password"), e2 = Tb(e2, Ib, "Salt"), f = f || "sha1";
      var p = new kb(f, t, e2.length), m = Sn.allocUnsafe(o), y = Sn.allocUnsafe(e2.length + 4);
      e2.copy(y, 0, 0, e2.length);
      for (var M = 0, x = ds[f], S = Math.ceil(o / x), E = 1;E <= S; E++) {
        y.writeUInt32BE(E, e2.length);
        for (var B = p.run(y, p.ipad1), q = B, L = 1;L < r; L++) {
          q = p.run(q, p.ipad2);
          for (var ge = 0;ge < x; ge++)
            B[ge] ^= q[ge];
        }
        B.copy(m, M), M += x;
      }
      return m;
    }
    Lb.exports = Z7;
  });
  Ub = T((cT, Fb) => {
    var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
    function G7(t) {
      if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
        return Promise.resolve(false);
      if (Ru[t] !== undefined)
        return Ru[t];
      cs = cs || Cb.alloc(8);
      var e2 = Ob(cs, cs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ru[t] = e2, e2;
    }
    var En;
    function Bu() {
      return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
    }
    function Ob(t, e2, r, o, f) {
      return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p) {
        return xa.deriveBits({ name: "PBKDF2", salt: e2, iterations: r, hash: { name: f } }, p, o << 3);
      }).then(function(p) {
        return Cb.from(p);
      });
    }
    function Y7(t, e2) {
      t.then(function(r) {
        Bu()(function() {
          e2(null, r);
        });
      }, function(r) {
        Bu()(function() {
          e2(r);
        });
      });
    }
    Fb.exports = function(t, e2, r, o, f, p) {
      typeof f == "function" && (p = f, f = undefined), f = f || "sha1";
      var m = $7[f.toLowerCase()];
      if (!m || typeof global.Promise != "function") {
        Bu()(function() {
          var y;
          try {
            y = Db(t, e2, r, o, f);
          } catch (M) {
            return p(M);
          }
          p(null, y);
        });
        return;
      }
      if (V7(r, o), t = Pb(t, Nb, "Password"), e2 = Pb(e2, Nb, "Salt"), typeof p != "function")
        throw new Error("No callback provided to pbkdf2");
      Y7(G7(m).then(function(y) {
        return y ? Ob(t, e2, r, o, m) : Db(t, e2, r, o, f);
      }), p);
    };
  });
  Iu = T((qu) => {
    qu.pbkdf2 = Ub();
    qu.pbkdf2Sync = Au();
  });
  Tu = T((br) => {
    br.readUInt32BE = function(e2, r) {
      var o = e2[0 + r] << 24 | e2[1 + r] << 16 | e2[2 + r] << 8 | e2[3 + r];
      return o >>> 0;
    };
    br.writeUInt32BE = function(e2, r, o) {
      e2[0 + o] = r >>> 24, e2[1 + o] = r >>> 16 & 255, e2[2 + o] = r >>> 8 & 255, e2[3 + o] = r & 255;
    };
    br.ip = function(e2, r, o, f) {
      for (var p = 0, m = 0, y = 6;y >= 0; y -= 2) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >>> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e2 >>> M + y & 1;
      }
      for (var y = 6;y >= 0; y -= 2) {
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= r >>> M + y & 1;
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= e2 >>> M + y & 1;
      }
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.rip = function(e2, r, o, f) {
      for (var p = 0, m = 0, y = 0;y < 4; y++)
        for (var M = 24;M >= 0; M -= 8)
          p <<= 1, p |= r >>> M + y & 1, p <<= 1, p |= e2 >>> M + y & 1;
      for (var y = 4;y < 8; y++)
        for (var M = 24;M >= 0; M -= 8)
          m <<= 1, m |= r >>> M + y & 1, m <<= 1, m |= e2 >>> M + y & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.pc1 = function(e2, r, o, f) {
      for (var p = 0, m = 0, y = 7;y >= 5; y--) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e2 >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        p <<= 1, p |= r >> M + y & 1;
      for (var y = 1;y <= 3; y++) {
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= e2 >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        m <<= 1, m |= e2 >> M + y & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.r28shl = function(e2, r) {
      return e2 << r & 268435455 | e2 >>> 28 - r;
    };
    var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    br.pc2 = function(e2, r, o, f) {
      for (var p = 0, m = 0, y = ps.length >>> 1, M = 0;M < y; M++)
        p <<= 1, p |= e2 >>> ps[M] & 1;
      for (var M = y;M < ps.length; M++)
        m <<= 1, m |= r >>> ps[M] & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.expand = function(e2, r, o) {
      var f = 0, p = 0;
      f = (e2 & 1) << 5 | e2 >>> 27;
      for (var m = 23;m >= 15; m -= 4)
        f <<= 6, f |= e2 >>> m & 63;
      for (var m = 11;m >= 3; m -= 4)
        p |= e2 >>> m & 63, p <<= 6;
      p |= (e2 & 31) << 1 | e2 >>> 31, r[o + 0] = f >>> 0, r[o + 1] = p >>> 0;
    };
    var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    br.substitute = function(e2, r) {
      for (var o = 0, f = 0;f < 4; f++) {
        var p = e2 >>> 18 - f * 6 & 63, m = zb[f * 64 + p];
        o <<= 4, o |= m;
      }
      for (var f = 0;f < 4; f++) {
        var p = r >>> 18 - f * 6 & 63, m = zb[4 * 64 + f * 64 + p];
        o <<= 4, o |= m;
      }
      return o >>> 0;
    };
    var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    br.permute = function(e2) {
      for (var r = 0, o = 0;o < Hb.length; o++)
        r <<= 1, r |= e2 >>> Hb[o] & 1;
      return r >>> 0;
    };
    br.padSplit = function(e2, r, o) {
      for (var f = e2.toString(2);f.length < r; )
        f = "0" + f;
      for (var p = [], m = 0;m < r; m += o)
        p.push(f.slice(m, m + o));
      return p.join(" ");
    };
  });
  ar = T((bT, Kb) => {
    Kb.exports = Wb;
    function Wb(t, e2) {
      if (!t)
        throw new Error(e2 || "Assertion failed");
    }
    Wb.equal = function(e2, r, o) {
      if (e2 != r)
        throw new Error(o || "Assertion failed: " + e2 + " != " + r);
    };
  });
  vs = T((mT, jb) => {
    var X7 = ar();
    function mr(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    jb.exports = mr;
    mr.prototype._init = function() {
    };
    mr.prototype.update = function(e2) {
      return e2.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e2) : this._updateEncrypt(e2);
    };
    mr.prototype._buffer = function(e2, r) {
      for (var o = Math.min(this.buffer.length - this.bufferOff, e2.length - r), f = 0;f < o; f++)
        this.buffer[this.bufferOff + f] = e2[r + f];
      return this.bufferOff += o, o;
    };
    mr.prototype._flushBuffer = function(e2, r) {
      return this._update(this.buffer, 0, e2, r), this.bufferOff = 0, this.blockSize;
    };
    mr.prototype._updateEncrypt = function(e2) {
      var r = 0, o = 0, f = (this.bufferOff + e2.length) / this.blockSize | 0, p = new Array(f * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e2, r), this.bufferOff === this.buffer.length && (o += this._flushBuffer(p, o)));
      for (var m = e2.length - (e2.length - r) % this.blockSize;r < m; r += this.blockSize)
        this._update(e2, r, p, o), o += this.blockSize;
      for (;r < e2.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e2[r];
      return p;
    };
    mr.prototype._updateDecrypt = function(e2) {
      for (var r = 0, o = 0, f = Math.ceil((this.bufferOff + e2.length) / this.blockSize) - 1, p = new Array(f * this.blockSize);f > 0; f--)
        r += this._buffer(e2, r), o += this._flushBuffer(p, o);
      return r += this._buffer(e2, r), p;
    };
    mr.prototype.final = function(e2) {
      var r;
      e2 && (r = this.update(e2));
      var o;
      return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), r ? r.concat(o) : o;
    };
    mr.prototype._pad = function(e2, r) {
      if (r === 0)
        return false;
      for (;r < e2.length; )
        e2[r++] = 0;
      return true;
    };
    mr.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e2 = new Array(this.blockSize);
      return this._update(this.buffer, 0, e2, 0), e2;
    };
    mr.prototype._unpad = function(e2) {
      return e2;
    };
    mr.prototype._finalDecrypt = function() {
      X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e2 = new Array(this.blockSize);
      return this._flushBuffer(e2, 0), this._unpad(e2);
    };
  });
  ku = T((gT, $b) => {
    var Zb = ar(), J7 = Ie(), Nt = Tu(), Vb = vs();
    function Q7() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ei(t) {
      Vb.call(this, t);
      var e2 = new Q7;
      this._desState = e2, this.deriveKeys(e2, t.key);
    }
    J7(ei, Vb);
    $b.exports = ei;
    ei.create = function(e2) {
      return new ei(e2);
    };
    var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ei.prototype.deriveKeys = function(e2, r) {
      e2.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
      var o = Nt.readUInt32BE(r, 0), f = Nt.readUInt32BE(r, 4);
      Nt.pc1(o, f, e2.tmp, 0), o = e2.tmp[0], f = e2.tmp[1];
      for (var p = 0;p < e2.keys.length; p += 2) {
        var m = e9[p >>> 1];
        o = Nt.r28shl(o, m), f = Nt.r28shl(f, m), Nt.pc2(o, f, e2.keys, p);
      }
    };
    ei.prototype._update = function(e2, r, o, f) {
      var p = this._desState, m = Nt.readUInt32BE(e2, r), y = Nt.readUInt32BE(e2, r + 4);
      Nt.ip(m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, m, y, p.tmp, 0) : this._decrypt(p, m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], Nt.writeUInt32BE(o, m, f), Nt.writeUInt32BE(o, y, f + 4);
    };
    ei.prototype._pad = function(e2, r) {
      for (var o = e2.length - r, f = r;f < e2.length; f++)
        e2[f] = o;
      return true;
    };
    ei.prototype._unpad = function(e2) {
      for (var r = e2[e2.length - 1], o = e2.length - r;o < e2.length; o++)
        Zb.equal(e2[o], r);
      return e2.slice(0, e2.length - r);
    };
    ei.prototype._encrypt = function(e2, r, o, f, p) {
      for (var m = r, y = o, M = 0;M < e2.keys.length; M += 2) {
        var x = e2.keys[M], S = e2.keys[M + 1];
        Nt.expand(y, e2.tmp, 0), x ^= e2.tmp[0], S ^= e2.tmp[1];
        var E = Nt.substitute(x, S), B = Nt.permute(E), q = y;
        y = (m ^ B) >>> 0, m = q;
      }
      Nt.rip(y, m, f, p);
    };
    ei.prototype._decrypt = function(e2, r, o, f, p) {
      for (var m = o, y = r, M = e2.keys.length - 2;M >= 0; M -= 2) {
        var x = e2.keys[M], S = e2.keys[M + 1];
        Nt.expand(m, e2.tmp, 0), x ^= e2.tmp[0], S ^= e2.tmp[1];
        var E = Nt.substitute(x, S), B = Nt.permute(E), q = m;
        m = (y ^ B) >>> 0, y = q;
      }
      Nt.rip(m, y, f, p);
    };
  });
  Yb = T((Gb) => {
    var t9 = ar(), r9 = Ie(), bs = {};
    function i9(t) {
      t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e2 = 0;e2 < this.iv.length; e2++)
        this.iv[e2] = t[e2];
    }
    function n9(t) {
      function e2(p) {
        t.call(this, p), this._cbcInit();
      }
      r9(e2, t);
      for (var r = Object.keys(bs), o = 0;o < r.length; o++) {
        var f = r[o];
        e2.prototype[f] = bs[f];
      }
      return e2.create = function(m) {
        return new e2(m);
      }, e2;
    }
    Gb.instantiate = n9;
    bs._cbcInit = function() {
      var e2 = new i9(this.options.iv);
      this._cbcState = e2;
    };
    bs._update = function(e2, r, o, f) {
      var p = this._cbcState, m = this.constructor.super_.prototype, y = p.iv;
      if (this.type === "encrypt") {
        for (var M = 0;M < this.blockSize; M++)
          y[M] ^= e2[r + M];
        m._update.call(this, y, 0, o, f);
        for (var M = 0;M < this.blockSize; M++)
          y[M] = o[f + M];
      } else {
        m._update.call(this, e2, r, o, f);
        for (var M = 0;M < this.blockSize; M++)
          o[f + M] ^= y[M];
        for (var M = 0;M < this.blockSize; M++)
          y[M] = e2[r + M];
      }
    };
  });
  Qb = T((wT, Jb) => {
    var f9 = ar(), a9 = Ie(), Xb = vs(), Wi = ku();
    function o9(t, e2) {
      f9.equal(e2.length, 24, "Invalid key length");
      var r = e2.slice(0, 8), o = e2.slice(8, 16), f = e2.slice(16, 24);
      t === "encrypt" ? this.ciphers = [Wi.create({ type: "encrypt", key: r }), Wi.create({ type: "decrypt", key: o }), Wi.create({ type: "encrypt", key: f })] : this.ciphers = [Wi.create({ type: "decrypt", key: f }), Wi.create({ type: "encrypt", key: o }), Wi.create({ type: "decrypt", key: r })];
    }
    function An(t) {
      Xb.call(this, t);
      var e2 = new o9(this.type, this.options.key);
      this._edeState = e2;
    }
    a9(An, Xb);
    Jb.exports = An;
    An.create = function(e2) {
      return new An(e2);
    };
    An.prototype._update = function(e2, r, o, f) {
      var p = this._edeState;
      p.ciphers[0]._update(e2, r, o, f), p.ciphers[1]._update(o, f, o, f), p.ciphers[2]._update(o, f, o, f);
    };
    An.prototype._pad = Wi.prototype._pad;
    An.prototype._unpad = Wi.prototype._unpad;
  });
  em = T((gf) => {
    gf.utils = Tu();
    gf.Cipher = vs();
    gf.DES = ku();
    gf.CBC = Yb();
    gf.EDE = Qb();
  });
  im = T((_T, rm) => {
    var tm = yi(), wi = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi.CBC.instantiate(wi.EDE), "des-ede3": wi.EDE, "des-ede-cbc": wi.CBC.instantiate(wi.EDE), "des-ede": wi.EDE, "des-cbc": wi.CBC.instantiate(wi.DES), "des-ecb": wi.DES };
    Sa.des = Sa["des-cbc"];
    Sa.des3 = Sa["des-ede3-cbc"];
    rm.exports = ms;
    s9(ms, tm);
    function ms(t) {
      tm.call(this);
      var e2 = t.mode.toLowerCase(), r = Sa[e2], o;
      t.decrypt ? o = "decrypt" : o = "encrypt";
      var f = t.key;
      Rn.isBuffer(f) || (f = Rn.from(f)), (e2 === "des-ede" || e2 === "des-ede-cbc") && (f = Rn.concat([f, f.slice(0, 8)]));
      var p = t.iv;
      Rn.isBuffer(p) || (p = Rn.from(p)), this._des = r.create({ key: f, iv: p, type: o });
    }
    ms.prototype._update = function(t) {
      return Rn.from(this._des.update(t));
    };
    ms.prototype._final = function() {
      return Rn.from(this._des.final());
    };
  });
  nm = T((Lu) => {
    Lu.encrypt = function(t, e2) {
      return t._cipher.encryptBlock(e2);
    };
    Lu.decrypt = function(t, e2) {
      return t._cipher.decryptBlock(e2);
    };
  });
  yf = T((ST, fm) => {
    fm.exports = function(e2, r) {
      for (var o = Math.min(e2.length, r.length), f = new Buffer(o), p = 0;p < o; ++p)
        f[p] = e2[p] ^ r[p];
      return f;
    };
  });
  om = T((Nu) => {
    var am = yf();
    Nu.encrypt = function(t, e2) {
      var r = am(e2, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Nu.decrypt = function(t, e2) {
      var r = t._prev;
      t._prev = e2;
      var o = t._cipher.decryptBlock(e2);
      return am(o, r);
    };
  });
  um = T((hm) => {
    var Ea = Te().Buffer, h9 = yf();
    function sm(t, e2, r) {
      var o = e2.length, f = h9(e2, t._cache);
      return t._cache = t._cache.slice(o), t._prev = Ea.concat([t._prev, r ? e2 : f]), f;
    }
    hm.encrypt = function(t, e2, r) {
      for (var o = Ea.allocUnsafe(0), f;e2.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e2.length)
          f = t._cache.length, o = Ea.concat([o, sm(t, e2.slice(0, f), r)]), e2 = e2.slice(f);
        else {
          o = Ea.concat([o, sm(t, e2, r)]);
          break;
        }
      return o;
    };
  });
  dm = T((lm) => {
    var Du = Te().Buffer;
    function u9(t, e2, r) {
      var o = t._cipher.encryptBlock(t._prev), f = o[0] ^ e2;
      return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e2 : f])]), f;
    }
    lm.encrypt = function(t, e2, r) {
      for (var o = e2.length, f = Du.allocUnsafe(o), p = -1;++p < o; )
        f[p] = u9(t, e2[p], r);
      return f;
    };
  });
  pm = T((cm) => {
    var gs = Te().Buffer;
    function l9(t, e2, r) {
      for (var o, f = -1, p = 8, m = 0, y, M;++f < p; )
        o = t._cipher.encryptBlock(t._prev), y = e2 & 1 << 7 - f ? 128 : 0, M = o[0] ^ y, m += (M & 128) >> f % 8, t._prev = d9(t._prev, r ? y : M);
      return m;
    }
    function d9(t, e2) {
      var r = t.length, o = -1, f = gs.allocUnsafe(t.length);
      for (t = gs.concat([t, gs.from([e2])]);++o < r; )
        f[o] = t[o] << 1 | t[o + 1] >> 7;
      return f;
    }
    cm.encrypt = function(t, e2, r) {
      for (var o = e2.length, f = gs.allocUnsafe(o), p = -1;++p < o; )
        f[p] = l9(t, e2[p], r);
      return f;
    };
  });
  bm = T((vm) => {
    var c9 = yf();
    function p9(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    vm.encrypt = function(t, e2) {
      for (;t._cache.length < e2.length; )
        t._cache = Buffer.concat([t._cache, p9(t)]);
      var r = t._cache.slice(0, e2.length);
      return t._cache = t._cache.slice(e2.length), c9(e2, r);
    };
  });
  Pu = T((IT, mm) => {
    function v9(t) {
      for (var e2 = t.length, r;e2--; )
        if (r = t.readUInt8(e2), r === 255)
          t.writeUInt8(0, e2);
        else {
          r++, t.writeUInt8(r, e2);
          break;
        }
    }
    mm.exports = v9;
  });
  Ou = T((ym) => {
    var b9 = yf(), gm = Te().Buffer, m9 = Pu();
    function g9(t) {
      var e2 = t._cipher.encryptBlockRaw(t._prev);
      return m9(t._prev), e2;
    }
    var Cu = 16;
    ym.encrypt = function(t, e2) {
      var r = Math.ceil(e2.length / Cu), o = t._cache.length;
      t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
      for (var f = 0;f < r; f++) {
        var p = g9(t), m = o + f * Cu;
        t._cache.writeUInt32BE(p[0], m + 0), t._cache.writeUInt32BE(p[1], m + 4), t._cache.writeUInt32BE(p[2], m + 8), t._cache.writeUInt32BE(p[3], m + 12);
      }
      var y = t._cache.slice(0, e2.length);
      return t._cache = t._cache.slice(e2.length), b9(e2, y);
    };
  });
  Fu = T((kT, y9) => {
    y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  ws = T((LT, wm) => {
    var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
    for (Uu in ys)
      ys[Uu].module = w9[ys[Uu].mode];
    var Uu;
    wm.exports = ys;
  });
  Aa = T((NT, _m) => {
    var Ms = Te().Buffer;
    function Hu(t) {
      Ms.isBuffer(t) || (t = Ms.from(t));
      for (var e2 = t.length / 4 | 0, r = new Array(e2), o = 0;o < e2; o++)
        r[o] = t.readUInt32BE(o * 4);
      return r;
    }
    function zu(t) {
      for (var e2 = 0;e2 < t.length; t++)
        t[e2] = 0;
    }
    function Mm(t, e2, r, o, f) {
      for (var p = r[0], m = r[1], y = r[2], M = r[3], x = t[0] ^ e2[0], S = t[1] ^ e2[1], E = t[2] ^ e2[2], B = t[3] ^ e2[3], q, L, ge, _e, N = 4, we = 1;we < f; we++)
        q = p[x >>> 24] ^ m[S >>> 16 & 255] ^ y[E >>> 8 & 255] ^ M[B & 255] ^ e2[N++], L = p[S >>> 24] ^ m[E >>> 16 & 255] ^ y[B >>> 8 & 255] ^ M[x & 255] ^ e2[N++], ge = p[E >>> 24] ^ m[B >>> 16 & 255] ^ y[x >>> 8 & 255] ^ M[S & 255] ^ e2[N++], _e = p[B >>> 24] ^ m[x >>> 16 & 255] ^ y[S >>> 8 & 255] ^ M[E & 255] ^ e2[N++], x = q, S = L, E = ge, B = _e;
      return q = (o[x >>> 24] << 24 | o[S >>> 16 & 255] << 16 | o[E >>> 8 & 255] << 8 | o[B & 255]) ^ e2[N++], L = (o[S >>> 24] << 24 | o[E >>> 16 & 255] << 16 | o[B >>> 8 & 255] << 8 | o[x & 255]) ^ e2[N++], ge = (o[E >>> 24] << 24 | o[B >>> 16 & 255] << 16 | o[x >>> 8 & 255] << 8 | o[S & 255]) ^ e2[N++], _e = (o[B >>> 24] << 24 | o[x >>> 16 & 255] << 16 | o[S >>> 8 & 255] << 8 | o[E & 255]) ^ e2[N++], q = q >>> 0, L = L >>> 0, ge = ge >>> 0, _e = _e >>> 0, [q, L, ge, _e];
    }
    var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt = function() {
      for (var t = new Array(256), e2 = 0;e2 < 256; e2++)
        e2 < 128 ? t[e2] = e2 << 1 : t[e2] = e2 << 1 ^ 283;
      for (var r = [], o = [], f = [[], [], [], []], p = [[], [], [], []], m = 0, y = 0, M = 0;M < 256; ++M) {
        var x = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
        x = x >>> 8 ^ x & 255 ^ 99, r[m] = x, o[x] = m;
        var S = t[m], E = t[S], B = t[E], q = t[x] * 257 ^ x * 16843008;
        f[0][m] = q << 24 | q >>> 8, f[1][m] = q << 16 | q >>> 16, f[2][m] = q << 8 | q >>> 24, f[3][m] = q, q = B * 16843009 ^ E * 65537 ^ S * 257 ^ m * 16843008, p[0][x] = q << 24 | q >>> 8, p[1][x] = q << 16 | q >>> 16, p[2][x] = q << 8 | q >>> 24, p[3][x] = q, m === 0 ? m = y = 1 : (m = S ^ t[t[t[B ^ S]]], y ^= t[t[y]]);
      }
      return { SBOX: r, INV_SBOX: o, SUB_MIX: f, INV_SUB_MIX: p };
    }();
    function gr(t) {
      this._key = Hu(t), this._reset();
    }
    gr.blockSize = 4 * 4;
    gr.keySize = 256 / 8;
    gr.prototype.blockSize = gr.blockSize;
    gr.prototype.keySize = gr.keySize;
    gr.prototype._reset = function() {
      for (var t = this._key, e2 = t.length, r = e2 + 6, o = (r + 1) * 4, f = [], p = 0;p < e2; p++)
        f[p] = t[p];
      for (p = e2;p < o; p++) {
        var m = f[p - 1];
        p % e2 === 0 ? (m = m << 8 | m >>> 24, m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255], m ^= M9[p / e2 | 0] << 24) : e2 > 6 && p % e2 === 4 && (m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255]), f[p] = f[p - e2] ^ m;
      }
      for (var y = [], M = 0;M < o; M++) {
        var x = o - M, S = f[x - (M % 4 ? 0 : 4)];
        M < 4 || x <= 4 ? y[M] = S : y[M] = kt.INV_SUB_MIX[0][kt.SBOX[S >>> 24]] ^ kt.INV_SUB_MIX[1][kt.SBOX[S >>> 16 & 255]] ^ kt.INV_SUB_MIX[2][kt.SBOX[S >>> 8 & 255]] ^ kt.INV_SUB_MIX[3][kt.SBOX[S & 255]];
      }
      this._nRounds = r, this._keySchedule = f, this._invKeySchedule = y;
    };
    gr.prototype.encryptBlockRaw = function(t) {
      return t = Hu(t), Mm(t, this._keySchedule, kt.SUB_MIX, kt.SBOX, this._nRounds);
    };
    gr.prototype.encryptBlock = function(t) {
      var e2 = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
      return r.writeUInt32BE(e2[0], 0), r.writeUInt32BE(e2[1], 4), r.writeUInt32BE(e2[2], 8), r.writeUInt32BE(e2[3], 12), r;
    };
    gr.prototype.decryptBlock = function(t) {
      t = Hu(t);
      var e2 = t[1];
      t[1] = t[3], t[3] = e2;
      var r = Mm(t, this._invKeySchedule, kt.INV_SUB_MIX, kt.INV_SBOX, this._nRounds), o = Ms.allocUnsafe(16);
      return o.writeUInt32BE(r[0], 0), o.writeUInt32BE(r[3], 4), o.writeUInt32BE(r[2], 8), o.writeUInt32BE(r[1], 12), o;
    };
    gr.prototype.scrub = function() {
      zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
    };
    _m.exports.AES = gr;
  });
  Em = T((DT, Sm) => {
    var wf = Te().Buffer, _9 = wf.alloc(16, 0);
    function x9(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function xm(t) {
      var e2 = wf.allocUnsafe(16);
      return e2.writeUInt32BE(t[0] >>> 0, 0), e2.writeUInt32BE(t[1] >>> 0, 4), e2.writeUInt32BE(t[2] >>> 0, 8), e2.writeUInt32BE(t[3] >>> 0, 12), e2;
    }
    function Ra(t) {
      this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
    }
    Ra.prototype.ghash = function(t) {
      for (var e2 = -1;++e2 < t.length; )
        this.state[e2] ^= t[e2];
      this._multiply();
    };
    Ra.prototype._multiply = function() {
      for (var t = x9(this.h), e2 = [0, 0, 0, 0], r, o, f, p = -1;++p < 128; ) {
        for (o = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, o && (e2[0] ^= t[0], e2[1] ^= t[1], e2[2] ^= t[2], e2[3] ^= t[3]), f = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = xm(e2);
    };
    Ra.prototype.update = function(t) {
      this.cache = wf.concat([this.cache, t]);
      for (var e2;this.cache.length >= 16; )
        e2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e2);
    };
    Ra.prototype.final = function(t, e2) {
      return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e2])), this.state;
    };
    Sm.exports = Ra;
  });
  Wu = T((PT, Bm) => {
    var S9 = Aa(), rr = Te().Buffer, Am = yi(), E9 = Ie(), Rm = Em(), A9 = yf(), R9 = Pu();
    function B9(t, e2) {
      var r = 0;
      t.length !== e2.length && r++;
      for (var o = Math.min(t.length, e2.length), f = 0;f < o; ++f)
        r += t[f] ^ e2[f];
      return r;
    }
    function q9(t, e2, r) {
      if (e2.length === 12)
        return t._finID = rr.concat([e2, rr.from([0, 0, 0, 1])]), rr.concat([e2, rr.from([0, 0, 0, 2])]);
      var o = new Rm(r), f = e2.length, p = f % 16;
      o.update(e2), p && (p = 16 - p, o.update(rr.alloc(p, 0))), o.update(rr.alloc(8, 0));
      var m = f * 8, y = rr.alloc(8);
      y.writeUIntBE(m, 0, 8), o.update(y), t._finID = o.state;
      var M = rr.from(t._finID);
      return R9(M), M;
    }
    function Bn(t, e2, r, o) {
      Am.call(this);
      var f = rr.alloc(4, 0);
      this._cipher = new S9.AES(e2);
      var p = this._cipher.encryptBlock(f);
      this._ghash = new Rm(p), r = q9(this, r, p), this._prev = rr.from(r), this._cache = rr.allocUnsafe(0), this._secCache = rr.allocUnsafe(0), this._decrypt = o, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    E9(Bn, Am);
    Bn.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e2 = 16 - this._alen % 16;
        e2 < 16 && (e2 = rr.alloc(e2, 0), this._ghash.update(e2));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Bn.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && B9(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Bn.prototype.getAuthTag = function() {
      if (this._decrypt || !rr.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Bn.prototype.setAuthTag = function(e2) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e2;
    };
    Bn.prototype.setAAD = function(e2) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e2), this._alen += e2.length;
    };
    Bm.exports = Bn;
  });
  ju = T((CT, Im) => {
    var I9 = Aa(), Ku = Te().Buffer, qm = yi(), T9 = Ie();
    function _s(t, e2, r, o) {
      qm.call(this), this._cipher = new I9.AES(e2), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o, this._mode = t;
    }
    T9(_s, qm);
    _s.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    _s.prototype._final = function() {
      this._cipher.scrub();
    };
    Im.exports = _s;
  });
  Ba = T((OT, Tm) => {
    var qn = Te().Buffer, k9 = Ao();
    function L9(t, e2, r, o) {
      if (qn.isBuffer(t) || (t = qn.from(t, "binary")), e2 && (qn.isBuffer(e2) || (e2 = qn.from(e2, "binary")), e2.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f = r / 8, p = qn.alloc(f), m = qn.alloc(o || 0), y = qn.alloc(0);f > 0 || o > 0; ) {
        var M = new k9;
        M.update(y), M.update(t), e2 && M.update(e2), y = M.digest();
        var x = 0;
        if (f > 0) {
          var S = p.length - f;
          x = Math.min(f, y.length), y.copy(p, S, 0, x), f -= x;
        }
        if (x < y.length && o > 0) {
          var E = m.length - o, B = Math.min(o, y.length - x);
          y.copy(m, E, x, x + B), o -= B;
        }
      }
      return y.fill(0), { key: p, iv: m };
    }
    Tm.exports = L9;
  });
  Dm = T((Zu) => {
    var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi(), P9 = Aa(), C9 = Ba(), O9 = Ie();
    function qa(t, e2, r) {
      Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e2), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
    }
    O9(qa, Lm);
    qa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e2, r, o = [];e2 = this._cache.get(); )
        r = this._mode.encrypt(this, e2), o.push(r);
      return Mi.concat(o);
    };
    var F9 = Mi.alloc(16, 16);
    qa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(F9))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    qa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function xs() {
      this.cache = Mi.allocUnsafe(0);
    }
    xs.prototype.add = function(t) {
      this.cache = Mi.concat([this.cache, t]);
    };
    xs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    xs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e2 = Mi.allocUnsafe(t), r = -1;++r < t; )
        e2.writeUInt8(t, r);
      return Mi.concat([this.cache, e2]);
    };
    function Nm(t, e2, r) {
      var o = km[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof e2 == "string" && (e2 = Mi.from(e2)), e2.length !== o.key / 8)
        throw new TypeError("invalid key length " + e2.length);
      if (typeof r == "string" && (r = Mi.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o.type === "stream" ? new D9(o.module, e2, r) : o.type === "auth" ? new N9(o.module, e2, r) : new qa(o.module, e2, r);
    }
    function U9(t, e2) {
      var r = km[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = C9(e2, false, r.key, r.iv);
      return Nm(t, o.key, o.iv);
    }
    Zu.createCipheriv = Nm;
    Zu.createCipher = U9;
  });
  Fm = T((Vu) => {
    var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi(), W9 = Aa(), K9 = Ba(), j9 = Ie();
    function Ia(t, e2, r) {
      Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e2), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
    }
    j9(Ia, Cm);
    Ia.prototype._update = function(t) {
      this._cache.add(t);
      for (var e2, r, o = [];e2 = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e2), o.push(r);
      return Mf.concat(o);
    };
    Ia.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return Z9(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Ia.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Ss() {
      this.cache = Mf.allocUnsafe(0);
    }
    Ss.prototype.add = function(t) {
      this.cache = Mf.concat([this.cache, t]);
    };
    Ss.prototype.get = function(t) {
      var e2;
      if (t) {
        if (this.cache.length > 16)
          return e2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e2;
      } else if (this.cache.length >= 16)
        return e2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e2;
      return null;
    };
    Ss.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function Z9(t) {
      var e2 = t[15];
      if (e2 < 1 || e2 > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e2; )
        if (t[r + (16 - e2)] !== e2)
          throw new Error("unable to decrypt data");
      if (e2 !== 16)
        return t.slice(0, 16 - e2);
    }
    function Om(t, e2, r) {
      var o = Pm[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Mf.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e2 == "string" && (e2 = Mf.from(e2)), e2.length !== o.key / 8)
        throw new TypeError("invalid key length " + e2.length);
      return o.type === "stream" ? new H9(o.module, e2, r, true) : o.type === "auth" ? new z9(o.module, e2, r, true) : new Ia(o.module, e2, r);
    }
    function V9(t, e2) {
      var r = Pm[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = K9(e2, false, r.key, r.iv);
      return Om(t, o.key, o.iv);
    }
    Vu.createDecipher = V9;
    Vu.createDecipheriv = Om;
  });
  Es = T((Nr) => {
    var Um = Dm(), zm = Fm(), $9 = Fu();
    function G9() {
      return Object.keys($9);
    }
    Nr.createCipher = Nr.Cipher = Um.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
    Nr.createDecipher = Nr.Decipher = zm.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = G9;
  });
  Hm = T((_i) => {
    _i["des-ecb"] = { key: 8, iv: 0 };
    _i["des-cbc"] = _i.des = { key: 8, iv: 8 };
    _i["des-ede3-cbc"] = _i.des3 = { key: 24, iv: 8 };
    _i["des-ede3"] = { key: 24, iv: 0 };
    _i["des-ede-cbc"] = { key: 16, iv: 8 };
    _i["des-ede"] = { key: 16, iv: 0 };
  });
  Vm = T((Dr) => {
    var Wm = im(), $u = Es(), Ki = ws(), xi = Hm(), Km = Ba();
    function Y9(t, e2) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e2, false, r, o);
      return jm(t, f.key, f.iv);
    }
    function X9(t, e2) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e2, false, r, o);
      return Zm(t, f.key, f.iv);
    }
    function jm(t, e2, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createCipheriv(t, e2, r);
      if (xi[t])
        return new Wm({ key: e2, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function Zm(t, e2, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createDecipheriv(t, e2, r);
      if (xi[t])
        return new Wm({ key: e2, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function J9() {
      return Object.keys(xi).concat($u.getCiphers());
    }
    Dr.createCipher = Dr.Cipher = Y9;
    Dr.createCipheriv = Dr.Cipheriv = jm;
    Dr.createDecipher = Dr.Decipher = X9;
    Dr.createDecipheriv = Dr.Decipheriv = Zm;
    Dr.listCiphers = Dr.getCiphers = J9;
  });
  ji = T(() => {
  });
  Yu = T(($m, Gu) => {
    (function(t, e2) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e2.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q2) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q2) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q2) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q2) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q2) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q2) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P5(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P5(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P5.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P5.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P5.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P5.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P5.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P5.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P5.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P5.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P5.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P5.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P5.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P5.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P5.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P5.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P5.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P5.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P5.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P5.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P5.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P5), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Gu > "u" || Gu, $m);
  });
  Ym = T((Gm, Xu) => {
    (function(t, e2) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e2.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q2) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q2) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q2) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q2) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q2) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q2) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P5(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P5(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P5.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P5.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P5.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P5.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P5.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P5.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P5.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P5.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P5.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P5.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P5.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P5.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P5.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P5.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P5.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P5.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P5.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P5.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P5.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P5), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Xu > "u" || Xu, Gm);
  });
  Xm = T(() => {
  });
  As = T(($T, el) => {
    var Ju;
    el.exports = function(e2) {
      return Ju || (Ju = new Zi(null)), Ju.generate(e2);
    };
    function Zi(t) {
      this.rand = t;
    }
    el.exports.Rand = Zi;
    Zi.prototype.generate = function(e2) {
      return this._rand(e2);
    };
    Zi.prototype._rand = function(e2) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e2);
      for (var r = new Uint8Array(e2), o = 0;o < r.length; o++)
        r[o] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e2) {
        var r = new Uint8Array(e2);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e2) {
        var r = new Uint8Array(e2);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && (Zi.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (Qu = Xm(), typeof Qu.randomBytes != "function")
          throw new Error("Not supported");
        Zi.prototype._rand = function(e2) {
          return Qu.randomBytes(e2);
        };
      } catch {
      }
    var Qu;
  });
  tl = T((GT, Jm) => {
    var In = Ym(), Q9 = As();
    function Tn(t) {
      this.rand = t || new Q9.Rand;
    }
    Jm.exports = Tn;
    Tn.create = function(e2) {
      return new Tn(e2);
    };
    Tn.prototype._randbelow = function(e2) {
      var r = e2.bitLength(), o = Math.ceil(r / 8);
      do
        var f = new In(this.rand.generate(o));
      while (f.cmp(e2) >= 0);
      return f;
    };
    Tn.prototype._randrange = function(e2, r) {
      var o = r.sub(e2);
      return e2.add(this._randbelow(o));
    };
    Tn.prototype.test = function(e2, r, o) {
      var f = e2.bitLength(), p = In.mont(e2), m = new In(1).toRed(p);
      r || (r = Math.max(1, f / 48 | 0));
      for (var y = e2.subn(1), M = 0;!y.testn(M); M++)
        ;
      for (var x = e2.shrn(M), S = y.toRed(p), E = true;r > 0; r--) {
        var B = this._randrange(new In(2), y);
        o && o(B);
        var q = B.toRed(p).redPow(x);
        if (!(q.cmp(m) === 0 || q.cmp(S) === 0)) {
          for (var L = 1;L < M; L++) {
            if (q = q.redSqr(), q.cmp(m) === 0)
              return false;
            if (q.cmp(S) === 0)
              break;
          }
          if (L === M)
            return false;
        }
      }
      return E;
    };
    Tn.prototype.getDivisor = function(e2, r) {
      var o = e2.bitLength(), f = In.mont(e2), p = new In(1).toRed(f);
      r || (r = Math.max(1, o / 48 | 0));
      for (var m = e2.subn(1), y = 0;!m.testn(y); y++)
        ;
      for (var M = e2.shrn(y), x = m.toRed(f);r > 0; r--) {
        var S = this._randrange(new In(2), m), E = e2.gcd(S);
        if (E.cmpn(1) !== 0)
          return E;
        var B = S.toRed(f).redPow(M);
        if (!(B.cmp(p) === 0 || B.cmp(x) === 0)) {
          for (var q = 1;q < y; q++) {
            if (B = B.redSqr(), B.cmp(p) === 0)
              return B.fromRed().subn(1).gcd(e2);
            if (B.cmp(x) === 0)
              break;
          }
          if (q === y)
            return B = B.redSqr(), B.fromRed().subn(1).gcd(e2);
        }
      }
      return false;
    };
  });
  ol = T((ek, tg) => {
    var eS = on();
    tg.exports = al;
    al.simpleSieve = nl;
    al.fermatTest = fl;
    var Ht = Yu(), tS = new Ht(24), rS = tl(), Qm = new rS, iS = new Ht(1), il = new Ht(2), nS = new Ht(5), YT = new Ht(16), XT = new Ht(8), fS = new Ht(10), aS = new Ht(3), JT = new Ht(7), oS = new Ht(11), eg = new Ht(4), QT = new Ht(12), rl = null;
    function sS() {
      if (rl !== null)
        return rl;
      var t = 1048576, e2 = [];
      e2[0] = 2;
      for (var r = 1, o = 3;o < t; o += 2) {
        for (var f = Math.ceil(Math.sqrt(o)), p = 0;p < r && e2[p] <= f && o % e2[p] !== 0; p++)
          ;
        r !== p && e2[p] <= f || (e2[r++] = o);
      }
      return rl = e2, e2;
    }
    function nl(t) {
      for (var e2 = sS(), r = 0;r < e2.length; r++)
        if (t.modn(e2[r]) === 0)
          return t.cmpn(e2[r]) === 0;
      return true;
    }
    function fl(t) {
      var e2 = Ht.mont(t);
      return il.toRed(e2).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function al(t, e2) {
      if (t < 16)
        return e2 === 2 || e2 === 5 ? new Ht([140, 123]) : new Ht([140, 39]);
      e2 = new Ht(e2);
      for (var r, o;; ) {
        for (r = new Ht(eS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e2.cmp(il)) {
          if (!e2.cmp(nS))
            for (;r.mod(fS).cmp(aS); )
              r.iadd(eg);
        } else
          for (;r.mod(tS).cmp(oS); )
            r.iadd(eg);
        if (o = r.shrn(1), nl(o) && nl(r) && fl(o) && fl(r) && Qm.test(o) && Qm.test(r))
          return r;
      }
    }
  });
  rg = T((tk, hS) => {
    hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  ag = T((rk, fg) => {
    var yr = Yu(), uS = tl(), ig = new uS, lS = new yr(24), dS = new yr(11), cS = new yr(10), pS = new yr(3), vS = new yr(7), ng = ol(), bS = on();
    fg.exports = Si;
    function mS(t, e2) {
      return e2 = e2 || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e2)), this._pub = new yr(t), this;
    }
    function gS(t, e2) {
      return e2 = e2 || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e2)), this._priv = new yr(t), this;
    }
    var Rs = {};
    function yS(t, e2) {
      var r = e2.toString("hex"), o = [r, t.toString(16)].join("_");
      if (o in Rs)
        return Rs[o];
      var f = 0;
      if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
        return f += 1, r === "02" || r === "05" ? f += 8 : f += 4, Rs[o] = f, f;
      ig.test(t.shrn(1)) || (f += 2);
      var p;
      switch (r) {
        case "02":
          t.mod(lS).cmp(dS) && (f += 8);
          break;
        case "05":
          p = t.mod(cS), p.cmp(pS) && p.cmp(vS) && (f += 8);
          break;
        default:
          f += 4;
      }
      return Rs[o] = f, f;
    }
    function Si(t, e2, r) {
      this.setGenerator(e2), this.__prime = new yr(t), this._prime = yr.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
    }
    Object.defineProperty(Si.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
    } });
    Si.prototype.generateKeys = function() {
      return this._priv || (this._priv = new yr(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Si.prototype.computeSecret = function(t) {
      t = new yr(t), t = t.toRed(this._prime);
      var e2 = t.redPow(this._priv).fromRed(), r = new Buffer(e2.toArray()), o = this.getPrime();
      if (r.length < o.length) {
        var f = new Buffer(o.length - r.length);
        f.fill(0), r = Buffer.concat([f, r]);
      }
      return r;
    };
    Si.prototype.getPublicKey = function(e2) {
      return Bs(this._pub, e2);
    };
    Si.prototype.getPrivateKey = function(e2) {
      return Bs(this._priv, e2);
    };
    Si.prototype.getPrime = function(t) {
      return Bs(this.__prime, t);
    };
    Si.prototype.getGenerator = function(t) {
      return Bs(this._gen, t);
    };
    Si.prototype.setGenerator = function(t, e2) {
      return e2 = e2 || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e2)), this.__gen = t, this._gen = new yr(t), this;
    };
    function Bs(t, e2) {
      var r = new Buffer(t.toArray());
      return e2 ? r.toString(e2) : r;
    }
  });
  hg = T((_f) => {
    var wS = ol(), og = rg(), sl = ag();
    function MS(t) {
      var e2 = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
      return new sl(e2, r);
    }
    var _S = { binary: true, hex: true, base64: true };
    function sg(t, e2, r, o) {
      return Buffer.isBuffer(e2) || _S[e2] === undefined ? sg(t, "binary", e2, r) : (e2 = e2 || "binary", o = o || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o)), typeof t == "number" ? new sl(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e2)), new sl(t, r, true)));
    }
    _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
    _f.createDiffieHellman = _f.DiffieHellman = sg;
  });
  hl = T((nk, ug) => {
    ug.exports = ki().EventEmitter;
  });
  pg = T((fk, cg) => {
    function lg(t, e2) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e2 && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function xS(t) {
      for (var e2 = 1;e2 < arguments.length; e2++) {
        var r = arguments[e2] != null ? arguments[e2] : {};
        e2 % 2 ? lg(Object(r), true).forEach(function(o) {
          SS(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function SS(t, e2, r) {
      return e2 in t ? Object.defineProperty(t, e2, { value: r, enumerable: true, configurable: true, writable: true }) : t[e2] = r, t;
    }
    function ES(t, e2) {
      if (!(t instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    function dg(t, e2) {
      for (var r = 0;r < e2.length; r++) {
        var o = e2[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function AS(t, e2, r) {
      return e2 && dg(t.prototype, e2), r && dg(t, r), t;
    }
    var RS = Ut(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
    function IS(t, e2, r) {
      qs.prototype.copy.call(t, e2, r);
    }
    cg.exports = function() {
      function t() {
        ES(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return AS(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return qs.alloc(0);
        for (var o = qs.allocUnsafe(r >>> 0), f = this.head, p = 0;f; )
          IS(f.data, o, p), p += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = qs.allocUnsafe(r), f = this.head, p = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: qS, value: function(r, o) {
        return ul(this, xS({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  dl = T((ak, bg) => {
    function TS(t, e2) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e2 ? e2(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e2 && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p)) : process.nextTick(vg, r, p) : e2 ? (process.nextTick(Is, r), e2(p)) : process.nextTick(Is, r);
      }), this);
    }
    function vg(t, e2) {
      ll(t, e2), Is(t);
    }
    function Is(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function kS() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function ll(t, e2) {
      t.emit("error", e2);
    }
    function LS(t, e2) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e2) : t.emit("error", e2);
    }
    bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
  });
  kn = T((ok, yg) => {
    function NS(t, e2) {
      t.prototype = Object.create(e2.prototype), t.prototype.constructor = t, t.__proto__ = e2;
    }
    var gg = {};
    function wr(t, e2, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e2 == "string" ? e2 : e2(p, m, y);
      }
      var f = function(p) {
        NS(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gg[t] = f;
    }
    function mg(t, e2) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e2, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e2, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e2, " ").concat(t[0]);
      } else
        return "of ".concat(e2, " ").concat(String(t));
    }
    function DS(t, e2, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e2.length) === e2;
    }
    function PS(t, e2, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e2.length, r) === e2;
    }
    function CS(t, e2, r) {
      return typeof r != "number" && (r = 0), r + e2.length > t.length ? false : t.indexOf(e2, r) !== -1;
    }
    wr("ERR_INVALID_OPT_VALUE", function(t, e2) {
      return 'The value "' + e2 + '" is invalid for option "' + t + '"';
    }, TypeError);
    wr("ERR_INVALID_ARG_TYPE", function(t, e2, r) {
      var o;
      typeof e2 == "string" && DS(e2, "not ") ? (o = "must not be", e2 = e2.replace(/^not /, "")) : o = "must be";
      var f;
      if (PS(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mg(e2, "type"));
      else {
        var p = CS(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(mg(e2, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    wr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    wr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yg.exports.codes = gg;
  });
  cl = T((sk, wg) => {
    var OS = kn().codes.ERR_INVALID_OPT_VALUE;
    function FS(t, e2, r) {
      return t.highWaterMark != null ? t.highWaterMark : e2 ? t[r] : null;
    }
    function US(t, e2, r, o) {
      var f = FS(e2, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p = o ? r : "highWaterMark";
          throw new OS(p, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wg.exports = { getHighWaterMark: US };
  });
  bl = T((hk, Ag) => {
    Ag.exports = ut;
    function _g(t) {
      var e2 = this;
      this.next = null, this.entry = null, this.finish = function() {
        cE(e2, t);
      };
    }
    var xf;
    ut.WritableState = ka;
    var zS = { deprecate: G0() }, xg = hl(), ks = Ut().Buffer, HS = global.Uint8Array || function() {
    };
    function WS(t) {
      return ks.from(t);
    }
    function KS(t) {
      return ks.isBuffer(t) || t instanceof HS;
    }
    var vl = dl(), jS = cl(), ZS = jS.getHighWaterMark, Vi = kn().codes, VS = Vi.ERR_INVALID_ARG_TYPE, $S = Vi.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi.ERR_MULTIPLE_CALLBACK, YS = Vi.ERR_STREAM_CANNOT_PIPE, XS = Vi.ERR_STREAM_DESTROYED, JS = Vi.ERR_STREAM_NULL_VALUES, QS = Vi.ERR_STREAM_WRITE_AFTER_END, eE = Vi.ERR_UNKNOWN_ENCODING, Sf = vl.errorOrDestroy;
    Ie()(ut, xg);
    function tE() {
    }
    function ka(t, e2, r) {
      xf = xf || Ln(), t = t || {}, typeof r != "boolean" && (r = e2 instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        sE(e2, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
    }
    ka.prototype.getBuffer = function() {
      for (var e2 = this.bufferedRequest, r = [];e2; )
        r.push(e2), e2 = e2.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(ka.prototype, "buffer", { get: zS.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ts;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut, Symbol.hasInstance, { value: function(e2) {
      return Ts.call(this, e2) ? true : this !== ut ? false : e2 && e2._writableState instanceof ka;
    } })) : Ts = function(e2) {
      return e2 instanceof this;
    };
    function ut(t) {
      xf = xf || Ln();
      var e2 = this instanceof xf;
      if (!e2 && !Ts.call(ut, this))
        return new ut(t);
      this._writableState = new ka(t, this, e2), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    ut.prototype.pipe = function() {
      Sf(this, new YS);
    };
    function rE(t, e2) {
      var r = new QS;
      Sf(t, r), process.nextTick(e2, r);
    }
    function iE(t, e2, r, o) {
      var f;
      return r === null ? f = new JS : typeof r != "string" && !e2.objectMode && (f = new VS("chunk", ["string", "Buffer"], r)), f ? (Sf(t, f), process.nextTick(o, f), false) : true;
    }
    ut.prototype.write = function(t, e2, r) {
      var o = this._writableState, f = false, p = !o.objectMode && KS(t);
      return p && !ks.isBuffer(t) && (t = WS(t)), typeof e2 == "function" && (r = e2, e2 = null), p ? e2 = "buffer" : e2 || (e2 = o.defaultEncoding), typeof r != "function" && (r = tE), o.ending ? rE(this, r) : (p || iE(this, o, t, r)) && (o.pendingcb++, f = fE(this, o, p, t, e2, r)), f;
    };
    ut.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
    };
    ut.prototype.setDefaultEncoding = function(e2) {
      if (typeof e2 == "string" && (e2 = e2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase()) > -1))
        throw new eE(e2);
      return this._writableState.defaultEncoding = e2, this;
    };
    Object.defineProperty(ut.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function nE(t, e2, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e2 == "string" && (e2 = ks.from(e2, r)), e2;
    }
    Object.defineProperty(ut.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function fE(t, e2, r, o, f, p) {
      if (!r) {
        var m = nE(e2, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e2.objectMode ? 1 : o.length;
      e2.length += y;
      var M = e2.length < e2.highWaterMark;
      if (M || (e2.needDrain = true), e2.writing || e2.corked) {
        var x = e2.lastBufferedRequest;
        e2.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p, next: null }, x ? x.next = e2.lastBufferedRequest : e2.bufferedRequest = e2.lastBufferedRequest, e2.bufferedRequestCount += 1;
      } else
        pl(t, e2, false, y, o, f, p);
      return M;
    }
    function pl(t, e2, r, o, f, p, m) {
      e2.writelen = o, e2.writecb = m, e2.writing = true, e2.sync = true, e2.destroyed ? e2.onwrite(new XS("write")) : r ? t._writev(f, e2.onwrite) : t._write(f, p, e2.onwrite), e2.sync = false;
    }
    function aE(t, e2, r, o, f) {
      --e2.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Ta, t, e2), t._writableState.errorEmitted = true, Sf(t, o)) : (f(o), t._writableState.errorEmitted = true, Sf(t, o), Ta(t, e2));
    }
    function oE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function sE(t, e2) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new GS;
      if (oE(r), e2)
        aE(t, r, o, e2, f);
      else {
        var p = Eg(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o ? process.nextTick(Mg, t, r, p, f) : Mg(t, r, p, f);
      }
    }
    function Mg(t, e2, r, o) {
      r || hE(t, e2), e2.pendingcb--, o(), Ta(t, e2);
    }
    function hE(t, e2) {
      e2.length === 0 && e2.needDrain && (e2.needDrain = false, t.emit("drain"));
    }
    function Sg(t, e2) {
      e2.bufferProcessing = true;
      var r = e2.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e2.bufferedRequestCount, f = new Array(o), p = e2.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, pl(t, e2, true, e2.length, f, "", p.finish), e2.pendingcb++, e2.lastBufferedRequest = null, p.next ? (e2.corkedRequestsFree = p.next, p.next = null) : e2.corkedRequestsFree = new _g(e2), e2.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S } = r, E = e2.objectMode ? 1 : M.length;
          if (pl(t, e2, false, E, M, x, S), r = r.next, e2.bufferedRequestCount--, e2.writing)
            break;
        }
        r === null && (e2.lastBufferedRequest = null);
      }
      e2.bufferedRequest = r, e2.bufferProcessing = false;
    }
    ut.prototype._write = function(t, e2, r) {
      r(new $S("_write()"));
    };
    ut.prototype._writev = null;
    ut.prototype.end = function(t, e2, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e2 = null) : typeof e2 == "function" && (r = e2, e2 = null), t != null && this.write(t, e2), o.corked && (o.corked = 1, this.uncork()), o.ending || dE(this, o, r), this;
    };
    Object.defineProperty(ut.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Eg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function uE(t, e2) {
      t._final(function(r) {
        e2.pendingcb--, r && Sf(t, r), e2.prefinished = true, t.emit("prefinish"), Ta(t, e2);
      });
    }
    function lE(t, e2) {
      !e2.prefinished && !e2.finalCalled && (typeof t._final == "function" && !e2.destroyed ? (e2.pendingcb++, e2.finalCalled = true, process.nextTick(uE, t, e2)) : (e2.prefinished = true, t.emit("prefinish")));
    }
    function Ta(t, e2) {
      var r = Eg(e2);
      if (r && (lE(t, e2), e2.pendingcb === 0 && (e2.finished = true, t.emit("finish"), e2.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function dE(t, e2, r) {
      e2.ending = true, Ta(t, e2), r && (e2.finished ? process.nextTick(r) : t.once("finish", r)), e2.ended = true, t.writable = false;
    }
    function cE(t, e2, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e2.pendingcb--, f(r), o = o.next;
      }
      e2.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e2) {
      !this._writableState || (this._writableState.destroyed = e2);
    } });
    ut.prototype.destroy = vl.destroy;
    ut.prototype._undestroy = vl.undestroy;
    ut.prototype._destroy = function(t, e2) {
      e2(t);
    };
  });
  Ln = T((uk, Bg) => {
    var pE = Object.keys || function(t) {
      var e2 = [];
      for (var r in t)
        e2.push(r);
      return e2;
    };
    Bg.exports = ti;
    var Rg = yl(), gl = bl();
    Ie()(ti, Rg);
    for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
      Ns = ml[Ls], ti.prototype[Ns] || (ti.prototype[Ns] = gl.prototype[Ns]);
    var ml, Ns, Ls;
    function ti(t) {
      if (!(this instanceof ti))
        return new ti(t);
      Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
    }
    Object.defineProperty(ti.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ti.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ti.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function vE() {
      this._writableState.ended || process.nextTick(bE, this);
    }
    function bE(t) {
      t.end();
    }
    Object.defineProperty(ti.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e2) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
    } });
  });
  Ds = T((lk, Tg) => {
    var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function mE(t) {
      var e2 = false;
      return function() {
        if (!e2) {
          e2 = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function gE() {
    }
    function yE(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Ig(t, e2, r) {
      if (typeof e2 == "function")
        return Ig(t, null, e2);
      e2 || (e2 = {}), r = mE(r || gE);
      var o = e2.readable || e2.readable !== false && t.readable, f = e2.writable || e2.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S = function(L) {
        r.call(t, L);
      }, E = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new qg), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new qg), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return yE(t) ? (t.on("complete", y), t.on("abort", E), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e2.error !== false && t.on("error", S), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S), t.removeListener("close", E);
      };
    }
    Tg.exports = Ig;
  });
  Lg = T((dk, kg) => {
    var Ps;
    function $i(t, e2, r) {
      return e2 in t ? Object.defineProperty(t, e2, { value: r, enumerable: true, configurable: true, writable: true }) : t[e2] = r, t;
    }
    var wE = Ds(), Gi = Symbol("lastResolve"), Nn = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
    function Yi(t, e2) {
      return { value: t, done: e2 };
    }
    function ME(t) {
      var e2 = t[Gi];
      if (e2 !== null) {
        var r = t[Pn].read();
        r !== null && (t[Dn] = null, t[Gi] = null, t[Nn] = null, e2(Yi(r, false)));
      }
    }
    function _E(t) {
      process.nextTick(ME, t);
    }
    function xE(t, e2) {
      return function(r, o) {
        t.then(function() {
          if (e2[Cs]) {
            r(Yi(undefined, true));
            return;
          }
          e2[wl](r, o);
        }, o);
      };
    }
    var SE = Object.getPrototypeOf(function() {
    }), EE = Object.setPrototypeOf((Ps = { get stream() {
      return this[Pn];
    }, next: function() {
      var e2 = this, r = this[La];
      if (r !== null)
        return Promise.reject(r);
      if (this[Cs])
        return Promise.resolve(Yi(undefined, true));
      if (this[Pn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e2[La] ? y(e2[La]) : m(Yi(undefined, true));
          });
        });
      var o = this[Dn], f;
      if (o)
        f = new Promise(xE(o, this));
      else {
        var p = this[Pn].read();
        if (p !== null)
          return Promise.resolve(Yi(p, false));
        f = new Promise(this[wl]);
      }
      return this[Dn] = f, f;
    } }, $i(Ps, Symbol.asyncIterator, function() {
      return this;
    }), $i(Ps, "return", function() {
      var e2 = this;
      return new Promise(function(r, o) {
        e2[Pn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Yi(undefined, true));
        });
      });
    }), Ps), SE), AE = function(e2) {
      var r, o = Object.create(EE, (r = {}, $i(r, Pn, { value: e2, writable: true }), $i(r, Gi, { value: null, writable: true }), $i(r, Nn, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e2._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p, m) {
        var y = o[Pn].read();
        y ? (o[Dn] = null, o[Gi] = null, o[Nn] = null, p(Yi(y, false))) : (o[Gi] = p, o[Nn] = m);
      }, writable: true }), r));
      return o[Dn] = null, wE(e2, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[Nn];
          p !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, p(f)), o[La] = f;
          return;
        }
        var m = o[Gi];
        m !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, m(Yi(undefined, true))), o[Cs] = true;
      }), e2.on("readable", _E.bind(null, o)), o;
    };
    kg.exports = AE;
  });
  Dg = T((ck, Ng) => {
    Ng.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  yl = T((vk, jg) => {
    jg.exports = Oe;
    var Ef;
    Oe.ReadableState = Fg;
    var pk = ki().EventEmitter, Og = function(e2, r) {
      return e2.listeners(r).length;
    }, Da = hl(), Os = Ut().Buffer, RE = global.Uint8Array || function() {
    };
    function BE(t) {
      return Os.from(t);
    }
    function qE(t) {
      return Os.isBuffer(t) || t instanceof RE;
    }
    var Ml = $f(), De;
    Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {
    };
    var IE = pg(), Bl = dl(), TE = cl(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af, _l, xl;
    Ie()(Oe, Da);
    var Na = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
    function CE(t, e2, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e2, r);
      !t._events || !t._events[e2] ? t.on(e2, r) : Array.isArray(t._events[e2]) ? t._events[e2].unshift(r) : t._events[e2] = [r, t._events[e2]];
    }
    function Fg(t, e2, r) {
      Ef = Ef || Ln(), t = t || {}, typeof r != "boolean" && (r = e2 instanceof Ef), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af || (Af = (Qf(), ur(Jf)).StringDecoder), this.decoder = new Af(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Ef = Ef || Ln(), !(this instanceof Oe))
        return new Oe(t);
      var e2 = this instanceof Ef;
      this._readableState = new Fg(t, this, e2), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e2) {
      !this._readableState || (this._readableState.destroyed = e2);
    } });
    Oe.prototype.destroy = Bl.destroy;
    Oe.prototype._undestroy = Bl.undestroy;
    Oe.prototype._destroy = function(t, e2) {
      e2(t);
    };
    Oe.prototype.push = function(t, e2) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e2 = e2 || r.defaultEncoding, e2 !== r.encoding && (t = Os.from(t, e2), e2 = ""), o = true), Ug(this, t, e2, false, o);
    };
    Oe.prototype.unshift = function(t) {
      return Ug(this, t, null, true, false);
    };
    function Ug(t, e2, r, o, f) {
      De("readableAddChunk", e2);
      var p = t._readableState;
      if (e2 === null)
        p.reading = false, UE(t, p);
      else {
        var m;
        if (f || (m = OE(p, e2)), m)
          Na(t, m);
        else if (p.objectMode || e2 && e2.length > 0)
          if (typeof e2 != "string" && !p.objectMode && Object.getPrototypeOf(e2) !== Os.prototype && (e2 = BE(e2)), o)
            p.endEmitted ? Na(t, new PE) : El(t, p, e2, true);
          else if (p.ended)
            Na(t, new NE);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e2 = p.decoder.write(e2), p.objectMode || e2.length !== 0 ? El(t, p, e2, false) : Rl(t, p)) : El(t, p, e2, false);
          }
        else
          o || (p.reading = false, Rl(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function El(t, e2, r, o) {
      e2.flowing && e2.length === 0 && !e2.sync ? (e2.awaitDrain = 0, t.emit("data", r)) : (e2.length += e2.objectMode ? 1 : r.length, o ? e2.buffer.unshift(r) : e2.buffer.push(r), e2.needReadable && Us(t)), Rl(t, e2);
    }
    function OE(t, e2) {
      var r;
      return !qE(e2) && typeof e2 != "string" && e2 !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e2)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      Af || (Af = (Qf(), ur(Jf)).StringDecoder);
      var e2 = new Af(t);
      this._readableState.decoder = e2, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e2.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Pg = 1073741824;
    function FE(t) {
      return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Cg(t, e2) {
      return t <= 0 || e2.length === 0 && e2.ended ? 0 : e2.objectMode ? 1 : t !== t ? e2.flowing && e2.length ? e2.buffer.head.data.length : e2.length : (t > e2.highWaterMark && (e2.highWaterMark = FE(t)), t <= e2.length ? t : e2.ended ? e2.length : (e2.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      De("read", t), t = parseInt(t, 10);
      var e2 = this._readableState, r = t;
      if (t !== 0 && (e2.emittedReadable = false), t === 0 && e2.needReadable && ((e2.highWaterMark !== 0 ? e2.length >= e2.highWaterMark : e2.length > 0) || e2.ended))
        return De("read: emitReadable", e2.length, e2.ended), e2.length === 0 && e2.ended ? Al(this) : Us(this), null;
      if (t = Cg(t, e2), t === 0 && e2.ended)
        return e2.length === 0 && Al(this), null;
      var o = e2.needReadable;
      De("need readable", o), (e2.length === 0 || e2.length - t < e2.highWaterMark) && (o = true, De("length less than watermark", o)), e2.ended || e2.reading ? (o = false, De("reading or ended", o)) : o && (De("do read"), e2.reading = true, e2.sync = true, e2.length === 0 && (e2.needReadable = true), this._read(e2.highWaterMark), e2.sync = false, e2.reading || (t = Cg(r, e2)));
      var f;
      return t > 0 ? f = Wg(t, e2) : f = null, f === null ? (e2.needReadable = e2.length <= e2.highWaterMark, t = 0) : (e2.length -= t, e2.awaitDrain = 0), e2.length === 0 && (e2.ended || (e2.needReadable = true), r !== t && e2.ended && Al(this)), f !== null && this.emit("data", f), f;
    };
    function UE(t, e2) {
      if (De("onEofChunk"), !e2.ended) {
        if (e2.decoder) {
          var r = e2.decoder.end();
          r && r.length && (e2.buffer.push(r), e2.length += e2.objectMode ? 1 : r.length);
        }
        e2.ended = true, e2.sync ? Us(t) : (e2.needReadable = false, e2.emittedReadable || (e2.emittedReadable = true, zg(t)));
      }
    }
    function Us(t) {
      var e2 = t._readableState;
      De("emitReadable", e2.needReadable, e2.emittedReadable), e2.needReadable = false, e2.emittedReadable || (De("emitReadable", e2.flowing), e2.emittedReadable = true, process.nextTick(zg, t));
    }
    function zg(t) {
      var e2 = t._readableState;
      De("emitReadable_", e2.destroyed, e2.length, e2.ended), !e2.destroyed && (e2.length || e2.ended) && (t.emit("readable"), e2.emittedReadable = false), e2.needReadable = !e2.flowing && !e2.ended && e2.length <= e2.highWaterMark, ql(t);
    }
    function Rl(t, e2) {
      e2.readingMore || (e2.readingMore = true, process.nextTick(zE, t, e2));
    }
    function zE(t, e2) {
      for (;!e2.reading && !e2.ended && (e2.length < e2.highWaterMark || e2.flowing && e2.length === 0); ) {
        var r = e2.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e2.length)
          break;
      }
      e2.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Na(this, new DE("_read()"));
    };
    Oe.prototype.pipe = function(t, e2) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, De("pipe count=%d opts=%j", o.pipesCount, e2);
      var f = (!e2 || e2.end !== false) && t !== process.stdout && t !== process.stderr, p = f ? y : ge;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, N) {
        De("onunpipe"), _e === r && N && N.hasUnpiped === false && (N.hasUnpiped = true, S());
      }
      function y() {
        De("onend"), t.end();
      }
      var M = HE(r);
      t.on("drain", M);
      var x = false;
      function S() {
        De("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        De("ondata");
        var N = t.write(_e);
        De("dest.write", N), N === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Kg(o.pipes, t) !== -1) && !x && (De("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        De("onerror", _e), ge(), t.removeListener("error", B), Og(t, "error") === 0 && Na(t, _e);
      }
      CE(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        De("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (De("pipe resume"), r.resume()), t;
    };
    function HE(t) {
      return function() {
        var r = t._readableState;
        De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e2 = this._readableState, r = { hasUnpiped: false };
      if (e2.pipesCount === 0)
        return this;
      if (e2.pipesCount === 1)
        return t && t !== e2.pipes ? this : (t || (t = e2.pipes), e2.pipes = null, e2.pipesCount = 0, e2.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e2;
        e2.pipes = null, e2.pipesCount = 0, e2.flowing = false;
        for (var p = 0;p < f; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Kg(e2.pipes, t);
      return m === -1 ? this : (e2.pipes.splice(m, 1), e2.pipesCount -= 1, e2.pipesCount === 1 && (e2.pipes = e2.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e2) {
      var r = Da.prototype.on.call(this, t, e2), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, De("on readable", o.length, o.reading), o.length ? Us(this) : o.reading || process.nextTick(WE, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e2) {
      var r = Da.prototype.removeListener.call(this, t, e2);
      return t === "readable" && process.nextTick(Hg, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e2 = Da.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e2;
    };
    function Hg(t) {
      var e2 = t._readableState;
      e2.readableListening = t.listenerCount("readable") > 0, e2.resumeScheduled && !e2.paused ? e2.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function WE(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
    };
    function KE(t, e2) {
      e2.resumeScheduled || (e2.resumeScheduled = true, process.nextTick(jE, t, e2));
    }
    function jE(t, e2) {
      De("resume", e2.reading), e2.reading || t.read(0), e2.resumeScheduled = false, t.emit("resume"), ql(t), e2.flowing && !e2.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ql(t) {
      var e2 = t._readableState;
      for (De("flow", e2.flowing);e2.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e2 = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (De("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e2.push(m);
        }
        e2.push(null);
      }), t.on("data", function(m) {
        if (De("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e2.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p = 0;p < Sl.length; p++)
        t.on(Sl[p], this.emit.bind(this, Sl[p]));
      return this._read = function(m) {
        De("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return _l === undefined && (_l = Lg()), _l(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e2) {
      this._readableState && (this._readableState.flowing = e2);
    } });
    Oe._fromList = Wg;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wg(t, e2) {
      if (e2.length === 0)
        return null;
      var r;
      return e2.objectMode ? r = e2.buffer.shift() : !t || t >= e2.length ? (e2.decoder ? r = e2.buffer.join("") : e2.buffer.length === 1 ? r = e2.buffer.first() : r = e2.buffer.concat(e2.length), e2.buffer.clear()) : r = e2.buffer.consume(t, e2.decoder), r;
    }
    function Al(t) {
      var e2 = t._readableState;
      De("endReadable", e2.endEmitted), e2.endEmitted || (e2.ended = true, process.nextTick(ZE, e2, t));
    }
    function ZE(t, e2) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e2.readable = false, e2.emit("end"), t.autoDestroy)) {
        var r = e2._writableState;
        (!r || r.autoDestroy && r.finished) && e2.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e2) {
      return xl === undefined && (xl = Dg()), xl(Oe, t, e2);
    });
    function Kg(t, e2) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e2)
          return r;
      return -1;
    }
  });
  Il = T((bk, Vg) => {
    Vg.exports = Ei;
    var zs = kn().codes, VE = zs.ERR_METHOD_NOT_IMPLEMENTED, $E = zs.ERR_MULTIPLE_CALLBACK, GE = zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs.ERR_TRANSFORM_WITH_LENGTH_0, Hs = Ln();
    Ie()(Ei, Hs);
    function XE(t, e2) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new $E);
      r.writechunk = null, r.writecb = null, e2 != null && this.push(e2), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function Ei(t) {
      if (!(this instanceof Ei))
        return new Ei(t);
      Hs.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
    }
    function JE() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e2, r) {
        Zg(t, e2, r);
      }) : Zg(this, null, null);
    }
    Ei.prototype.push = function(t, e2) {
      return this._transformState.needTransform = false, Hs.prototype.push.call(this, t, e2);
    };
    Ei.prototype._transform = function(t, e2, r) {
      r(new VE("_transform()"));
    };
    Ei.prototype._write = function(t, e2, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e2, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    Ei.prototype._read = function(t) {
      var e2 = this._transformState;
      e2.writechunk !== null && !e2.transforming ? (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform)) : e2.needTransform = true;
    };
    Ei.prototype._destroy = function(t, e2) {
      Hs.prototype._destroy.call(this, t, function(r) {
        e2(r);
      });
    };
    function Zg(t, e2, r) {
      if (e2)
        return t.emit("error", e2);
      if (r != null && t.push(r), t._writableState.length)
        throw new YE;
      if (t._transformState.transforming)
        throw new GE;
      return t.push(null);
    }
  });
  Yg = T((mk, Gg) => {
    Gg.exports = Pa;
    var $g = Il();
    Ie()(Pa, $g);
    function Pa(t) {
      if (!(this instanceof Pa))
        return new Pa(t);
      $g.call(this, t);
    }
    Pa.prototype._transform = function(t, e2, r) {
      r(null, t);
    };
  });
  t2 = T((gk, e2) => {
    var Tl;
    function QE(t) {
      var e3 = false;
      return function() {
        e3 || (e3 = true, t.apply(undefined, arguments));
      };
    }
    var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
    function Xg(t) {
      if (t)
        throw t;
    }
    function rA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function iA(t, e3, r, o) {
      o = QE(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e3, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p = false;
      return function(m) {
        if (!f && !p) {
          if (p = true, rA(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new tA("pipe"));
        }
      };
    }
    function Jg(t) {
      t();
    }
    function nA(t, e3) {
      return t.pipe(e3);
    }
    function fA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
    }
    function aA() {
      for (var t = arguments.length, e3 = new Array(t), r = 0;r < t; r++)
        e3[r] = arguments[r];
      var o = fA(e3);
      if (Array.isArray(e3[0]) && (e3 = e3[0]), e3.length < 2)
        throw new eA("streams");
      var f, p = e3.map(function(m, y) {
        var M = y < e3.length - 1, x = y > 0;
        return iA(m, M, x, function(S) {
          f || (f = S), S && p.forEach(Jg), !M && (p.forEach(Jg), o(f));
        });
      });
      return e3.reduce(nA);
    }
    e2.exports = aA;
  });
  i2 = T((Mr, r2) => {
    Mr = r2.exports = yl();
    Mr.Stream = Mr;
    Mr.Readable = Mr;
    Mr.Writable = bl();
    Mr.Duplex = Ln();
    Mr.Transform = Il();
    Mr.PassThrough = Yg();
    Mr.finished = Ds();
    Mr.pipeline = t2();
  });
  Ws = T((n25, kl) => {
    (function(t, e2) {
      function r(h, s) {
        if (!h)
          throw new Error(s || "Assertion failed");
      }
      function o(h, s) {
        h.super_ = s;
        var u = function() {
        };
        u.prototype = s.prototype, h.prototype = new u, h.prototype.constructor = h;
      }
      function f(h, s, u) {
        if (f.isBN(h))
          return h;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h !== null && ((s === "le" || s === "be") && (u = s, s = 10), this._init(h || 0, s || 10, u || "be"));
      }
      typeof t == "object" ? t.exports = f : e2.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(s) {
        return s instanceof f ? true : s !== null && typeof s == "object" && s.constructor.wordSize === f.wordSize && Array.isArray(s.words);
      }, f.max = function(s, u) {
        return s.cmp(u) > 0 ? s : u;
      }, f.min = function(s, u) {
        return s.cmp(u) < 0 ? s : u;
      }, f.prototype._init = function(s, u, c) {
        if (typeof s == "number")
          return this._initNumber(s, u, c);
        if (typeof s == "object")
          return this._initArray(s, u, c);
        u === "hex" && (u = 16), r(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\s+/g, "");
        var b = 0;
        s[0] === "-" && (b++, this.negative = 1), b < s.length && (u === 16 ? this._parseHex(s, b, c) : (this._parseBase(s, u, b), c === "le" && this._initArray(this.toArray(), u, c)));
      }, f.prototype._initNumber = function(s, u, c) {
        s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (r(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), c === "le" && this._initArray(this.toArray(), u, c);
      }, f.prototype._initArray = function(s, u, c) {
        if (r(typeof s.length == "number"), s.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
        for (var b = 0;b < this.length; b++)
          this.words[b] = 0;
        var l, n, d = 0;
        if (c === "be")
          for (b = s.length - 1, l = 0;b >= 0; b -= 3)
            n = s[b] | s[b - 1] << 8 | s[b - 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        else if (c === "le")
          for (b = 0, l = 0;b < s.length; b += 3)
            n = s[b] | s[b + 1] << 8 | s[b + 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        return this._strip();
      };
      function m(h, s) {
        var u = h.charCodeAt(s);
        if (u >= 48 && u <= 57)
          return u - 48;
        if (u >= 65 && u <= 70)
          return u - 55;
        if (u >= 97 && u <= 102)
          return u - 87;
        r(false, "Invalid character in " + h);
      }
      function y(h, s, u) {
        var c = m(h, u);
        return u - 1 >= s && (c |= m(h, u - 1) << 4), c;
      }
      f.prototype._parseHex = function(s, u, c) {
        this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);
        for (var b = 0;b < this.length; b++)
          this.words[b] = 0;
        var l = 0, n = 0, d;
        if (c === "be")
          for (b = s.length - 1;b >= u; b -= 2)
            d = y(s, u, b) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        else {
          var w = s.length - u;
          for (b = w % 2 === 0 ? u + 1 : u;b < s.length; b += 2)
            d = y(s, u, b) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        }
        this._strip();
      };
      function M(h, s, u, c) {
        for (var b = 0, l = 0, n = Math.min(h.length, u), d = s;d < n; d++) {
          var w = h.charCodeAt(d) - 48;
          b *= c, w >= 49 ? l = w - 49 + 10 : w >= 17 ? l = w - 17 + 10 : l = w, r(w >= 0 && l < c, "Invalid character"), b += l;
        }
        return b;
      }
      f.prototype._parseBase = function(s, u, c) {
        this.words = [0], this.length = 1;
        for (var b = 0, l = 1;l <= 67108863; l *= u)
          b++;
        b--, l = l / u | 0;
        for (var n = s.length - c, d = n % b, w = Math.min(n, n - d) + c, g = 0, _ = c;_ < w; _ += b)
          g = M(s, _, _ + b, u), this.imuln(l), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        if (d !== 0) {
          var A = 1;
          for (g = M(s, _, s.length, u), _ = 0;_ < d; _++)
            A *= u;
          this.imuln(A), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        }
        this._strip();
      }, f.prototype.copy = function(s) {
        s.words = new Array(this.length);
        for (var u = 0;u < this.length; u++)
          s.words[u] = this.words[u];
        s.length = this.length, s.negative = this.negative, s.red = this.red;
      };
      function x(h, s) {
        h.words = s.words, h.length = s.length, h.negative = s.negative, h.red = s.red;
      }
      if (f.prototype._move = function(s) {
        x(s, this);
      }, f.prototype.clone = function() {
        var s = new f(null);
        return this.copy(s), s;
      }, f.prototype._expand = function(s) {
        for (;this.length < s; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f.prototype[Symbol.for("nodejs.util.inspect.custom")] = S;
        } catch {
          f.prototype.inspect = S;
        }
      else
        f.prototype.inspect = S;
      function S() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(s, u) {
        s = s || 10, u = u | 0 || 1;
        var c;
        if (s === 16 || s === "hex") {
          c = "";
          for (var b = 0, l = 0, n = 0;n < this.length; n++) {
            var d = this.words[n], w = ((d << b | l) & 16777215).toString(16);
            l = d >>> 24 - b & 16777215, b += 2, b >= 26 && (b -= 26, n--), l !== 0 || n !== this.length - 1 ? c = E[6 - w.length] + w + c : c = w + c;
          }
          for (l !== 0 && (c = l.toString(16) + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        if (s === (s | 0) && s >= 2 && s <= 36) {
          var g = B[s], _ = q[s];
          c = "";
          var A = this.clone();
          for (A.negative = 0;!A.isZero(); ) {
            var R = A.modrn(_).toString(s);
            A = A.idivn(_), A.isZero() ? c = R + c : c = E[g - R.length] + R + c;
          }
          for (this.isZero() && (c = "0" + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var s = this.words[0];
        return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s;
      }, f.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p && (f.prototype.toBuffer = function(s, u) {
        return this.toArrayLike(p, s, u);
      }), f.prototype.toArray = function(s, u) {
        return this.toArrayLike(Array, s, u);
      };
      var L = function(s, u) {
        return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);
      };
      f.prototype.toArrayLike = function(s, u, c) {
        this._strip();
        var b = this.byteLength(), l = c || Math.max(1, b);
        r(b <= l, "byte array longer than desired length"), r(l > 0, "Requested array length <= 0");
        var n = L(s, l), d = u === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d](n, b), n;
      }, f.prototype._toArrayLikeLE = function(s, u) {
        for (var c = 0, b = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b;
          s[c++] = d & 255, c < s.length && (s[c++] = d >> 8 & 255), c < s.length && (s[c++] = d >> 16 & 255), n === 6 ? (c < s.length && (s[c++] = d >> 24 & 255), b = 0, n = 0) : (b = d >>> 24, n += 2);
        }
        if (c < s.length)
          for (s[c++] = b;c < s.length; )
            s[c++] = 0;
      }, f.prototype._toArrayLikeBE = function(s, u) {
        for (var c = s.length - 1, b = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b;
          s[c--] = d & 255, c >= 0 && (s[c--] = d >> 8 & 255), c >= 0 && (s[c--] = d >> 16 & 255), n === 6 ? (c >= 0 && (s[c--] = d >> 24 & 255), b = 0, n = 0) : (b = d >>> 24, n += 2);
        }
        if (c >= 0)
          for (s[c--] = b;c >= 0; )
            s[c--] = 0;
      }, Math.clz32 ? f.prototype._countBits = function(s) {
        return 32 - Math.clz32(s);
      } : f.prototype._countBits = function(s) {
        var u = s, c = 0;
        return u >= 4096 && (c += 13, u >>>= 13), u >= 64 && (c += 7, u >>>= 7), u >= 8 && (c += 4, u >>>= 4), u >= 2 && (c += 2, u >>>= 2), c + u;
      }, f.prototype._zeroBits = function(s) {
        if (s === 0)
          return 26;
        var u = s, c = 0;
        return (u & 8191) === 0 && (c += 13, u >>>= 13), (u & 127) === 0 && (c += 7, u >>>= 7), (u & 15) === 0 && (c += 4, u >>>= 4), (u & 3) === 0 && (c += 2, u >>>= 2), (u & 1) === 0 && c++, c;
      }, f.prototype.bitLength = function() {
        var s = this.words[this.length - 1], u = this._countBits(s);
        return (this.length - 1) * 26 + u;
      };
      function ge(h) {
        for (var s = new Array(h.bitLength()), u = 0;u < s.length; u++) {
          var c = u / 26 | 0, b = u % 26;
          s[u] = h.words[c] >>> b & 1;
        }
        return s;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s = 0, u = 0;u < this.length; u++) {
          var c = this._zeroBits(this.words[u]);
          if (s += c, c !== 26)
            break;
        }
        return s;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(s) {
        return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(s) {
        return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(s) {
        for (;this.length < s.length; )
          this.words[this.length++] = 0;
        for (var u = 0;u < s.length; u++)
          this.words[u] = this.words[u] | s.words[u];
        return this._strip();
      }, f.prototype.ior = function(s) {
        return r((this.negative | s.negative) === 0), this.iuor(s);
      }, f.prototype.or = function(s) {
        return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);
      }, f.prototype.uor = function(s) {
        return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);
      }, f.prototype.iuand = function(s) {
        var u;
        this.length > s.length ? u = s : u = this;
        for (var c = 0;c < u.length; c++)
          this.words[c] = this.words[c] & s.words[c];
        return this.length = u.length, this._strip();
      }, f.prototype.iand = function(s) {
        return r((this.negative | s.negative) === 0), this.iuand(s);
      }, f.prototype.and = function(s) {
        return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);
      }, f.prototype.uand = function(s) {
        return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);
      }, f.prototype.iuxor = function(s) {
        var u, c;
        this.length > s.length ? (u = this, c = s) : (u = s, c = this);
        for (var b = 0;b < c.length; b++)
          this.words[b] = u.words[b] ^ c.words[b];
        if (this !== u)
          for (;b < u.length; b++)
            this.words[b] = u.words[b];
        return this.length = u.length, this._strip();
      }, f.prototype.ixor = function(s) {
        return r((this.negative | s.negative) === 0), this.iuxor(s);
      }, f.prototype.xor = function(s) {
        return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);
      }, f.prototype.uxor = function(s) {
        return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);
      }, f.prototype.inotn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = Math.ceil(s / 26) | 0, c = s % 26;
        this._expand(u), c > 0 && u--;
        for (var b = 0;b < u; b++)
          this.words[b] = ~this.words[b] & 67108863;
        return c > 0 && (this.words[b] = ~this.words[b] & 67108863 >> 26 - c), this._strip();
      }, f.prototype.notn = function(s) {
        return this.clone().inotn(s);
      }, f.prototype.setn = function(s, u) {
        r(typeof s == "number" && s >= 0);
        var c = s / 26 | 0, b = s % 26;
        return this._expand(c + 1), u ? this.words[c] = this.words[c] | 1 << b : this.words[c] = this.words[c] & ~(1 << b), this._strip();
      }, f.prototype.iadd = function(s) {
        var u;
        if (this.negative !== 0 && s.negative === 0)
          return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s.negative !== 0)
          return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();
        var c, b;
        this.length > s.length ? (c = this, b = s) : (c = s, b = this);
        for (var l = 0, n = 0;n < b.length; n++)
          u = (c.words[n] | 0) + (b.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        for (;l !== 0 && n < c.length; n++)
          u = (c.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        if (this.length = c.length, l !== 0)
          this.words[this.length] = l, this.length++;
        else if (c !== this)
          for (;n < c.length; n++)
            this.words[n] = c.words[n];
        return this;
      }, f.prototype.add = function(s) {
        var u;
        return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);
      }, f.prototype.isub = function(s) {
        if (s.negative !== 0) {
          s.negative = 0;
          var u = this.iadd(s);
          return s.negative = 1, u._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
        var c = this.cmp(s);
        if (c === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b, l;
        c > 0 ? (b = this, l = s) : (b = s, l = this);
        for (var n = 0, d = 0;d < l.length; d++)
          u = (b.words[d] | 0) - (l.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        for (;n !== 0 && d < b.length; d++)
          u = (b.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        if (n === 0 && d < b.length && b !== this)
          for (;d < b.length; d++)
            this.words[d] = b.words[d];
        return this.length = Math.max(this.length, d), b !== this && (this.negative = 1), this._strip();
      }, f.prototype.sub = function(s) {
        return this.clone().isub(s);
      };
      function _e(h, s, u) {
        u.negative = s.negative ^ h.negative;
        var c = h.length + s.length | 0;
        u.length = c, c = c - 1 | 0;
        var b = h.words[0] | 0, l = s.words[0] | 0, n = b * l, d = n & 67108863, w = n / 67108864 | 0;
        u.words[0] = d;
        for (var g = 1;g < c; g++) {
          for (var _ = w >>> 26, A = w & 67108863, R = Math.min(g, s.length - 1), I = Math.max(0, g - h.length + 1);I <= R; I++) {
            var Me = g - I | 0;
            b = h.words[Me] | 0, l = s.words[I] | 0, n = b * l + A, _ += n / 67108864 | 0, A = n & 67108863;
          }
          u.words[g] = A | 0, w = _ | 0;
        }
        return w !== 0 ? u.words[g] = w | 0 : u.length--, u._strip();
      }
      var N = function(s, u, c) {
        var b = s.words, l = u.words, n = c.words, d = 0, w, g, _, A = b[0] | 0, R = A & 8191, I = A >>> 13, Me = b[1] | 0, k = Me & 8191, D = Me >>> 13, nt = b[2] | 0, C = nt & 8191, O = nt >>> 13, vt = b[3] | 0, F = vt & 8191, U = vt >>> 13, bt = b[4] | 0, z = bt & 8191, H = bt >>> 13, mt = b[5] | 0, W = mt & 8191, K = mt >>> 13, gt = b[6] | 0, j = gt & 8191, Z = gt >>> 13, yt = b[7] | 0, V = yt & 8191, $ = yt >>> 13, wt = b[8] | 0, G = wt & 8191, Y = wt >>> 13, Mt = b[9] | 0, X = Mt & 8191, J = Mt >>> 13, _t = l[0] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = l[1] | 0, te = xt & 8191, re = xt >>> 13, St = l[2] | 0, ie = St & 8191, ne = St >>> 13, Et = l[3] | 0, fe = Et & 8191, ae = Et >>> 13, At = l[4] | 0, oe = At & 8191, se = At >>> 13, Rt = l[5] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = l[6] | 0, le = Bt & 8191, de = Bt >>> 13, qt = l[7] | 0, ce = qt & 8191, pe = qt >>> 13, It = l[8] | 0, ve = It & 8191, be = It >>> 13, ft = l[9] | 0, Be = ft & 8191, qe = ft >>> 13;
        c.negative = s.negative ^ u.negative, c.length = 19, w = Math.imul(R, Q2), g = Math.imul(R, ee), g = g + Math.imul(I, Q2) | 0, _ = Math.imul(I, ee);
        var ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w = Math.imul(k, Q2), g = Math.imul(k, ee), g = g + Math.imul(D, Q2) | 0, _ = Math.imul(D, ee), w = w + Math.imul(R, te) | 0, g = g + Math.imul(R, re) | 0, g = g + Math.imul(I, te) | 0, _ = _ + Math.imul(I, re) | 0;
        var He = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, w = Math.imul(C, Q2), g = Math.imul(C, ee), g = g + Math.imul(O, Q2) | 0, _ = Math.imul(O, ee), w = w + Math.imul(k, te) | 0, g = g + Math.imul(k, re) | 0, g = g + Math.imul(D, te) | 0, _ = _ + Math.imul(D, re) | 0, w = w + Math.imul(R, ie) | 0, g = g + Math.imul(R, ne) | 0, g = g + Math.imul(I, ie) | 0, _ = _ + Math.imul(I, ne) | 0;
        var We = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, w = Math.imul(F, Q2), g = Math.imul(F, ee), g = g + Math.imul(U, Q2) | 0, _ = Math.imul(U, ee), w = w + Math.imul(C, te) | 0, g = g + Math.imul(C, re) | 0, g = g + Math.imul(O, te) | 0, _ = _ + Math.imul(O, re) | 0, w = w + Math.imul(k, ie) | 0, g = g + Math.imul(k, ne) | 0, g = g + Math.imul(D, ie) | 0, _ = _ + Math.imul(D, ne) | 0, w = w + Math.imul(R, fe) | 0, g = g + Math.imul(R, ae) | 0, g = g + Math.imul(I, fe) | 0, _ = _ + Math.imul(I, ae) | 0;
        var Ke = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(z, Q2), g = Math.imul(z, ee), g = g + Math.imul(H, Q2) | 0, _ = Math.imul(H, ee), w = w + Math.imul(F, te) | 0, g = g + Math.imul(F, re) | 0, g = g + Math.imul(U, te) | 0, _ = _ + Math.imul(U, re) | 0, w = w + Math.imul(C, ie) | 0, g = g + Math.imul(C, ne) | 0, g = g + Math.imul(O, ie) | 0, _ = _ + Math.imul(O, ne) | 0, w = w + Math.imul(k, fe) | 0, g = g + Math.imul(k, ae) | 0, g = g + Math.imul(D, fe) | 0, _ = _ + Math.imul(D, ae) | 0, w = w + Math.imul(R, oe) | 0, g = g + Math.imul(R, se) | 0, g = g + Math.imul(I, oe) | 0, _ = _ + Math.imul(I, se) | 0;
        var je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w = Math.imul(W, Q2), g = Math.imul(W, ee), g = g + Math.imul(K, Q2) | 0, _ = Math.imul(K, ee), w = w + Math.imul(z, te) | 0, g = g + Math.imul(z, re) | 0, g = g + Math.imul(H, te) | 0, _ = _ + Math.imul(H, re) | 0, w = w + Math.imul(F, ie) | 0, g = g + Math.imul(F, ne) | 0, g = g + Math.imul(U, ie) | 0, _ = _ + Math.imul(U, ne) | 0, w = w + Math.imul(C, fe) | 0, g = g + Math.imul(C, ae) | 0, g = g + Math.imul(O, fe) | 0, _ = _ + Math.imul(O, ae) | 0, w = w + Math.imul(k, oe) | 0, g = g + Math.imul(k, se) | 0, g = g + Math.imul(D, oe) | 0, _ = _ + Math.imul(D, se) | 0, w = w + Math.imul(R, he) | 0, g = g + Math.imul(R, ue) | 0, g = g + Math.imul(I, he) | 0, _ = _ + Math.imul(I, ue) | 0;
        var Ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, w = Math.imul(j, Q2), g = Math.imul(j, ee), g = g + Math.imul(Z, Q2) | 0, _ = Math.imul(Z, ee), w = w + Math.imul(W, te) | 0, g = g + Math.imul(W, re) | 0, g = g + Math.imul(K, te) | 0, _ = _ + Math.imul(K, re) | 0, w = w + Math.imul(z, ie) | 0, g = g + Math.imul(z, ne) | 0, g = g + Math.imul(H, ie) | 0, _ = _ + Math.imul(H, ne) | 0, w = w + Math.imul(F, fe) | 0, g = g + Math.imul(F, ae) | 0, g = g + Math.imul(U, fe) | 0, _ = _ + Math.imul(U, ae) | 0, w = w + Math.imul(C, oe) | 0, g = g + Math.imul(C, se) | 0, g = g + Math.imul(O, oe) | 0, _ = _ + Math.imul(O, se) | 0, w = w + Math.imul(k, he) | 0, g = g + Math.imul(k, ue) | 0, g = g + Math.imul(D, he) | 0, _ = _ + Math.imul(D, ue) | 0, w = w + Math.imul(R, le) | 0, g = g + Math.imul(R, de) | 0, g = g + Math.imul(I, le) | 0, _ = _ + Math.imul(I, de) | 0;
        var Ve = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w = Math.imul(V, Q2), g = Math.imul(V, ee), g = g + Math.imul($, Q2) | 0, _ = Math.imul($, ee), w = w + Math.imul(j, te) | 0, g = g + Math.imul(j, re) | 0, g = g + Math.imul(Z, te) | 0, _ = _ + Math.imul(Z, re) | 0, w = w + Math.imul(W, ie) | 0, g = g + Math.imul(W, ne) | 0, g = g + Math.imul(K, ie) | 0, _ = _ + Math.imul(K, ne) | 0, w = w + Math.imul(z, fe) | 0, g = g + Math.imul(z, ae) | 0, g = g + Math.imul(H, fe) | 0, _ = _ + Math.imul(H, ae) | 0, w = w + Math.imul(F, oe) | 0, g = g + Math.imul(F, se) | 0, g = g + Math.imul(U, oe) | 0, _ = _ + Math.imul(U, se) | 0, w = w + Math.imul(C, he) | 0, g = g + Math.imul(C, ue) | 0, g = g + Math.imul(O, he) | 0, _ = _ + Math.imul(O, ue) | 0, w = w + Math.imul(k, le) | 0, g = g + Math.imul(k, de) | 0, g = g + Math.imul(D, le) | 0, _ = _ + Math.imul(D, de) | 0, w = w + Math.imul(R, ce) | 0, g = g + Math.imul(R, pe) | 0, g = g + Math.imul(I, ce) | 0, _ = _ + Math.imul(I, pe) | 0;
        var $e = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, w = Math.imul(G, Q2), g = Math.imul(G, ee), g = g + Math.imul(Y, Q2) | 0, _ = Math.imul(Y, ee), w = w + Math.imul(V, te) | 0, g = g + Math.imul(V, re) | 0, g = g + Math.imul($, te) | 0, _ = _ + Math.imul($, re) | 0, w = w + Math.imul(j, ie) | 0, g = g + Math.imul(j, ne) | 0, g = g + Math.imul(Z, ie) | 0, _ = _ + Math.imul(Z, ne) | 0, w = w + Math.imul(W, fe) | 0, g = g + Math.imul(W, ae) | 0, g = g + Math.imul(K, fe) | 0, _ = _ + Math.imul(K, ae) | 0, w = w + Math.imul(z, oe) | 0, g = g + Math.imul(z, se) | 0, g = g + Math.imul(H, oe) | 0, _ = _ + Math.imul(H, se) | 0, w = w + Math.imul(F, he) | 0, g = g + Math.imul(F, ue) | 0, g = g + Math.imul(U, he) | 0, _ = _ + Math.imul(U, ue) | 0, w = w + Math.imul(C, le) | 0, g = g + Math.imul(C, de) | 0, g = g + Math.imul(O, le) | 0, _ = _ + Math.imul(O, de) | 0, w = w + Math.imul(k, ce) | 0, g = g + Math.imul(k, pe) | 0, g = g + Math.imul(D, ce) | 0, _ = _ + Math.imul(D, pe) | 0, w = w + Math.imul(R, ve) | 0, g = g + Math.imul(R, be) | 0, g = g + Math.imul(I, ve) | 0, _ = _ + Math.imul(I, be) | 0;
        var Ge = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w = Math.imul(X, Q2), g = Math.imul(X, ee), g = g + Math.imul(J, Q2) | 0, _ = Math.imul(J, ee), w = w + Math.imul(G, te) | 0, g = g + Math.imul(G, re) | 0, g = g + Math.imul(Y, te) | 0, _ = _ + Math.imul(Y, re) | 0, w = w + Math.imul(V, ie) | 0, g = g + Math.imul(V, ne) | 0, g = g + Math.imul($, ie) | 0, _ = _ + Math.imul($, ne) | 0, w = w + Math.imul(j, fe) | 0, g = g + Math.imul(j, ae) | 0, g = g + Math.imul(Z, fe) | 0, _ = _ + Math.imul(Z, ae) | 0, w = w + Math.imul(W, oe) | 0, g = g + Math.imul(W, se) | 0, g = g + Math.imul(K, oe) | 0, _ = _ + Math.imul(K, se) | 0, w = w + Math.imul(z, he) | 0, g = g + Math.imul(z, ue) | 0, g = g + Math.imul(H, he) | 0, _ = _ + Math.imul(H, ue) | 0, w = w + Math.imul(F, le) | 0, g = g + Math.imul(F, de) | 0, g = g + Math.imul(U, le) | 0, _ = _ + Math.imul(U, de) | 0, w = w + Math.imul(C, ce) | 0, g = g + Math.imul(C, pe) | 0, g = g + Math.imul(O, ce) | 0, _ = _ + Math.imul(O, pe) | 0, w = w + Math.imul(k, ve) | 0, g = g + Math.imul(k, be) | 0, g = g + Math.imul(D, ve) | 0, _ = _ + Math.imul(D, be) | 0, w = w + Math.imul(R, Be) | 0, g = g + Math.imul(R, qe) | 0, g = g + Math.imul(I, Be) | 0, _ = _ + Math.imul(I, qe) | 0;
        var Ye = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(X, te), g = Math.imul(X, re), g = g + Math.imul(J, te) | 0, _ = Math.imul(J, re), w = w + Math.imul(G, ie) | 0, g = g + Math.imul(G, ne) | 0, g = g + Math.imul(Y, ie) | 0, _ = _ + Math.imul(Y, ne) | 0, w = w + Math.imul(V, fe) | 0, g = g + Math.imul(V, ae) | 0, g = g + Math.imul($, fe) | 0, _ = _ + Math.imul($, ae) | 0, w = w + Math.imul(j, oe) | 0, g = g + Math.imul(j, se) | 0, g = g + Math.imul(Z, oe) | 0, _ = _ + Math.imul(Z, se) | 0, w = w + Math.imul(W, he) | 0, g = g + Math.imul(W, ue) | 0, g = g + Math.imul(K, he) | 0, _ = _ + Math.imul(K, ue) | 0, w = w + Math.imul(z, le) | 0, g = g + Math.imul(z, de) | 0, g = g + Math.imul(H, le) | 0, _ = _ + Math.imul(H, de) | 0, w = w + Math.imul(F, ce) | 0, g = g + Math.imul(F, pe) | 0, g = g + Math.imul(U, ce) | 0, _ = _ + Math.imul(U, pe) | 0, w = w + Math.imul(C, ve) | 0, g = g + Math.imul(C, be) | 0, g = g + Math.imul(O, ve) | 0, _ = _ + Math.imul(O, be) | 0, w = w + Math.imul(k, Be) | 0, g = g + Math.imul(k, qe) | 0, g = g + Math.imul(D, Be) | 0, _ = _ + Math.imul(D, qe) | 0;
        var Xe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(X, ie), g = Math.imul(X, ne), g = g + Math.imul(J, ie) | 0, _ = Math.imul(J, ne), w = w + Math.imul(G, fe) | 0, g = g + Math.imul(G, ae) | 0, g = g + Math.imul(Y, fe) | 0, _ = _ + Math.imul(Y, ae) | 0, w = w + Math.imul(V, oe) | 0, g = g + Math.imul(V, se) | 0, g = g + Math.imul($, oe) | 0, _ = _ + Math.imul($, se) | 0, w = w + Math.imul(j, he) | 0, g = g + Math.imul(j, ue) | 0, g = g + Math.imul(Z, he) | 0, _ = _ + Math.imul(Z, ue) | 0, w = w + Math.imul(W, le) | 0, g = g + Math.imul(W, de) | 0, g = g + Math.imul(K, le) | 0, _ = _ + Math.imul(K, de) | 0, w = w + Math.imul(z, ce) | 0, g = g + Math.imul(z, pe) | 0, g = g + Math.imul(H, ce) | 0, _ = _ + Math.imul(H, pe) | 0, w = w + Math.imul(F, ve) | 0, g = g + Math.imul(F, be) | 0, g = g + Math.imul(U, ve) | 0, _ = _ + Math.imul(U, be) | 0, w = w + Math.imul(C, Be) | 0, g = g + Math.imul(C, qe) | 0, g = g + Math.imul(O, Be) | 0, _ = _ + Math.imul(O, qe) | 0;
        var Je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w = Math.imul(X, fe), g = Math.imul(X, ae), g = g + Math.imul(J, fe) | 0, _ = Math.imul(J, ae), w = w + Math.imul(G, oe) | 0, g = g + Math.imul(G, se) | 0, g = g + Math.imul(Y, oe) | 0, _ = _ + Math.imul(Y, se) | 0, w = w + Math.imul(V, he) | 0, g = g + Math.imul(V, ue) | 0, g = g + Math.imul($, he) | 0, _ = _ + Math.imul($, ue) | 0, w = w + Math.imul(j, le) | 0, g = g + Math.imul(j, de) | 0, g = g + Math.imul(Z, le) | 0, _ = _ + Math.imul(Z, de) | 0, w = w + Math.imul(W, ce) | 0, g = g + Math.imul(W, pe) | 0, g = g + Math.imul(K, ce) | 0, _ = _ + Math.imul(K, pe) | 0, w = w + Math.imul(z, ve) | 0, g = g + Math.imul(z, be) | 0, g = g + Math.imul(H, ve) | 0, _ = _ + Math.imul(H, be) | 0, w = w + Math.imul(F, Be) | 0, g = g + Math.imul(F, qe) | 0, g = g + Math.imul(U, Be) | 0, _ = _ + Math.imul(U, qe) | 0;
        var Qe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(X, oe), g = Math.imul(X, se), g = g + Math.imul(J, oe) | 0, _ = Math.imul(J, se), w = w + Math.imul(G, he) | 0, g = g + Math.imul(G, ue) | 0, g = g + Math.imul(Y, he) | 0, _ = _ + Math.imul(Y, ue) | 0, w = w + Math.imul(V, le) | 0, g = g + Math.imul(V, de) | 0, g = g + Math.imul($, le) | 0, _ = _ + Math.imul($, de) | 0, w = w + Math.imul(j, ce) | 0, g = g + Math.imul(j, pe) | 0, g = g + Math.imul(Z, ce) | 0, _ = _ + Math.imul(Z, pe) | 0, w = w + Math.imul(W, ve) | 0, g = g + Math.imul(W, be) | 0, g = g + Math.imul(K, ve) | 0, _ = _ + Math.imul(K, be) | 0, w = w + Math.imul(z, Be) | 0, g = g + Math.imul(z, qe) | 0, g = g + Math.imul(H, Be) | 0, _ = _ + Math.imul(H, qe) | 0;
        var et = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(X, he), g = Math.imul(X, ue), g = g + Math.imul(J, he) | 0, _ = Math.imul(J, ue), w = w + Math.imul(G, le) | 0, g = g + Math.imul(G, de) | 0, g = g + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, de) | 0, w = w + Math.imul(V, ce) | 0, g = g + Math.imul(V, pe) | 0, g = g + Math.imul($, ce) | 0, _ = _ + Math.imul($, pe) | 0, w = w + Math.imul(j, ve) | 0, g = g + Math.imul(j, be) | 0, g = g + Math.imul(Z, ve) | 0, _ = _ + Math.imul(Z, be) | 0, w = w + Math.imul(W, Be) | 0, g = g + Math.imul(W, qe) | 0, g = g + Math.imul(K, Be) | 0, _ = _ + Math.imul(K, qe) | 0;
        var tt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, w = Math.imul(X, le), g = Math.imul(X, de), g = g + Math.imul(J, le) | 0, _ = Math.imul(J, de), w = w + Math.imul(G, ce) | 0, g = g + Math.imul(G, pe) | 0, g = g + Math.imul(Y, ce) | 0, _ = _ + Math.imul(Y, pe) | 0, w = w + Math.imul(V, ve) | 0, g = g + Math.imul(V, be) | 0, g = g + Math.imul($, ve) | 0, _ = _ + Math.imul($, be) | 0, w = w + Math.imul(j, Be) | 0, g = g + Math.imul(j, qe) | 0, g = g + Math.imul(Z, Be) | 0, _ = _ + Math.imul(Z, qe) | 0;
        var rt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, w = Math.imul(X, ce), g = Math.imul(X, pe), g = g + Math.imul(J, ce) | 0, _ = Math.imul(J, pe), w = w + Math.imul(G, ve) | 0, g = g + Math.imul(G, be) | 0, g = g + Math.imul(Y, ve) | 0, _ = _ + Math.imul(Y, be) | 0, w = w + Math.imul(V, Be) | 0, g = g + Math.imul(V, qe) | 0, g = g + Math.imul($, Be) | 0, _ = _ + Math.imul($, qe) | 0;
        var S0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w = Math.imul(X, ve), g = Math.imul(X, be), g = g + Math.imul(J, ve) | 0, _ = Math.imul(J, be), w = w + Math.imul(G, Be) | 0, g = g + Math.imul(G, qe) | 0, g = g + Math.imul(Y, Be) | 0, _ = _ + Math.imul(Y, qe) | 0;
        var E0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w = Math.imul(X, Be), g = Math.imul(X, qe), g = g + Math.imul(J, Be) | 0, _ = Math.imul(J, qe);
        var A0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        return d = (_ + (g >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He, n[2] = We, n[3] = Ke, n[4] = je, n[5] = Ze, n[6] = Ve, n[7] = $e, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe, n[13] = et, n[14] = tt, n[15] = rt, n[16] = S0, n[17] = E0, n[18] = A0, d !== 0 && (n[19] = d, c.length++), c;
      };
      Math.imul || (N = _e);
      function we(h, s, u) {
        u.negative = s.negative ^ h.negative, u.length = h.length + s.length;
        for (var c = 0, b = 0, l = 0;l < u.length - 1; l++) {
          var n = b;
          b = 0;
          for (var d = c & 67108863, w = Math.min(l, s.length - 1), g = Math.max(0, l - h.length + 1);g <= w; g++) {
            var _ = l - g, A = h.words[_] | 0, R = s.words[g] | 0, I = A * R, Me = I & 67108863;
            n = n + (I / 67108864 | 0) | 0, Me = Me + d | 0, d = Me & 67108863, n = n + (Me >>> 26) | 0, b += n >>> 26, n &= 67108863;
          }
          u.words[l] = d, c = n, n = b;
        }
        return c !== 0 ? u.words[l] = c : u.length--, u._strip();
      }
      function ye(h, s, u) {
        return we(h, s, u);
      }
      f.prototype.mulTo = function(s, u) {
        var c, b = this.length + s.length;
        return this.length === 10 && s.length === 10 ? c = N(this, s, u) : b < 63 ? c = _e(this, s, u) : b < 1024 ? c = we(this, s, u) : c = ye(this, s, u), c;
      };
      function xe(h, s) {
        this.x = h, this.y = s;
      }
      xe.prototype.makeRBT = function(s) {
        for (var u = new Array(s), c = f.prototype._countBits(s) - 1, b = 0;b < s; b++)
          u[b] = this.revBin(b, c, s);
        return u;
      }, xe.prototype.revBin = function(s, u, c) {
        if (s === 0 || s === c - 1)
          return s;
        for (var b = 0, l = 0;l < u; l++)
          b |= (s & 1) << u - l - 1, s >>= 1;
        return b;
      }, xe.prototype.permute = function(s, u, c, b, l, n) {
        for (var d = 0;d < n; d++)
          b[d] = u[s[d]], l[d] = c[s[d]];
      }, xe.prototype.transform = function(s, u, c, b, l, n) {
        this.permute(n, s, u, c, b, l);
        for (var d = 1;d < l; d <<= 1)
          for (var w = d << 1, g = Math.cos(2 * Math.PI / w), _ = Math.sin(2 * Math.PI / w), A = 0;A < l; A += w)
            for (var R = g, I = _, Me = 0;Me < d; Me++) {
              var k = c[A + Me], D = b[A + Me], nt = c[A + Me + d], C = b[A + Me + d], O = R * nt - I * C;
              C = R * C + I * nt, nt = O, c[A + Me] = k + nt, b[A + Me] = D + C, c[A + Me + d] = k - nt, b[A + Me + d] = D - C, Me !== w && (O = g * R - _ * I, I = g * I + _ * R, R = O);
            }
      }, xe.prototype.guessLen13b = function(s, u) {
        var c = Math.max(u, s) | 1, b = c & 1, l = 0;
        for (c = c / 2 | 0;c; c = c >>> 1)
          l++;
        return 1 << l + 1 + b;
      }, xe.prototype.conjugate = function(s, u, c) {
        if (!(c <= 1))
          for (var b = 0;b < c / 2; b++) {
            var l = s[b];
            s[b] = s[c - b - 1], s[c - b - 1] = l, l = u[b], u[b] = -u[c - b - 1], u[c - b - 1] = -l;
          }
      }, xe.prototype.normalize13b = function(s, u) {
        for (var c = 0, b = 0;b < u / 2; b++) {
          var l = Math.round(s[2 * b + 1] / u) * 8192 + Math.round(s[2 * b] / u) + c;
          s[b] = l & 67108863, l < 67108864 ? c = 0 : c = l / 67108864 | 0;
        }
        return s;
      }, xe.prototype.convert13b = function(s, u, c, b) {
        for (var l = 0, n = 0;n < u; n++)
          l = l + (s[n] | 0), c[2 * n] = l & 8191, l = l >>> 13, c[2 * n + 1] = l & 8191, l = l >>> 13;
        for (n = 2 * u;n < b; ++n)
          c[n] = 0;
        r(l === 0), r((l & -8192) === 0);
      }, xe.prototype.stub = function(s) {
        for (var u = new Array(s), c = 0;c < s; c++)
          u[c] = 0;
        return u;
      }, xe.prototype.mulp = function(s, u, c) {
        var b = 2 * this.guessLen13b(s.length, u.length), l = this.makeRBT(b), n = this.stub(b), d = new Array(b), w = new Array(b), g = new Array(b), _ = new Array(b), A = new Array(b), R = new Array(b), I = c.words;
        I.length = b, this.convert13b(s.words, s.length, d, b), this.convert13b(u.words, u.length, _, b), this.transform(d, n, w, g, b, l), this.transform(_, n, A, R, b, l);
        for (var Me = 0;Me < b; Me++) {
          var k = w[Me] * A[Me] - g[Me] * R[Me];
          g[Me] = w[Me] * R[Me] + g[Me] * A[Me], w[Me] = k;
        }
        return this.conjugate(w, g, b), this.transform(w, g, I, n, b, l), this.conjugate(I, n, b), this.normalize13b(I, b), c.negative = s.negative ^ u.negative, c.length = s.length + u.length, c._strip();
      }, f.prototype.mul = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), this.mulTo(s, u);
      }, f.prototype.mulf = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), ye(this, s, u);
      }, f.prototype.imul = function(s) {
        return this.clone().mulTo(s, this);
      }, f.prototype.imuln = function(s) {
        var u = s < 0;
        u && (s = -s), r(typeof s == "number"), r(s < 67108864);
        for (var c = 0, b = 0;b < this.length; b++) {
          var l = (this.words[b] | 0) * s, n = (l & 67108863) + (c & 67108863);
          c >>= 26, c += l / 67108864 | 0, c += n >>> 26, this.words[b] = n & 67108863;
        }
        return c !== 0 && (this.words[b] = c, this.length++), u ? this.ineg() : this;
      }, f.prototype.muln = function(s) {
        return this.clone().imuln(s);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(s) {
        var u = ge(s);
        if (u.length === 0)
          return new f(1);
        for (var c = this, b = 0;b < u.length && u[b] === 0; b++, c = c.sqr())
          ;
        if (++b < u.length)
          for (var l = c.sqr();b < u.length; b++, l = l.sqr())
            u[b] !== 0 && (c = c.mul(l));
        return c;
      }, f.prototype.iushln = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b = 67108863 >>> 26 - u << 26 - u, l;
        if (u !== 0) {
          var n = 0;
          for (l = 0;l < this.length; l++) {
            var d = this.words[l] & b, w = (this.words[l] | 0) - d << u;
            this.words[l] = w | n, n = d >>> 26 - u;
          }
          n && (this.words[l] = n, this.length++);
        }
        if (c !== 0) {
          for (l = this.length - 1;l >= 0; l--)
            this.words[l + c] = this.words[l];
          for (l = 0;l < c; l++)
            this.words[l] = 0;
          this.length += c;
        }
        return this._strip();
      }, f.prototype.ishln = function(s) {
        return r(this.negative === 0), this.iushln(s);
      }, f.prototype.iushrn = function(s, u, c) {
        r(typeof s == "number" && s >= 0);
        var b;
        u ? b = (u - u % 26) / 26 : b = 0;
        var l = s % 26, n = Math.min((s - l) / 26, this.length), d = 67108863 ^ 67108863 >>> l << l, w = c;
        if (b -= n, b = Math.max(0, b), w) {
          for (var g = 0;g < n; g++)
            w.words[g] = this.words[g];
          w.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g = 0;g < this.length; g++)
              this.words[g] = this.words[g + n];
          else
            this.words[0] = 0, this.length = 1;
        var _ = 0;
        for (g = this.length - 1;g >= 0 && (_ !== 0 || g >= b); g--) {
          var A = this.words[g] | 0;
          this.words[g] = _ << 26 - l | A >>> l, _ = A & d;
        }
        return w && _ !== 0 && (w.words[w.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f.prototype.ishrn = function(s, u, c) {
        return r(this.negative === 0), this.iushrn(s, u, c);
      }, f.prototype.shln = function(s) {
        return this.clone().ishln(s);
      }, f.prototype.ushln = function(s) {
        return this.clone().iushln(s);
      }, f.prototype.shrn = function(s) {
        return this.clone().ishrn(s);
      }, f.prototype.ushrn = function(s) {
        return this.clone().iushrn(s);
      }, f.prototype.testn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b = 1 << u;
        if (this.length <= c)
          return false;
        var l = this.words[c];
        return !!(l & b);
      }, f.prototype.imaskn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
          return this;
        if (u !== 0 && c++, this.length = Math.min(c, this.length), u !== 0) {
          var b = 67108863 ^ 67108863 >>> u << u;
          this.words[this.length - 1] &= b;
        }
        return this._strip();
      }, f.prototype.maskn = function(s) {
        return this.clone().imaskn(s);
      }, f.prototype.iaddn = function(s) {
        return r(typeof s == "number"), r(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);
      }, f.prototype._iaddn = function(s) {
        this.words[0] += s;
        for (var u = 0;u < this.length && this.words[u] >= 67108864; u++)
          this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
        return this.length = Math.max(this.length, u + 1), this;
      }, f.prototype.isubn = function(s) {
        if (r(typeof s == "number"), r(s < 67108864), s < 0)
          return this.iaddn(-s);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s), this.negative = 1, this;
        if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u = 0;u < this.length && this.words[u] < 0; u++)
            this.words[u] += 67108864, this.words[u + 1] -= 1;
        return this._strip();
      }, f.prototype.addn = function(s) {
        return this.clone().iaddn(s);
      }, f.prototype.subn = function(s) {
        return this.clone().isubn(s);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(s, u, c) {
        var b = s.length + c, l;
        this._expand(b);
        var n, d = 0;
        for (l = 0;l < s.length; l++) {
          n = (this.words[l + c] | 0) + d;
          var w = (s.words[l] | 0) * u;
          n -= w & 67108863, d = (n >> 26) - (w / 67108864 | 0), this.words[l + c] = n & 67108863;
        }
        for (;l < this.length - c; l++)
          n = (this.words[l + c] | 0) + d, d = n >> 26, this.words[l + c] = n & 67108863;
        if (d === 0)
          return this._strip();
        for (r(d === -1), d = 0, l = 0;l < this.length; l++)
          n = -(this.words[l] | 0) + d, d = n >> 26, this.words[l] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f.prototype._wordDiv = function(s, u) {
        var c = this.length - s.length, b = this.clone(), l = s, n = l.words[l.length - 1] | 0, d = this._countBits(n);
        c = 26 - d, c !== 0 && (l = l.ushln(c), b.iushln(c), n = l.words[l.length - 1] | 0);
        var w = b.length - l.length, g;
        if (u !== "mod") {
          g = new f(null), g.length = w + 1, g.words = new Array(g.length);
          for (var _ = 0;_ < g.length; _++)
            g.words[_] = 0;
        }
        var A = b.clone()._ishlnsubmul(l, 1, w);
        A.negative === 0 && (b = A, g && (g.words[w] = 1));
        for (var R = w - 1;R >= 0; R--) {
          var I = (b.words[l.length + R] | 0) * 67108864 + (b.words[l.length + R - 1] | 0);
          for (I = Math.min(I / n | 0, 67108863), b._ishlnsubmul(l, I, R);b.negative !== 0; )
            I--, b.negative = 0, b._ishlnsubmul(l, 1, R), b.isZero() || (b.negative ^= 1);
          g && (g.words[R] = I);
        }
        return g && g._strip(), b._strip(), u !== "div" && c !== 0 && b.iushrn(c), { div: g || null, mod: b };
      }, f.prototype.divmod = function(s, u, c) {
        if (r(!s.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var b, l, n;
        return this.negative !== 0 && s.negative === 0 ? (n = this.neg().divmod(s, u), u !== "mod" && (b = n.div.neg()), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.iadd(s)), { div: b, mod: l }) : this.negative === 0 && s.negative !== 0 ? (n = this.divmod(s.neg(), u), u !== "mod" && (b = n.div.neg()), { div: b, mod: n.mod }) : (this.negative & s.negative) !== 0 ? (n = this.neg().divmod(s.neg(), u), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.isub(s)), { div: n.div, mod: l }) : s.length > this.length || this.cmp(s) < 0 ? { div: new f(0), mod: this } : s.length === 1 ? u === "div" ? { div: this.divn(s.words[0]), mod: null } : u === "mod" ? { div: null, mod: new f(this.modrn(s.words[0])) } : { div: this.divn(s.words[0]), mod: new f(this.modrn(s.words[0])) } : this._wordDiv(s, u);
      }, f.prototype.div = function(s) {
        return this.divmod(s, "div", false).div;
      }, f.prototype.mod = function(s) {
        return this.divmod(s, "mod", false).mod;
      }, f.prototype.umod = function(s) {
        return this.divmod(s, "mod", true).mod;
      }, f.prototype.divRound = function(s) {
        var u = this.divmod(s);
        if (u.mod.isZero())
          return u.div;
        var c = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, b = s.ushrn(1), l = s.andln(1), n = c.cmp(b);
        return n < 0 || l === 1 && n === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
      }, f.prototype.modrn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = (1 << 26) % s, b = 0, l = this.length - 1;l >= 0; l--)
          b = (c * b + (this.words[l] | 0)) % s;
        return u ? -b : b;
      }, f.prototype.modn = function(s) {
        return this.modrn(s);
      }, f.prototype.idivn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = 0, b = this.length - 1;b >= 0; b--) {
          var l = (this.words[b] | 0) + c * 67108864;
          this.words[b] = l / s | 0, c = l % s;
        }
        return this._strip(), u ? this.ineg() : this;
      }, f.prototype.divn = function(s) {
        return this.clone().idivn(s);
      }, f.prototype.egcd = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b = new f(1), l = new f(0), n = new f(0), d = new f(1), w = 0;u.isEven() && c.isEven(); )
          u.iushrn(1), c.iushrn(1), ++w;
        for (var g = c.clone(), _ = u.clone();!u.isZero(); ) {
          for (var A = 0, R = 1;(u.words[0] & R) === 0 && A < 26; ++A, R <<= 1)
            ;
          if (A > 0)
            for (u.iushrn(A);A-- > 0; )
              (b.isOdd() || l.isOdd()) && (b.iadd(g), l.isub(_)), b.iushrn(1), l.iushrn(1);
          for (var I = 0, Me = 1;(c.words[0] & Me) === 0 && I < 26; ++I, Me <<= 1)
            ;
          if (I > 0)
            for (c.iushrn(I);I-- > 0; )
              (n.isOdd() || d.isOdd()) && (n.iadd(g), d.isub(_)), n.iushrn(1), d.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b.isub(n), l.isub(d)) : (c.isub(u), n.isub(b), d.isub(l));
        }
        return { a: n, b: d, gcd: c.iushln(w) };
      }, f.prototype._invmp = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b = new f(1), l = new f(0), n = c.clone();u.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
          for (var d = 0, w = 1;(u.words[0] & w) === 0 && d < 26; ++d, w <<= 1)
            ;
          if (d > 0)
            for (u.iushrn(d);d-- > 0; )
              b.isOdd() && b.iadd(n), b.iushrn(1);
          for (var g = 0, _ = 1;(c.words[0] & _) === 0 && g < 26; ++g, _ <<= 1)
            ;
          if (g > 0)
            for (c.iushrn(g);g-- > 0; )
              l.isOdd() && l.iadd(n), l.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b.isub(l)) : (c.isub(u), l.isub(b));
        }
        var A;
        return u.cmpn(1) === 0 ? A = b : A = l, A.cmpn(0) < 0 && A.iadd(s), A;
      }, f.prototype.gcd = function(s) {
        if (this.isZero())
          return s.abs();
        if (s.isZero())
          return this.abs();
        var u = this.clone(), c = s.clone();
        u.negative = 0, c.negative = 0;
        for (var b = 0;u.isEven() && c.isEven(); b++)
          u.iushrn(1), c.iushrn(1);
        do {
          for (;u.isEven(); )
            u.iushrn(1);
          for (;c.isEven(); )
            c.iushrn(1);
          var l = u.cmp(c);
          if (l < 0) {
            var n = u;
            u = c, c = n;
          } else if (l === 0 || c.cmpn(1) === 0)
            break;
          u.isub(c);
        } while (true);
        return c.iushln(b);
      }, f.prototype.invm = function(s) {
        return this.egcd(s).a.umod(s);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(s) {
        return this.words[0] & s;
      }, f.prototype.bincn = function(s) {
        r(typeof s == "number");
        var u = s % 26, c = (s - u) / 26, b = 1 << u;
        if (this.length <= c)
          return this._expand(c + 1), this.words[c] |= b, this;
        for (var l = b, n = c;l !== 0 && n < this.length; n++) {
          var d = this.words[n] | 0;
          d += l, l = d >>> 26, d &= 67108863, this.words[n] = d;
        }
        return l !== 0 && (this.words[n] = l, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(s) {
        var u = s < 0;
        if (this.negative !== 0 && !u)
          return -1;
        if (this.negative === 0 && u)
          return 1;
        this._strip();
        var c;
        if (this.length > 1)
          c = 1;
        else {
          u && (s = -s), r(s <= 67108863, "Number is too big");
          var b = this.words[0] | 0;
          c = b === s ? 0 : b < s ? -1 : 1;
        }
        return this.negative !== 0 ? -c | 0 : c;
      }, f.prototype.cmp = function(s) {
        if (this.negative !== 0 && s.negative === 0)
          return -1;
        if (this.negative === 0 && s.negative !== 0)
          return 1;
        var u = this.ucmp(s);
        return this.negative !== 0 ? -u | 0 : u;
      }, f.prototype.ucmp = function(s) {
        if (this.length > s.length)
          return 1;
        if (this.length < s.length)
          return -1;
        for (var u = 0, c = this.length - 1;c >= 0; c--) {
          var b = this.words[c] | 0, l = s.words[c] | 0;
          if (b !== l) {
            b < l ? u = -1 : b > l && (u = 1);
            break;
          }
        }
        return u;
      }, f.prototype.gtn = function(s) {
        return this.cmpn(s) === 1;
      }, f.prototype.gt = function(s) {
        return this.cmp(s) === 1;
      }, f.prototype.gten = function(s) {
        return this.cmpn(s) >= 0;
      }, f.prototype.gte = function(s) {
        return this.cmp(s) >= 0;
      }, f.prototype.ltn = function(s) {
        return this.cmpn(s) === -1;
      }, f.prototype.lt = function(s) {
        return this.cmp(s) === -1;
      }, f.prototype.lten = function(s) {
        return this.cmpn(s) <= 0;
      }, f.prototype.lte = function(s) {
        return this.cmp(s) <= 0;
      }, f.prototype.eqn = function(s) {
        return this.cmpn(s) === 0;
      }, f.prototype.eq = function(s) {
        return this.cmp(s) === 0;
      }, f.red = function(s) {
        return new i(s);
      }, f.prototype.toRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(s) {
        return this.red = s, this;
      }, f.prototype.forceRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s);
      }, f.prototype.redAdd = function(s) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s);
      }, f.prototype.redIAdd = function(s) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s);
      }, f.prototype.redSub = function(s) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s);
      }, f.prototype.redISub = function(s) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s);
      }, f.prototype.redShl = function(s) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s);
      }, f.prototype.redMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s);
      }, f.prototype.redIMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(s) {
        return r(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s);
      };
      var Re = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h, s) {
        this.name = h, this.p = new f(s, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s = new f(null);
        return s.words = new Array(Math.ceil(this.n / 13)), s;
      }, Ee.prototype.ireduce = function(s) {
        var u = s, c;
        do
          this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), c = u.bitLength();
        while (c > this.n);
        var b = c < this.n ? -1 : u.ucmp(this.p);
        return b === 0 ? (u.words[0] = 0, u.length = 1) : b > 0 ? u.isub(this.p) : u.strip !== undefined ? u.strip() : u._strip(), u;
      }, Ee.prototype.split = function(s, u) {
        s.iushrn(this.n, 0, u);
      }, Ee.prototype.imulK = function(s) {
        return s.imul(this.k);
      };
      function Ae() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(Ae, Ee), Ae.prototype.split = function(s, u) {
        for (var c = 4194303, b = Math.min(s.length, 9), l = 0;l < b; l++)
          u.words[l] = s.words[l];
        if (u.length = b, s.length <= 9) {
          s.words[0] = 0, s.length = 1;
          return;
        }
        var n = s.words[9];
        for (u.words[u.length++] = n & c, l = 10;l < s.length; l++) {
          var d = s.words[l] | 0;
          s.words[l - 10] = (d & c) << 4 | n >>> 22, n = d;
        }
        n >>>= 22, s.words[l - 10] = n, n === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;
      }, Ae.prototype.imulK = function(s) {
        s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
        for (var u = 0, c = 0;c < s.length; c++) {
          var b = s.words[c] | 0;
          u += b * 977, s.words[c] = u & 67108863, u = b * 64 + (u / 67108864 | 0);
        }
        return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;
      };
      function P5() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(P5, Ee);
      function Se() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Se, Ee);
      function v() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(v, Ee), v.prototype.imulK = function(s) {
        for (var u = 0, c = 0;c < s.length; c++) {
          var b = (s.words[c] | 0) * 19 + u, l = b & 67108863;
          b >>>= 26, s.words[c] = l, u = b;
        }
        return u !== 0 && (s.words[s.length++] = u), s;
      }, f._prime = function(s) {
        if (Re[s])
          return Re[s];
        var u;
        if (s === "k256")
          u = new Ae;
        else if (s === "p224")
          u = new P5;
        else if (s === "p192")
          u = new Se;
        else if (s === "p25519")
          u = new v;
        else
          throw new Error("Unknown prime " + s);
        return Re[s] = u, u;
      };
      function i(h) {
        if (typeof h == "string") {
          var s = f._prime(h);
          this.m = s.p, this.prime = s;
        } else
          r(h.gtn(1), "modulus must be greater than 1"), this.m = h, this.prime = null;
      }
      i.prototype._verify1 = function(s) {
        r(s.negative === 0, "red works only with positives"), r(s.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s, u) {
        r((s.negative | u.negative) === 0, "red works only with positives"), r(s.red && s.red === u.red, "red works only with red numbers");
      }, i.prototype.imod = function(s) {
        return this.prime ? this.prime.ireduce(s)._forceRed(this) : (x(s, s.umod(this.m)._forceRed(this)), s);
      }, i.prototype.neg = function(s) {
        return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);
      }, i.prototype.add = function(s, u) {
        this._verify2(s, u);
        var c = s.add(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
      }, i.prototype.iadd = function(s, u) {
        this._verify2(s, u);
        var c = s.iadd(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c;
      }, i.prototype.sub = function(s, u) {
        this._verify2(s, u);
        var c = s.sub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
      }, i.prototype.isub = function(s, u) {
        this._verify2(s, u);
        var c = s.isub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c;
      }, i.prototype.shl = function(s, u) {
        return this._verify1(s), this.imod(s.ushln(u));
      }, i.prototype.imul = function(s, u) {
        return this._verify2(s, u), this.imod(s.imul(u));
      }, i.prototype.mul = function(s, u) {
        return this._verify2(s, u), this.imod(s.mul(u));
      }, i.prototype.isqr = function(s) {
        return this.imul(s, s.clone());
      }, i.prototype.sqr = function(s) {
        return this.mul(s, s);
      }, i.prototype.sqrt = function(s) {
        if (s.isZero())
          return s.clone();
        var u = this.m.andln(3);
        if (r(u % 2 === 1), u === 3) {
          var c = this.m.add(new f(1)).iushrn(2);
          return this.pow(s, c);
        }
        for (var b = this.m.subn(1), l = 0;!b.isZero() && b.andln(1) === 0; )
          l++, b.iushrn(1);
        r(!b.isZero());
        var n = new f(1).toRed(this), d = n.redNeg(), w = this.m.subn(1).iushrn(1), g = this.m.bitLength();
        for (g = new f(2 * g * g).toRed(this);this.pow(g, w).cmp(d) !== 0; )
          g.redIAdd(d);
        for (var _ = this.pow(g, b), A = this.pow(s, b.addn(1).iushrn(1)), R = this.pow(s, b), I = l;R.cmp(n) !== 0; ) {
          for (var Me = R, k = 0;Me.cmp(n) !== 0; k++)
            Me = Me.redSqr();
          r(k < I);
          var D = this.pow(_, new f(1).iushln(I - k - 1));
          A = A.redMul(D), _ = D.redSqr(), R = R.redMul(_), I = k;
        }
        return A;
      }, i.prototype.invm = function(s) {
        var u = s._invmp(this.m);
        return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
      }, i.prototype.pow = function(s, u) {
        if (u.isZero())
          return new f(1).toRed(this);
        if (u.cmpn(1) === 0)
          return s.clone();
        var c = 4, b = new Array(1 << c);
        b[0] = new f(1).toRed(this), b[1] = s;
        for (var l = 2;l < b.length; l++)
          b[l] = this.mul(b[l - 1], s);
        var n = b[0], d = 0, w = 0, g = u.bitLength() % 26;
        for (g === 0 && (g = 26), l = u.length - 1;l >= 0; l--) {
          for (var _ = u.words[l], A = g - 1;A >= 0; A--) {
            var R = _ >> A & 1;
            if (n !== b[0] && (n = this.sqr(n)), R === 0 && d === 0) {
              w = 0;
              continue;
            }
            d <<= 1, d |= R, w++, !(w !== c && (l !== 0 || A !== 0)) && (n = this.mul(n, b[d]), w = 0, d = 0);
          }
          g = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s) {
        var u = s.umod(this.m);
        return u === s ? u.clone() : u;
      }, i.prototype.convertFrom = function(s) {
        var u = s.clone();
        return u.red = null, u;
      }, f.mont = function(s) {
        return new a(s);
      };
      function a(h) {
        i.call(this, h), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(a, i), a.prototype.convertTo = function(s) {
        return this.imod(s.ushln(this.shift));
      }, a.prototype.convertFrom = function(s) {
        var u = this.imod(s.mul(this.rinv));
        return u.red = null, u;
      }, a.prototype.imul = function(s, u) {
        if (s.isZero() || u.isZero())
          return s.words[0] = 0, s.length = 1, s;
        var c = s.imul(u), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.mul = function(s, u) {
        if (s.isZero() || u.isZero())
          return new f(0)._forceRed(this);
        var c = s.mul(u), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.invm = function(s) {
        var u = this.imod(s._invmp(this.m).mul(this.r2));
        return u._forceRed(this);
      };
    })(typeof kl > "u" || kl, n25);
  });
  Ks = T((yk, o2) => {
    var Rf = Ws(), oA = on();
    function sA(t) {
      var e2 = f2(t), r = e2.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e2.invm(t.modulus) };
    }
    function f2(t) {
      var e2 = t.modulus.byteLength(), r;
      do
        r = new Rf(oA(e2));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function a2(t, e2) {
      var r = sA(e2), o = e2.modulus.byteLength(), f = new Rf(t).mul(r.blinder).umod(e2.modulus), p = f.toRed(Rf.mont(e2.prime1)), m = f.toRed(Rf.mont(e2.prime2)), y = e2.coefficient, M = e2.prime1, x = e2.prime2, S = p.redPow(e2.exponent1).fromRed(), E = m.redPow(e2.exponent2).fromRed(), B = S.isub(E).imul(y).umod(M).imul(x);
      return E.iadd(B).imul(r.unblinder).umod(e2.modulus).toArrayLike(Buffer, "be", o);
    }
    a2.getr = f2;
    o2.exports = a2;
  });
  s2 = T((wk, hA) => {
    hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  ri = T((h2, Ll) => {
    (function(t, e2) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e2.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q2) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q2) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q2) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q2) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q2) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q2) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P5(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P5(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P5.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P5.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P5.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P5.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P5.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P5.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P5.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P5.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P5.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P5.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P5.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P5.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P5.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P5.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P5.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P5.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P5.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P5.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P5.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P5), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Ll > "u" || Ll, h2);
  });
  Nl = T((d2) => {
    var js = d2;
    function uA(t, e2) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o = 0;o < t.length; o++)
          r[o] = t[o] | 0;
        return r;
      }
      if (e2 === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o = 0;o < t.length; o += 2)
          r.push(parseInt(t[o] + t[o + 1], 16));
      } else
        for (var o = 0;o < t.length; o++) {
          var f = t.charCodeAt(o), p = f >> 8, m = f & 255;
          p ? r.push(p, m) : r.push(m);
        }
      return r;
    }
    js.toArray = uA;
    function u2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    js.zero2 = u2;
    function l2(t) {
      for (var e2 = "", r = 0;r < t.length; r++)
        e2 += u2(t[r].toString(16));
      return e2;
    }
    js.toHex = l2;
    js.encode = function(e2, r) {
      return r === "hex" ? l2(e2) : e2;
    };
  });
  or = T((c2) => {
    var Pr = c2, lA = ri(), dA = ar(), Zs = Nl();
    Pr.assert = dA;
    Pr.toArray = Zs.toArray;
    Pr.zero2 = Zs.zero2;
    Pr.toHex = Zs.toHex;
    Pr.encode = Zs.encode;
    function cA(t, e2, r) {
      var o = new Array(Math.max(t.bitLength(), r) + 1);
      o.fill(0);
      for (var f = 1 << e2 + 1, p = t.clone(), m = 0;m < o.length; m++) {
        var y, M = p.andln(f - 1);
        p.isOdd() ? (M > (f >> 1) - 1 ? y = (f >> 1) - M : y = M, p.isubn(y)) : y = 0, o[m] = y, p.iushrn(1);
      }
      return o;
    }
    Pr.getNAF = cA;
    function pA(t, e2) {
      var r = [[], []];
      t = t.clone(), e2 = e2.clone();
      for (var o = 0, f = 0, p;t.cmpn(-o) > 0 || e2.cmpn(-f) > 0; ) {
        var m = t.andln(3) + o & 3, y = e2.andln(3) + f & 3;
        m === 3 && (m = -1), y === 3 && (y = -1);
        var M;
        (m & 1) === 0 ? M = 0 : (p = t.andln(7) + o & 7, (p === 3 || p === 5) && y === 2 ? M = -m : M = m), r[0].push(M);
        var x;
        (y & 1) === 0 ? x = 0 : (p = e2.andln(7) + f & 7, (p === 3 || p === 5) && m === 2 ? x = -y : x = y), r[1].push(x), 2 * o === M + 1 && (o = 1 - o), 2 * f === x + 1 && (f = 1 - f), t.iushrn(1), e2.iushrn(1);
      }
      return r;
    }
    Pr.getJSF = pA;
    function vA(t, e2, r) {
      var o = "_" + e2;
      t.prototype[e2] = function() {
        return this[o] !== undefined ? this[o] : this[o] = r.call(this);
      };
    }
    Pr.cachedProperty = vA;
    function bA(t) {
      return typeof t == "string" ? Pr.toArray(t, "hex") : t;
    }
    Pr.parseBytes = bA;
    function mA(t) {
      return new lA(t, "hex", "le");
    }
    Pr.intFromLE = mA;
  });
  Oa = T((xk, p2) => {
    var Cn = ri(), Ca = or(), Vs = Ca.getNAF, gA = Ca.getJSF, $s = Ca.assert;
    function Xi(t, e2) {
      this.type = t, this.p = new Cn(e2.p, 16), this.red = e2.prime ? Cn.red(e2.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e2.n && new Cn(e2.n, 16), this.g = e2.g && this.pointFromJSON(e2.g, e2.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    p2.exports = Xi;
    Xi.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype._fixedNafMul = function(e2, r) {
      $s(e2.precomputed);
      var o = e2._getDoubles(), f = Vs(r, 1, this._bitLength), p = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
      p /= 3;
      var m = [], y, M;
      for (y = 0;y < f.length; y += o.step) {
        M = 0;
        for (var x = y + o.step - 1;x >= y; x--)
          M = (M << 1) + f[x];
        m.push(M);
      }
      for (var S = this.jpoint(null, null, null), E = this.jpoint(null, null, null), B = p;B > 0; B--) {
        for (y = 0;y < m.length; y++)
          M = m[y], M === B ? E = E.mixedAdd(o.points[y]) : M === -B && (E = E.mixedAdd(o.points[y].neg()));
        S = S.add(E);
      }
      return S.toP();
    };
    Xi.prototype._wnafMul = function(e2, r) {
      var o = 4, f = e2._getNAFPoints(o);
      o = f.wnd;
      for (var p = f.points, m = Vs(r, o, this._bitLength), y = this.jpoint(null, null, null), M = m.length - 1;M >= 0; M--) {
        for (var x = 0;M >= 0 && m[M] === 0; M--)
          x++;
        if (M >= 0 && x++, y = y.dblp(x), M < 0)
          break;
        var S = m[M];
        $s(S !== 0), e2.type === "affine" ? S > 0 ? y = y.mixedAdd(p[S - 1 >> 1]) : y = y.mixedAdd(p[-S - 1 >> 1].neg()) : S > 0 ? y = y.add(p[S - 1 >> 1]) : y = y.add(p[-S - 1 >> 1].neg());
      }
      return e2.type === "affine" ? y.toP() : y;
    };
    Xi.prototype._wnafMulAdd = function(e2, r, o, f, p) {
      var m = this._wnafT1, y = this._wnafT2, M = this._wnafT3, x = 0, S, E, B;
      for (S = 0;S < f; S++) {
        B = r[S];
        var q = B._getNAFPoints(e2);
        m[S] = q.wnd, y[S] = q.points;
      }
      for (S = f - 1;S >= 1; S -= 2) {
        var L = S - 1, ge = S;
        if (m[L] !== 1 || m[ge] !== 1) {
          M[L] = Vs(o[L], m[L], this._bitLength), M[ge] = Vs(o[ge], m[ge], this._bitLength), x = Math.max(M[L].length, x), x = Math.max(M[ge].length, x);
          continue;
        }
        var _e = [r[L], null, null, r[ge]];
        r[L].y.cmp(r[ge].y) === 0 ? (_e[1] = r[L].add(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg())) : r[L].y.cmp(r[ge].y.redNeg()) === 0 ? (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].add(r[ge].neg())) : (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg()));
        var N = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o[L], o[ge]);
        for (x = Math.max(we[0].length, x), M[L] = new Array(x), M[ge] = new Array(x), E = 0;E < x; E++) {
          var ye = we[0][E] | 0, xe = we[1][E] | 0;
          M[L][E] = N[(ye + 1) * 3 + (xe + 1)], M[ge][E] = 0, y[L] = _e;
        }
      }
      var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S = x;S >= 0; S--) {
        for (var Ae = 0;S >= 0; ) {
          var P5 = true;
          for (E = 0;E < f; E++)
            Ee[E] = M[E][S] | 0, Ee[E] !== 0 && (P5 = false);
          if (!P5)
            break;
          Ae++, S--;
        }
        if (S >= 0 && Ae++, Re = Re.dblp(Ae), S < 0)
          break;
        for (E = 0;E < f; E++) {
          var Se = Ee[E];
          Se !== 0 && (Se > 0 ? B = y[E][Se - 1 >> 1] : Se < 0 && (B = y[E][-Se - 1 >> 1].neg()), B.type === "affine" ? Re = Re.mixedAdd(B) : Re = Re.add(B));
        }
      }
      for (S = 0;S < f; S++)
        y[S] = null;
      return p ? Re : Re.toP();
    };
    function _r(t, e2) {
      this.curve = t, this.type = e2, this.precomputed = null;
    }
    Xi.BasePoint = _r;
    _r.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    _r.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Xi.prototype.decodePoint = function(e2, r) {
      e2 = Ca.toArray(e2, r);
      var o = this.p.byteLength();
      if ((e2[0] === 4 || e2[0] === 6 || e2[0] === 7) && e2.length - 1 === 2 * o) {
        e2[0] === 6 ? $s(e2[e2.length - 1] % 2 === 0) : e2[0] === 7 && $s(e2[e2.length - 1] % 2 === 1);
        var f = this.point(e2.slice(1, 1 + o), e2.slice(1 + o, 1 + 2 * o));
        return f;
      } else if ((e2[0] === 2 || e2[0] === 3) && e2.length - 1 === o)
        return this.pointFromX(e2.slice(1, 1 + o), e2[0] === 3);
      throw new Error("Unknown point format");
    };
    _r.prototype.encodeCompressed = function(e2) {
      return this.encode(e2, true);
    };
    _r.prototype._encode = function(e2) {
      var r = this.curve.p.byteLength(), o = this.getX().toArray("be", r);
      return e2 ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", r));
    };
    _r.prototype.encode = function(e2, r) {
      return Ca.encode(this._encode(r), e2);
    };
    _r.prototype.precompute = function(e2) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e2), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    _r.prototype._hasDoubles = function(e2) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e2.bitLength() + 1) / r.step) : false;
    };
    _r.prototype._getDoubles = function(e2, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o = [this], f = this, p = 0;p < r; p += e2) {
        for (var m = 0;m < e2; m++)
          f = f.dbl();
        o.push(f);
      }
      return { step: e2, points: o };
    };
    _r.prototype._getNAFPoints = function(e2) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o = (1 << e2) - 1, f = o === 1 ? null : this.dbl(), p = 1;p < o; p++)
        r[p] = r[p - 1].add(f);
      return { wnd: e2, points: r };
    };
    _r.prototype._getBeta = function() {
      return null;
    };
    _r.prototype.dblp = function(e2) {
      for (var r = this, o = 0;o < e2; o++)
        r = r.dbl();
      return r;
    };
  });
  b2 = T((Sk, v2) => {
    var yA = or(), lt = ri(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
    function xr(t) {
      Bf.call(this, "short", t), this.a = new lt(t.a, 16).toRed(this.red), this.b = new lt(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Dl(xr, Bf);
    v2.exports = xr;
    xr.prototype._getEndomorphism = function(e2) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o;
        if (e2.beta)
          r = new lt(e2.beta, 16).toRed(this.red);
        else {
          var f = this._getEndoRoots(this.p);
          r = f[0].cmp(f[1]) < 0 ? f[0] : f[1], r = r.toRed(this.red);
        }
        if (e2.lambda)
          o = new lt(e2.lambda, 16);
        else {
          var p = this._getEndoRoots(this.n);
          this.g.mul(p[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o = p[0] : (o = p[1], wA(this.g.mul(o).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m;
        return e2.basis ? m = e2.basis.map(function(y) {
          return { a: new lt(y.a, 16), b: new lt(y.b, 16) };
        }) : m = this._getEndoBasis(o), { beta: r, lambda: o, basis: m };
      }
    };
    xr.prototype._getEndoRoots = function(e2) {
      var r = e2 === this.p ? this.red : lt.mont(e2), o = new lt(2).toRed(r).redInvm(), f = o.redNeg(), p = new lt(3).toRed(r).redNeg().redSqrt().redMul(o), m = f.redAdd(p).fromRed(), y = f.redSub(p).fromRed();
      return [m, y];
    };
    xr.prototype._getEndoBasis = function(e2) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e2, f = this.n.clone(), p = new lt(1), m = new lt(0), y = new lt(0), M = new lt(1), x, S, E, B, q, L, ge, _e = 0, N, we;o.cmpn(0) !== 0; ) {
        var ye = f.div(o);
        N = f.sub(ye.mul(o)), we = y.sub(ye.mul(p));
        var xe = M.sub(ye.mul(m));
        if (!E && N.cmp(r) < 0)
          x = ge.neg(), S = p, E = N.neg(), B = we;
        else if (E && ++_e === 2)
          break;
        ge = N, f = o, o = N, y = p, p = we, M = m, m = xe;
      }
      q = N.neg(), L = we;
      var Re = E.sqr().add(B.sqr()), Ee = q.sqr().add(L.sqr());
      return Ee.cmp(Re) >= 0 && (q = x, L = S), E.negative && (E = E.neg(), B = B.neg()), q.negative && (q = q.neg(), L = L.neg()), [{ a: E, b: B }, { a: q, b: L }];
    };
    xr.prototype._endoSplit = function(e2) {
      var r = this.endo.basis, o = r[0], f = r[1], p = f.b.mul(e2).divRound(this.n), m = o.b.neg().mul(e2).divRound(this.n), y = p.mul(o.a), M = m.mul(f.a), x = p.mul(o.b), S = m.mul(f.b), E = e2.sub(y).sub(M), B = x.add(S).neg();
      return { k1: E, k2: B };
    };
    xr.prototype.pointFromX = function(e2, r) {
      e2 = new lt(e2, 16), e2.red || (e2 = e2.toRed(this.red));
      var o = e2.redSqr().redMul(e2).redIAdd(e2.redMul(this.a)).redIAdd(this.b), f = o.redSqrt();
      if (f.redSqr().redSub(o).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p = f.fromRed().isOdd();
      return (r && !p || !r && p) && (f = f.redNeg()), this.point(e2, f);
    };
    xr.prototype.validate = function(e2) {
      if (e2.inf)
        return true;
      var { x: r, y: o } = e2, f = this.a.redMul(r), p = r.redSqr().redMul(r).redIAdd(f).redIAdd(this.b);
      return o.redSqr().redISub(p).cmpn(0) === 0;
    };
    xr.prototype._endoWnafMulAdd = function(e2, r, o) {
      for (var f = this._endoWnafT1, p = this._endoWnafT2, m = 0;m < e2.length; m++) {
        var y = this._endoSplit(r[m]), M = e2[m], x = M._getBeta();
        y.k1.negative && (y.k1.ineg(), M = M.neg(true)), y.k2.negative && (y.k2.ineg(), x = x.neg(true)), f[m * 2] = M, f[m * 2 + 1] = x, p[m * 2] = y.k1, p[m * 2 + 1] = y.k2;
      }
      for (var S = this._wnafMulAdd(1, f, p, m * 2, o), E = 0;E < m * 2; E++)
        f[E] = null, p[E] = null;
      return S;
    };
    function Ct(t, e2, r, o) {
      Bf.BasePoint.call(this, t, "affine"), e2 === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt(e2, 16), this.y = new lt(r, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Dl(Ct, Bf.BasePoint);
    xr.prototype.point = function(e2, r, o) {
      return new Ct(this, e2, r, o);
    };
    xr.prototype.pointFromJSON = function(e2, r) {
      return Ct.fromJSON(this, e2, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e2 = this.precomputed;
        if (e2 && e2.beta)
          return e2.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e2) {
          var o = this.curve, f = function(p) {
            return o.point(p.x.redMul(o.endo.beta), p.y);
          };
          e2.beta = r, r.precomputed = { beta: null, naf: e2.naf && { wnd: e2.naf.wnd, points: e2.naf.points.map(f) }, doubles: e2.doubles && { step: e2.doubles.step, points: e2.doubles.points.map(f) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e2, r, o) {
      typeof r == "string" && (r = JSON.parse(r));
      var f = e2.point(r[0], r[1], o);
      if (!r[2])
        return f;
      function p(y) {
        return e2.point(y[0], y[1], o);
      }
      var m = r[2];
      return f.precomputed = { beta: null, doubles: m.doubles && { step: m.doubles.step, points: [f].concat(m.doubles.points.map(p)) }, naf: m.naf && { wnd: m.naf.wnd, points: [f].concat(m.naf.points.map(p)) } }, f;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e2) {
      if (this.inf)
        return e2;
      if (e2.inf)
        return this;
      if (this.eq(e2))
        return this.dbl();
      if (this.neg().eq(e2))
        return this.curve.point(null, null);
      if (this.x.cmp(e2.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e2.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e2.x).redInvm()));
      var o = r.redSqr().redISub(this.x).redISub(e2.x), f = r.redMul(this.x.redSub(o)).redISub(this.y);
      return this.curve.point(o, f);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e2 = this.y.redAdd(this.y);
      if (e2.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o = this.x.redSqr(), f = e2.redInvm(), p = o.redAdd(o).redIAdd(o).redIAdd(r).redMul(f), m = p.redSqr().redISub(this.x.redAdd(this.x)), y = p.redMul(this.x.redSub(m)).redISub(this.y);
      return this.curve.point(m, y);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e2) {
      return e2 = new lt(e2, 16), this.isInfinity() ? this : this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e2]) : this.curve._wnafMul(this, e2);
    };
    Ct.prototype.mulAdd = function(e2, r, o) {
      var f = [this, r], p = [e2, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p) : this.curve._wnafMulAdd(1, f, p, 2);
    };
    Ct.prototype.jmulAdd = function(e2, r, o) {
      var f = [this, r], p = [e2, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p, true) : this.curve._wnafMulAdd(1, f, p, 2, true);
    };
    Ct.prototype.eq = function(e2) {
      return this === e2 || this.inf === e2.inf && (this.inf || this.x.cmp(e2.x) === 0 && this.y.cmp(e2.y) === 0);
    };
    Ct.prototype.neg = function(e2) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e2 && this.precomputed) {
        var o = this.precomputed, f = function(p) {
          return p.neg();
        };
        r.precomputed = { naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(f) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(f) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e2 = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e2;
    };
    function Wt(t, e2, r, o) {
      Bf.BasePoint.call(this, t, "jacobian"), e2 === null && r === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt(0)) : (this.x = new lt(e2, 16), this.y = new lt(r, 16), this.z = new lt(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Dl(Wt, Bf.BasePoint);
    xr.prototype.jpoint = function(e2, r, o) {
      return new Wt(this, e2, r, o);
    };
    Wt.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e2 = this.z.redInvm(), r = e2.redSqr(), o = this.x.redMul(r), f = this.y.redMul(r).redMul(e2);
      return this.curve.point(o, f);
    };
    Wt.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt.prototype.add = function(e2) {
      if (this.isInfinity())
        return e2;
      if (e2.isInfinity())
        return this;
      var r = e2.z.redSqr(), o = this.z.redSqr(), f = this.x.redMul(r), p = e2.x.redMul(o), m = this.y.redMul(r.redMul(e2.z)), y = e2.y.redMul(o.redMul(this.z)), M = f.redSub(p), x = m.redSub(y);
      if (M.cmpn(0) === 0)
        return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S = M.redSqr(), E = S.redMul(M), B = f.redMul(S), q = x.redSqr().redIAdd(E).redISub(B).redISub(B), L = x.redMul(B.redISub(q)).redISub(m.redMul(E)), ge = this.z.redMul(e2.z).redMul(M);
      return this.curve.jpoint(q, L, ge);
    };
    Wt.prototype.mixedAdd = function(e2) {
      if (this.isInfinity())
        return e2.toJ();
      if (e2.isInfinity())
        return this;
      var r = this.z.redSqr(), o = this.x, f = e2.x.redMul(r), p = this.y, m = e2.y.redMul(r).redMul(this.z), y = o.redSub(f), M = p.redSub(m);
      if (y.cmpn(0) === 0)
        return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x = y.redSqr(), S = x.redMul(y), E = o.redMul(x), B = M.redSqr().redIAdd(S).redISub(E).redISub(E), q = M.redMul(E.redISub(B)).redISub(p.redMul(S)), L = this.z.redMul(y);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.dblp = function(e2) {
      if (e2 === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e2)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o = this;
        for (r = 0;r < e2; r++)
          o = o.dbl();
        return o;
      }
      var f = this.curve.a, p = this.curve.tinv, m = this.x, y = this.y, M = this.z, x = M.redSqr().redSqr(), S = y.redAdd(y);
      for (r = 0;r < e2; r++) {
        var E = m.redSqr(), B = S.redSqr(), q = B.redSqr(), L = E.redAdd(E).redIAdd(E).redIAdd(f.redMul(x)), ge = m.redMul(B), _e = L.redSqr().redISub(ge.redAdd(ge)), N = ge.redISub(_e), we = L.redMul(N);
        we = we.redIAdd(we).redISub(q);
        var ye = S.redMul(M);
        r + 1 < e2 && (x = x.redMul(q)), m = _e, M = ye, S = we;
      }
      return this.curve.jpoint(m, S.redMul(p), M);
    };
    Wt.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt.prototype._zeroDbl = function() {
      var e2, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f), x = M.redSqr().redISub(y).redISub(y), S = m.redIAdd(m);
        S = S.redIAdd(S), S = S.redIAdd(S), e2 = x, r = M.redMul(y.redISub(x)).redISub(S), o = this.y.redAdd(this.y);
      } else {
        var E = this.x.redSqr(), B = this.y.redSqr(), q = B.redSqr(), L = this.x.redAdd(B).redSqr().redISub(E).redISub(q);
        L = L.redIAdd(L);
        var ge = E.redAdd(E).redIAdd(E), _e = ge.redSqr(), N = q.redIAdd(q);
        N = N.redIAdd(N), N = N.redIAdd(N), e2 = _e.redISub(L).redISub(L), r = ge.redMul(L.redISub(e2)).redISub(N), o = this.y.redMul(this.z), o = o.redIAdd(o);
      }
      return this.curve.jpoint(e2, r, o);
    };
    Wt.prototype._threeDbl = function() {
      var e2, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f).redIAdd(this.curve.a), x = M.redSqr().redISub(y).redISub(y);
        e2 = x;
        var S = m.redIAdd(m);
        S = S.redIAdd(S), S = S.redIAdd(S), r = M.redMul(y.redISub(x)).redISub(S), o = this.y.redAdd(this.y);
      } else {
        var E = this.z.redSqr(), B = this.y.redSqr(), q = this.x.redMul(B), L = this.x.redSub(E).redMul(this.x.redAdd(E));
        L = L.redAdd(L).redIAdd(L);
        var ge = q.redIAdd(q);
        ge = ge.redIAdd(ge);
        var _e = ge.redAdd(ge);
        e2 = L.redSqr().redISub(_e), o = this.y.redAdd(this.z).redSqr().redISub(B).redISub(E);
        var N = B.redSqr();
        N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N), r = L.redMul(ge.redISub(e2)).redISub(N);
      }
      return this.curve.jpoint(e2, r, o);
    };
    Wt.prototype._dbl = function() {
      var e2 = this.curve.a, r = this.x, o = this.y, f = this.z, p = f.redSqr().redSqr(), m = r.redSqr(), y = o.redSqr(), M = m.redAdd(m).redIAdd(m).redIAdd(e2.redMul(p)), x = r.redAdd(r);
      x = x.redIAdd(x);
      var S = x.redMul(y), E = M.redSqr().redISub(S.redAdd(S)), B = S.redISub(E), q = y.redSqr();
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = M.redMul(B).redISub(q), ge = o.redAdd(o).redMul(f);
      return this.curve.jpoint(E, L, ge);
    };
    Wt.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e2 = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr(), f = r.redSqr(), p = e2.redAdd(e2).redIAdd(e2), m = p.redSqr(), y = this.x.redAdd(r).redSqr().redISub(e2).redISub(f);
      y = y.redIAdd(y), y = y.redAdd(y).redIAdd(y), y = y.redISub(m);
      var M = y.redSqr(), x = f.redIAdd(f);
      x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
      var S = p.redIAdd(y).redSqr().redISub(m).redISub(M).redISub(x), E = r.redMul(S);
      E = E.redIAdd(E), E = E.redIAdd(E);
      var B = this.x.redMul(M).redISub(E);
      B = B.redIAdd(B), B = B.redIAdd(B);
      var q = this.y.redMul(S.redMul(x.redISub(S)).redISub(y.redMul(M)));
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = this.z.redAdd(y).redSqr().redISub(o).redISub(M);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.mul = function(e2, r) {
      return e2 = new lt(e2, r), this.curve._wnafMul(this, e2);
    };
    Wt.prototype.eq = function(e2) {
      if (e2.type === "affine")
        return this.eq(e2.toJ());
      if (this === e2)
        return true;
      var r = this.z.redSqr(), o = e2.z.redSqr();
      if (this.x.redMul(o).redISub(e2.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f = r.redMul(this.z), p = o.redMul(e2.z);
      return this.y.redMul(p).redISub(e2.y.redMul(f)).cmpn(0) === 0;
    };
    Wt.prototype.eqXToP = function(e2) {
      var r = this.z.redSqr(), o = e2.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o) === 0)
        return true;
      for (var f = e2.clone(), p = this.curve.redN.redMul(r);; ) {
        if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0)
          return false;
        if (o.redIAdd(p), this.x.cmp(o) === 0)
          return true;
      }
    };
    Wt.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  y2 = T((Ek, g2) => {
    var qf = ri(), m2 = Ie(), Gs = Oa(), MA = or();
    function If(t) {
      Gs.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    m2(If, Gs);
    g2.exports = If;
    If.prototype.validate = function(e2) {
      var r = e2.normalize().x, o = r.redSqr(), f = o.redMul(r).redAdd(o.redMul(this.a)).redAdd(r), p = f.redSqrt();
      return p.redSqr().cmp(f) === 0;
    };
    function Ot(t, e2, r) {
      Gs.BasePoint.call(this, t, "projective"), e2 === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e2, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    m2(Ot, Gs.BasePoint);
    If.prototype.decodePoint = function(e2, r) {
      return this.point(MA.toArray(e2, r), 1);
    };
    If.prototype.point = function(e2, r) {
      return new Ot(this, e2, r);
    };
    If.prototype.pointFromJSON = function(e2) {
      return Ot.fromJSON(this, e2);
    };
    Ot.prototype.precompute = function() {
    };
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e2, r) {
      return new Ot(e2, r[0], r[1] || e2.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e2 = this.x.redAdd(this.z), r = e2.redSqr(), o = this.x.redSub(this.z), f = o.redSqr(), p = r.redSub(f), m = r.redMul(f), y = p.redMul(f.redAdd(this.curve.a24.redMul(p)));
      return this.curve.point(m, y);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e2, r) {
      var o = this.x.redAdd(this.z), f = this.x.redSub(this.z), p = e2.x.redAdd(e2.z), m = e2.x.redSub(e2.z), y = m.redMul(o), M = p.redMul(f), x = r.z.redMul(y.redAdd(M).redSqr()), S = r.x.redMul(y.redISub(M).redSqr());
      return this.curve.point(x, S);
    };
    Ot.prototype.mul = function(e2) {
      for (var r = e2.clone(), o = this, f = this.curve.point(null, null), p = this, m = [];r.cmpn(0) !== 0; r.iushrn(1))
        m.push(r.andln(1));
      for (var y = m.length - 1;y >= 0; y--)
        m[y] === 0 ? (o = o.diffAdd(f, p), f = f.dbl()) : (f = o.diffAdd(f, p), o = o.dbl());
      return f;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e2) {
      return this.getX().cmp(e2.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  _2 = T((Ak, M2) => {
    var _A = or(), Ai = ri(), w2 = Ie(), Ys = Oa(), xA = _A.assert;
    function ii(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys.call(this, "edwards", t), this.a = new Ai(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    w2(ii, Ys);
    M2.exports = ii;
    ii.prototype._mulA = function(e2) {
      return this.mOneA ? e2.redNeg() : this.a.redMul(e2);
    };
    ii.prototype._mulC = function(e2) {
      return this.oneC ? e2 : this.c.redMul(e2);
    };
    ii.prototype.jpoint = function(e2, r, o, f) {
      return this.point(e2, r, o, f);
    };
    ii.prototype.pointFromX = function(e2, r) {
      e2 = new Ai(e2, 16), e2.red || (e2 = e2.toRed(this.red));
      var o = e2.redSqr(), f = this.c2.redSub(this.a.redMul(o)), p = this.one.redSub(this.c2.redMul(this.d).redMul(o)), m = f.redMul(p.redInvm()), y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M = y.fromRed().isOdd();
      return (r && !M || !r && M) && (y = y.redNeg()), this.point(e2, y);
    };
    ii.prototype.pointFromY = function(e2, r) {
      e2 = new Ai(e2, 16), e2.red || (e2 = e2.toRed(this.red));
      var o = e2.redSqr(), f = o.redSub(this.c2), p = o.redMul(this.d).redMul(this.c2).redSub(this.a), m = f.redMul(p.redInvm());
      if (m.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e2);
      }
      var y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y.fromRed().isOdd() !== r && (y = y.redNeg()), this.point(y, e2);
    };
    ii.prototype.validate = function(e2) {
      if (e2.isInfinity())
        return true;
      e2.normalize();
      var r = e2.x.redSqr(), o = e2.y.redSqr(), f = r.redMul(this.a).redAdd(o), p = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o)));
      return f.cmp(p) === 0;
    };
    function at(t, e2, r, o, f) {
      Ys.BasePoint.call(this, t, "projective"), e2 === null && r === null && o === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai(e2, 16), this.y = new Ai(r, 16), this.z = o ? new Ai(o, 16) : this.curve.one, this.t = f && new Ai(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    w2(at, Ys.BasePoint);
    ii.prototype.pointFromJSON = function(e2) {
      return at.fromJSON(this, e2);
    };
    ii.prototype.point = function(e2, r, o, f) {
      return new at(this, e2, r, o, f);
    };
    at.fromJSON = function(e2, r) {
      return new at(e2, r[0], r[1], r[2]);
    };
    at.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at.prototype._extDbl = function() {
      var e2 = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr();
      o = o.redIAdd(o);
      var f = this.curve._mulA(e2), p = this.x.redAdd(this.y).redSqr().redISub(e2).redISub(r), m = f.redAdd(r), y = m.redSub(o), M = f.redSub(r), x = p.redMul(y), S = m.redMul(M), E = p.redMul(M), B = y.redMul(m);
      return this.curve.point(x, S, B, E);
    };
    at.prototype._projDbl = function() {
      var e2 = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o = this.y.redSqr(), f, p, m, y, M, x;
      if (this.curve.twisted) {
        y = this.curve._mulA(r);
        var S = y.redAdd(o);
        this.zOne ? (f = e2.redSub(r).redSub(o).redMul(S.redSub(this.curve.two)), p = S.redMul(y.redSub(o)), m = S.redSqr().redSub(S).redSub(S)) : (M = this.z.redSqr(), x = S.redSub(M).redISub(M), f = e2.redSub(r).redISub(o).redMul(x), p = S.redMul(y.redSub(o)), m = S.redMul(x));
      } else
        y = r.redAdd(o), M = this.curve._mulC(this.z).redSqr(), x = y.redSub(M).redSub(M), f = this.curve._mulC(e2.redISub(y)).redMul(x), p = this.curve._mulC(y).redMul(r.redISub(o)), m = y.redMul(x);
      return this.curve.point(f, p, m);
    };
    at.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at.prototype._extAdd = function(e2) {
      var r = this.y.redSub(this.x).redMul(e2.y.redSub(e2.x)), o = this.y.redAdd(this.x).redMul(e2.y.redAdd(e2.x)), f = this.t.redMul(this.curve.dd).redMul(e2.t), p = this.z.redMul(e2.z.redAdd(e2.z)), m = o.redSub(r), y = p.redSub(f), M = p.redAdd(f), x = o.redAdd(r), S = m.redMul(y), E = M.redMul(x), B = m.redMul(x), q = y.redMul(M);
      return this.curve.point(S, E, q, B);
    };
    at.prototype._projAdd = function(e2) {
      var r = this.z.redMul(e2.z), o = r.redSqr(), f = this.x.redMul(e2.x), p = this.y.redMul(e2.y), m = this.curve.d.redMul(f).redMul(p), y = o.redSub(m), M = o.redAdd(m), x = this.x.redAdd(this.y).redMul(e2.x.redAdd(e2.y)).redISub(f).redISub(p), S = r.redMul(y).redMul(x), E, B;
      return this.curve.twisted ? (E = r.redMul(M).redMul(p.redSub(this.curve._mulA(f))), B = y.redMul(M)) : (E = r.redMul(M).redMul(p.redSub(f)), B = this.curve._mulC(y).redMul(M)), this.curve.point(S, E, B);
    };
    at.prototype.add = function(e2) {
      return this.isInfinity() ? e2 : e2.isInfinity() ? this : this.curve.extended ? this._extAdd(e2) : this._projAdd(e2);
    };
    at.prototype.mul = function(e2) {
      return this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve._wnafMul(this, e2);
    };
    at.prototype.mulAdd = function(e2, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e2, o], 2, false);
    };
    at.prototype.jmulAdd = function(e2, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e2, o], 2, true);
    };
    at.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e2 = this.z.redInvm();
      return this.x = this.x.redMul(e2), this.y = this.y.redMul(e2), this.t && (this.t = this.t.redMul(e2)), this.z = this.curve.one, this.zOne = true, this;
    };
    at.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at.prototype.eq = function(e2) {
      return this === e2 || this.getX().cmp(e2.getX()) === 0 && this.getY().cmp(e2.getY()) === 0;
    };
    at.prototype.eqXToP = function(e2) {
      var r = e2.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o = e2.clone(), f = this.curve.redN.redMul(this.z);; ) {
        if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f), this.x.cmp(r) === 0)
          return true;
      }
    };
    at.prototype.toP = at.prototype.normalize;
    at.prototype.mixedAdd = at.prototype.add;
  });
  Pl = T((x2) => {
    var Xs = x2;
    Xs.base = Oa();
    Xs.short = b2();
    Xs.mont = y2();
    Xs.edwards = _2();
  });
  Cr = T((it) => {
    var SA = ar(), EA = Ie();
    it.inherits = EA;
    function AA(t, e2) {
      return (t.charCodeAt(e2) & 64512) !== 55296 || e2 < 0 || e2 + 1 >= t.length ? false : (t.charCodeAt(e2 + 1) & 64512) === 56320;
    }
    function RA(t, e2) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e2) {
          if (e2 === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f = 0;f < t.length; f += 2)
              r.push(parseInt(t[f] + t[f + 1], 16));
        } else
          for (var o = 0, f = 0;f < t.length; f++) {
            var p = t.charCodeAt(f);
            p < 128 ? r[o++] = p : p < 2048 ? (r[o++] = p >> 6 | 192, r[o++] = p & 63 | 128) : AA(t, f) ? (p = 65536 + ((p & 1023) << 10) + (t.charCodeAt(++f) & 1023), r[o++] = p >> 18 | 240, r[o++] = p >> 12 & 63 | 128, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128) : (r[o++] = p >> 12 | 224, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128);
          }
      else
        for (f = 0;f < t.length; f++)
          r[f] = t[f] | 0;
      return r;
    }
    it.toArray = RA;
    function BA(t) {
      for (var e2 = "", r = 0;r < t.length; r++)
        e2 += E2(t[r].toString(16));
      return e2;
    }
    it.toHex = BA;
    function S2(t) {
      var e2 = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e2 >>> 0;
    }
    it.htonl = S2;
    function qA(t, e2) {
      for (var r = "", o = 0;o < t.length; o++) {
        var f = t[o];
        e2 === "little" && (f = S2(f)), r += A2(f.toString(16));
      }
      return r;
    }
    it.toHex32 = qA;
    function E2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it.zero2 = E2;
    function A2(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it.zero8 = A2;
    function IA(t, e2, r, o) {
      var f = r - e2;
      SA(f % 4 === 0);
      for (var p = new Array(f / 4), m = 0, y = e2;m < p.length; m++, y += 4) {
        var M;
        o === "big" ? M = t[y] << 24 | t[y + 1] << 16 | t[y + 2] << 8 | t[y + 3] : M = t[y + 3] << 24 | t[y + 2] << 16 | t[y + 1] << 8 | t[y], p[m] = M >>> 0;
      }
      return p;
    }
    it.join32 = IA;
    function TA(t, e2) {
      for (var r = new Array(t.length * 4), o = 0, f = 0;o < t.length; o++, f += 4) {
        var p = t[o];
        e2 === "big" ? (r[f] = p >>> 24, r[f + 1] = p >>> 16 & 255, r[f + 2] = p >>> 8 & 255, r[f + 3] = p & 255) : (r[f + 3] = p >>> 24, r[f + 2] = p >>> 16 & 255, r[f + 1] = p >>> 8 & 255, r[f] = p & 255);
      }
      return r;
    }
    it.split32 = TA;
    function kA(t, e2) {
      return t >>> e2 | t << 32 - e2;
    }
    it.rotr32 = kA;
    function LA(t, e2) {
      return t << e2 | t >>> 32 - e2;
    }
    it.rotl32 = LA;
    function NA(t, e2) {
      return t + e2 >>> 0;
    }
    it.sum32 = NA;
    function DA(t, e2, r) {
      return t + e2 + r >>> 0;
    }
    it.sum32_3 = DA;
    function PA(t, e2, r, o) {
      return t + e2 + r + o >>> 0;
    }
    it.sum32_4 = PA;
    function CA(t, e2, r, o, f) {
      return t + e2 + r + o + f >>> 0;
    }
    it.sum32_5 = CA;
    function OA(t, e2, r, o) {
      var f = t[e2], p = t[e2 + 1], m = o + p >>> 0, y = (m < o ? 1 : 0) + r + f;
      t[e2] = y >>> 0, t[e2 + 1] = m;
    }
    it.sum64 = OA;
    function FA(t, e2, r, o) {
      var f = e2 + o >>> 0, p = (f < e2 ? 1 : 0) + t + r;
      return p >>> 0;
    }
    it.sum64_hi = FA;
    function UA(t, e2, r, o) {
      var f = e2 + o;
      return f >>> 0;
    }
    it.sum64_lo = UA;
    function zA(t, e2, r, o, f, p, m, y) {
      var M = 0, x = e2;
      x = x + o >>> 0, M += x < e2 ? 1 : 0, x = x + p >>> 0, M += x < p ? 1 : 0, x = x + y >>> 0, M += x < y ? 1 : 0;
      var S = t + r + f + m + M;
      return S >>> 0;
    }
    it.sum64_4_hi = zA;
    function HA(t, e2, r, o, f, p, m, y) {
      var M = e2 + o + p + y;
      return M >>> 0;
    }
    it.sum64_4_lo = HA;
    function WA(t, e2, r, o, f, p, m, y, M, x) {
      var S = 0, E = e2;
      E = E + o >>> 0, S += E < e2 ? 1 : 0, E = E + p >>> 0, S += E < p ? 1 : 0, E = E + y >>> 0, S += E < y ? 1 : 0, E = E + x >>> 0, S += E < x ? 1 : 0;
      var B = t + r + f + m + M + S;
      return B >>> 0;
    }
    it.sum64_5_hi = WA;
    function KA(t, e2, r, o, f, p, m, y, M, x) {
      var S = e2 + o + p + y + x;
      return S >>> 0;
    }
    it.sum64_5_lo = KA;
    function jA(t, e2, r) {
      var o = e2 << 32 - r | t >>> r;
      return o >>> 0;
    }
    it.rotr64_hi = jA;
    function ZA(t, e2, r) {
      var o = t << 32 - r | e2 >>> r;
      return o >>> 0;
    }
    it.rotr64_lo = ZA;
    function VA(t, e2, r) {
      return t >>> r;
    }
    it.shr64_hi = VA;
    function $A(t, e2, r) {
      var o = t << 32 - r | e2 >>> r;
      return o >>> 0;
    }
    it.shr64_lo = $A;
  });
  Tf = T((B2) => {
    var R2 = Cr(), GA = ar();
    function Js() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    B2.BlockHash = Js;
    Js.prototype.update = function(e2, r) {
      if (e2 = R2.toArray(e2, r), this.pending ? this.pending = this.pending.concat(e2) : this.pending = e2, this.pendingTotal += e2.length, this.pending.length >= this._delta8) {
        e2 = this.pending;
        var o = e2.length % this._delta8;
        this.pending = e2.slice(e2.length - o, e2.length), this.pending.length === 0 && (this.pending = null), e2 = R2.join32(e2, 0, e2.length - o, this.endian);
        for (var f = 0;f < e2.length; f += this._delta32)
          this._update(e2, f, f + this._delta32);
      }
      return this;
    };
    Js.prototype.digest = function(e2) {
      return this.update(this._pad()), GA(this.pending === null), this._digest(e2);
    };
    Js.prototype._pad = function() {
      var e2 = this.pendingTotal, r = this._delta8, o = r - (e2 + this.padLength) % r, f = new Array(o + this.padLength);
      f[0] = 128;
      for (var p = 1;p < o; p++)
        f[p] = 0;
      if (e2 <<= 3, this.endian === "big") {
        for (var m = 8;m < this.padLength; m++)
          f[p++] = 0;
        f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = e2 >>> 24 & 255, f[p++] = e2 >>> 16 & 255, f[p++] = e2 >>> 8 & 255, f[p++] = e2 & 255;
      } else
        for (f[p++] = e2 & 255, f[p++] = e2 >>> 8 & 255, f[p++] = e2 >>> 16 & 255, f[p++] = e2 >>> 24 & 255, f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = 0, m = 8;m < this.padLength; m++)
          f[p++] = 0;
      return f;
    };
  });
  Cl = T((Ri) => {
    var YA = Cr(), ni = YA.rotr32;
    function XA(t, e2, r, o) {
      if (t === 0)
        return q2(e2, r, o);
      if (t === 1 || t === 3)
        return T2(e2, r, o);
      if (t === 2)
        return I2(e2, r, o);
    }
    Ri.ft_1 = XA;
    function q2(t, e2, r) {
      return t & e2 ^ ~t & r;
    }
    Ri.ch32 = q2;
    function I2(t, e2, r) {
      return t & e2 ^ t & r ^ e2 & r;
    }
    Ri.maj32 = I2;
    function T2(t, e2, r) {
      return t ^ e2 ^ r;
    }
    Ri.p32 = T2;
    function JA(t) {
      return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
    }
    Ri.s0_256 = JA;
    function QA(t) {
      return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
    }
    Ri.s1_256 = QA;
    function eR(t) {
      return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
    }
    Ri.g0_256 = eR;
    function tR(t) {
      return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
    }
    Ri.g1_256 = tR;
  });
  N2 = T((Tk, L2) => {
    var kf = Cr(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k2 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
    function fi() {
      if (!(this instanceof fi))
        return new fi;
      k2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    kf.inherits(fi, k2);
    L2.exports = fi;
    fi.blockSize = 512;
    fi.outSize = 160;
    fi.hmacStrength = 80;
    fi.padLength = 64;
    fi.prototype._update = function(e2, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e2[r + f];
      for (;f < o.length; f++)
        o[f] = Ol(o[f - 3] ^ o[f - 8] ^ o[f - 14] ^ o[f - 16], 1);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4];
      for (f = 0;f < o.length; f++) {
        var S = ~~(f / 20), E = nR(Ol(p, 5), fR(S, m, y, M), x, o[f], aR[S]);
        x = M, M = y, y = Ol(m, 30), m = p, p = E;
      }
      this.h[0] = Fa(this.h[0], p), this.h[1] = Fa(this.h[1], m), this.h[2] = Fa(this.h[2], y), this.h[3] = Fa(this.h[3], M), this.h[4] = Fa(this.h[4], x);
    };
    fi.prototype._digest = function(e2) {
      return e2 === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
    };
  });
  Fl = T((kk, P22) => {
    var Lf = Cr(), oR = Tf(), Nf = Cl(), sR = ar(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D2 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ai() {
      if (!(this instanceof ai))
        return new ai;
      D2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
    }
    Lf.inherits(ai, D2);
    P22.exports = ai;
    ai.blockSize = 512;
    ai.outSize = 256;
    ai.hmacStrength = 192;
    ai.padLength = 64;
    ai.prototype._update = function(e2, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e2[r + f];
      for (;f < o.length; f++)
        o[f] = hR(bR(o[f - 2]), o[f - 7], vR(o[f - 15]), o[f - 16]);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4], S = this.h[5], E = this.h[6], B = this.h[7];
      for (sR(this.k.length === o.length), f = 0;f < o.length; f++) {
        var q = uR(B, pR(x), lR(x, S, E), this.k[f], o[f]), L = Or(cR(p), dR(p, m, y));
        B = E, E = S, S = x, x = Or(M, q), M = y, y = m, m = p, p = Or(q, L);
      }
      this.h[0] = Or(this.h[0], p), this.h[1] = Or(this.h[1], m), this.h[2] = Or(this.h[2], y), this.h[3] = Or(this.h[3], M), this.h[4] = Or(this.h[4], x), this.h[5] = Or(this.h[5], S), this.h[6] = Or(this.h[6], E), this.h[7] = Or(this.h[7], B);
    };
    ai.prototype._digest = function(e2) {
      return e2 === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
    };
  });
  F2 = T((Lk, O2) => {
    var Ul = Cr(), C2 = Fl();
    function Bi() {
      if (!(this instanceof Bi))
        return new Bi;
      C2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ul.inherits(Bi, C2);
    O2.exports = Bi;
    Bi.blockSize = 512;
    Bi.outSize = 224;
    Bi.hmacStrength = 192;
    Bi.padLength = 64;
    Bi.prototype._digest = function(e2) {
      return e2 === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
    };
  });
  Wl = T((Nk, W2) => {
    var ir = Cr(), gR = Tf(), yR = ar(), oi = ir.rotr64_hi, si = ir.rotr64_lo, U2 = ir.shr64_hi, z2 = ir.shr64_lo, Ji = ir.sum64, zl = ir.sum64_hi, Hl = ir.sum64_lo, wR = ir.sum64_4_hi, MR = ir.sum64_4_lo, _R = ir.sum64_5_hi, xR = ir.sum64_5_lo, H2 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr() {
      if (!(this instanceof Fr))
        return new Fr;
      H2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
    }
    ir.inherits(Fr, H2);
    W2.exports = Fr;
    Fr.blockSize = 1024;
    Fr.outSize = 512;
    Fr.hmacStrength = 192;
    Fr.padLength = 128;
    Fr.prototype._prepareBlock = function(e2, r) {
      for (var o = this.W, f = 0;f < 32; f++)
        o[f] = e2[r + f];
      for (;f < o.length; f += 2) {
        var p = DR(o[f - 4], o[f - 3]), m = PR(o[f - 4], o[f - 3]), y = o[f - 14], M = o[f - 13], x = LR(o[f - 30], o[f - 29]), S = NR(o[f - 30], o[f - 29]), E = o[f - 32], B = o[f - 31];
        o[f] = wR(p, m, y, M, x, S, E, B), o[f + 1] = MR(p, m, y, M, x, S, E, B);
      }
    };
    Fr.prototype._update = function(e2, r) {
      this._prepareBlock(e2, r);
      var o = this.W, f = this.h[0], p = this.h[1], m = this.h[2], y = this.h[3], M = this.h[4], x = this.h[5], S = this.h[6], E = this.h[7], B = this.h[8], q = this.h[9], L = this.h[10], ge = this.h[11], _e = this.h[12], N = this.h[13], we = this.h[14], ye = this.h[15];
      yR(this.k.length === o.length);
      for (var xe = 0;xe < o.length; xe += 2) {
        var Re = we, Ee = ye, Ae = TR(B, q), P5 = kR(B, q), Se = ER(B, q, L, ge, _e, N), v = AR(B, q, L, ge, _e, N), i = this.k[xe], a = this.k[xe + 1], h = o[xe], s = o[xe + 1], u = _R(Re, Ee, Ae, P5, Se, v, i, a, h, s), c = xR(Re, Ee, Ae, P5, Se, v, i, a, h, s);
        Re = qR(f, p), Ee = IR(f, p), Ae = RR(f, p, m, y, M, x), P5 = BR(f, p, m, y, M, x);
        var b = zl(Re, Ee, Ae, P5), l = Hl(Re, Ee, Ae, P5);
        we = _e, ye = N, _e = L, N = ge, L = B, ge = q, B = zl(S, E, u, c), q = Hl(E, E, u, c), S = M, E = x, M = m, x = y, m = f, y = p, f = zl(u, c, b, l), p = Hl(u, c, b, l);
      }
      Ji(this.h, 0, f, p), Ji(this.h, 2, m, y), Ji(this.h, 4, M, x), Ji(this.h, 6, S, E), Ji(this.h, 8, B, q), Ji(this.h, 10, L, ge), Ji(this.h, 12, _e, N), Ji(this.h, 14, we, ye);
    };
    Fr.prototype._digest = function(e2) {
      return e2 === "hex" ? ir.toHex32(this.h, "big") : ir.split32(this.h, "big");
    };
    function ER(t, e2, r, o, f) {
      var p = t & r ^ ~t & f;
      return p < 0 && (p += 4294967296), p;
    }
    function AR(t, e2, r, o, f, p) {
      var m = e2 & o ^ ~e2 & p;
      return m < 0 && (m += 4294967296), m;
    }
    function RR(t, e2, r, o, f) {
      var p = t & r ^ t & f ^ r & f;
      return p < 0 && (p += 4294967296), p;
    }
    function BR(t, e2, r, o, f, p) {
      var m = e2 & o ^ e2 & p ^ o & p;
      return m < 0 && (m += 4294967296), m;
    }
    function qR(t, e2) {
      var r = oi(t, e2, 28), o = oi(e2, t, 2), f = oi(e2, t, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function IR(t, e2) {
      var r = si(t, e2, 28), o = si(e2, t, 2), f = si(e2, t, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function TR(t, e2) {
      var r = oi(t, e2, 14), o = oi(t, e2, 18), f = oi(e2, t, 9), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function kR(t, e2) {
      var r = si(t, e2, 14), o = si(t, e2, 18), f = si(e2, t, 9), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function LR(t, e2) {
      var r = oi(t, e2, 1), o = oi(t, e2, 8), f = U2(t, e2, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function NR(t, e2) {
      var r = si(t, e2, 1), o = si(t, e2, 8), f = z2(t, e2, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function DR(t, e2) {
      var r = oi(t, e2, 19), o = oi(e2, t, 29), f = U2(t, e2, 6), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function PR(t, e2) {
      var r = si(t, e2, 19), o = si(e2, t, 29), f = z2(t, e2, 6), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
  });
  Z2 = T((Dk, j2) => {
    var Kl = Cr(), K2 = Wl();
    function qi() {
      if (!(this instanceof qi))
        return new qi;
      K2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Kl.inherits(qi, K2);
    j2.exports = qi;
    qi.blockSize = 1024;
    qi.outSize = 384;
    qi.hmacStrength = 192;
    qi.padLength = 128;
    qi.prototype._digest = function(e2) {
      return e2 === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
    };
  });
  V2 = T((Df) => {
    Df.sha1 = N2();
    Df.sha224 = F2();
    Df.sha256 = Fl();
    Df.sha384 = Z2();
    Df.sha512 = Wl();
  });
  Q2 = T((J2) => {
    var On = Cr(), CR = Tf(), Qs = On.rotl32, $2 = On.sum32, Ua = On.sum32_3, G2 = On.sum32_4, X2 = CR.BlockHash;
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      X2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    On.inherits(hi, X2);
    J2.ripemd160 = hi;
    hi.blockSize = 512;
    hi.outSize = 160;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e2, r) {
      for (var o = this.h[0], f = this.h[1], p = this.h[2], m = this.h[3], y = this.h[4], M = o, x = f, S = p, E = m, B = y, q = 0;q < 80; q++) {
        var L = $2(Qs(G2(o, Y2(q, f, p, m), e2[UR[q] + r], OR(q)), HR[q]), y);
        o = y, y = m, m = Qs(p, 10), p = f, f = L, L = $2(Qs(G2(M, Y2(79 - q, x, S, E), e2[zR[q] + r], FR(q)), WR[q]), B), M = B, B = E, E = Qs(S, 10), S = x, x = L;
      }
      L = Ua(this.h[1], p, E), this.h[1] = Ua(this.h[2], m, B), this.h[2] = Ua(this.h[3], y, M), this.h[3] = Ua(this.h[4], o, x), this.h[4] = Ua(this.h[0], f, S), this.h[0] = L;
    };
    hi.prototype._digest = function(e2) {
      return e2 === "hex" ? On.toHex32(this.h, "little") : On.split32(this.h, "little");
    };
    function Y2(t, e2, r, o) {
      return t <= 15 ? e2 ^ r ^ o : t <= 31 ? e2 & r | ~e2 & o : t <= 47 ? (e2 | ~r) ^ o : t <= 63 ? e2 & o | r & ~o : e2 ^ (r | ~o);
    }
    function OR(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function FR(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  ty = T((Ok, ey) => {
    var KR = Cr(), jR = ar();
    function Pf(t, e2, r) {
      if (!(this instanceof Pf))
        return new Pf(t, e2, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e2, r));
    }
    ey.exports = Pf;
    Pf.prototype._init = function(e2) {
      e2.length > this.blockSize && (e2 = new this.Hash().update(e2).digest()), jR(e2.length <= this.blockSize);
      for (var r = e2.length;r < this.blockSize; r++)
        e2.push(0);
      for (r = 0;r < e2.length; r++)
        e2[r] ^= 54;
      for (this.inner = new this.Hash().update(e2), r = 0;r < e2.length; r++)
        e2[r] ^= 106;
      this.outer = new this.Hash().update(e2);
    };
    Pf.prototype.update = function(e2, r) {
      return this.inner.update(e2, r), this;
    };
    Pf.prototype.digest = function(e2) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e2);
    };
  });
  e0 = T((ry) => {
    var Kt = ry;
    Kt.utils = Cr();
    Kt.common = Tf();
    Kt.sha = V2();
    Kt.ripemd = Q2();
    Kt.hmac = ty();
    Kt.sha1 = Kt.sha.sha1;
    Kt.sha256 = Kt.sha.sha256;
    Kt.sha224 = Kt.sha.sha224;
    Kt.sha384 = Kt.sha.sha384;
    Kt.sha512 = Kt.sha.sha512;
    Kt.ripemd160 = Kt.ripemd.ripemd160;
  });
  ny = T((Uk, iy) => {
    iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  t0 = T((oy) => {
    var Zl = oy, Qi = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
    function ay(t) {
      t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    Zl.PresetCurve = ay;
    function en(t, e2) {
      Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
        var r = new ay(e2);
        return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["9"] });
    en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var Vl;
    try {
      Vl = ny();
    } catch {
      Vl = undefined;
    }
    en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
  });
  uy = T((Hk, hy) => {
    var VR = e0(), Fn = Nl(), sy = ar();
    function tn(t) {
      if (!(this instanceof tn))
        return new tn(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e2 = Fn.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn.toArray(t.nonce, t.nonceEnc || "hex"), o = Fn.toArray(t.pers, t.persEnc || "hex");
      sy(e2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e2, r, o);
    }
    hy.exports = tn;
    tn.prototype._init = function(e2, r, o) {
      var f = e2.concat(r).concat(o);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p = 0;p < this.V.length; p++)
        this.K[p] = 0, this.V[p] = 1;
      this._update(f), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    tn.prototype._hmac = function() {
      return new VR.hmac(this.hash, this.K);
    };
    tn.prototype._update = function(e2) {
      var r = this._hmac().update(this.V).update([0]);
      e2 && (r = r.update(e2)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e2 && (this.K = this._hmac().update(this.V).update([1]).update(e2).digest(), this.V = this._hmac().update(this.V).digest());
    };
    tn.prototype.reseed = function(e2, r, o, f) {
      typeof r != "string" && (f = o, o = r, r = null), e2 = Fn.toArray(e2, r), o = Fn.toArray(o, f), sy(e2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e2.concat(o || [])), this._reseed = 1;
    };
    tn.prototype.generate = function(e2, r, o, f) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f = o, o = r, r = null), o && (o = Fn.toArray(o, f || "hex"), this._update(o));
      for (var p = [];p.length < e2; )
        this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
      var m = p.slice(0, e2);
      return this._update(o), this._reseed++, Fn.encode(m, r);
    };
  });
  dy = T((Wk, ly) => {
    var $R = ri(), GR = or(), $l = GR.assert;
    function Gt(t, e2) {
      this.ec = t, this.priv = null, this.pub = null, e2.priv && this._importPrivate(e2.priv, e2.privEnc), e2.pub && this._importPublic(e2.pub, e2.pubEnc);
    }
    ly.exports = Gt;
    Gt.fromPublic = function(e2, r, o) {
      return r instanceof Gt ? r : new Gt(e2, { pub: r, pubEnc: o });
    };
    Gt.fromPrivate = function(e2, r, o) {
      return r instanceof Gt ? r : new Gt(e2, { priv: r, privEnc: o });
    };
    Gt.prototype.validate = function() {
      var e2 = this.getPublic();
      return e2.isInfinity() ? { result: false, reason: "Invalid public key" } : e2.validate() ? e2.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e2, r) {
      return typeof e2 == "string" && (r = e2, e2 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e2) : this.pub;
    };
    Gt.prototype.getPrivate = function(e2) {
      return e2 === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e2, r) {
      this.priv = new $R(e2, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e2, r) {
      if (e2.x || e2.y) {
        this.ec.curve.type === "mont" ? $l(e2.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e2.x && e2.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e2.x, e2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e2, r);
    };
    Gt.prototype.derive = function(e2) {
      return e2.validate() || $l(e2.validate(), "public point not validated"), e2.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e2, r, o) {
      return this.ec.sign(e2, this, r, o);
    };
    Gt.prototype.verify = function(e2, r) {
      return this.ec.verify(e2, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  vy = T((Kk, py) => {
    var r0 = ri(), Xl = or(), YR = Xl.assert;
    function i0(t, e2) {
      if (t instanceof i0)
        return t;
      this._importDER(t, e2) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    py.exports = i0;
    function XR() {
      this.place = 0;
    }
    function Gl(t, e2) {
      var r = t[e2.place++];
      if (!(r & 128))
        return r;
      var o = r & 15;
      if (o === 0 || o > 4)
        return false;
      for (var f = 0, p = 0, m = e2.place;p < o; p++, m++)
        f <<= 8, f |= t[m], f >>>= 0;
      return f <= 127 ? false : (e2.place = m, f);
    }
    function cy(t) {
      for (var e2 = 0, r = t.length - 1;!t[e2] && !(t[e2 + 1] & 128) && e2 < r; )
        e2++;
      return e2 === 0 ? t : t.slice(e2);
    }
    i0.prototype._importDER = function(e2, r) {
      e2 = Xl.toArray(e2, r);
      var o = new XR;
      if (e2[o.place++] !== 48)
        return false;
      var f = Gl(e2, o);
      if (f === false || f + o.place !== e2.length || e2[o.place++] !== 2)
        return false;
      var p = Gl(e2, o);
      if (p === false)
        return false;
      var m = e2.slice(o.place, p + o.place);
      if (o.place += p, e2[o.place++] !== 2)
        return false;
      var y = Gl(e2, o);
      if (y === false || e2.length !== y + o.place)
        return false;
      var M = e2.slice(o.place, y + o.place);
      if (m[0] === 0)
        if (m[1] & 128)
          m = m.slice(1);
        else
          return false;
      if (M[0] === 0)
        if (M[1] & 128)
          M = M.slice(1);
        else
          return false;
      return this.r = new r0(m), this.s = new r0(M), this.recoveryParam = null, true;
    };
    function Yl(t, e2) {
      if (e2 < 128) {
        t.push(e2);
        return;
      }
      var r = 1 + (Math.log(e2) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e2 >>> (r << 3) & 255);
      t.push(e2);
    }
    i0.prototype.toDER = function(e2) {
      var r = this.r.toArray(), o = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o[0] & 128 && (o = [0].concat(o)), r = cy(r), o = cy(o);!o[0] && !(o[1] & 128); )
        o = o.slice(1);
      var f = [2];
      Yl(f, r.length), f = f.concat(r), f.push(2), Yl(f, o.length);
      var p = f.concat(o), m = [48];
      return Yl(m, p.length), m = m.concat(p), Xl.encode(m, e2);
    };
  });
  yy = T((jk, gy) => {
    var Un = ri(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
    function Sr(t) {
      if (!(this instanceof Sr))
        return new Sr(t);
      typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    gy.exports = Sr;
    Sr.prototype.keyPair = function(e2) {
      return new Ql(this, e2);
    };
    Sr.prototype.keyFromPrivate = function(e2, r) {
      return Ql.fromPrivate(this, e2, r);
    };
    Sr.prototype.keyFromPublic = function(e2, r) {
      return Ql.fromPublic(this, e2, r);
    };
    Sr.prototype.genKeyPair = function(e2) {
      e2 || (e2 = {});
      for (var r = new by({ hash: this.hash, pers: e2.pers, persEnc: e2.persEnc || "utf8", entropy: e2.entropy || QR(this.hash.hmacStrength), entropyEnc: e2.entropy && e2.entropyEnc || "utf8", nonce: this.n.toArray() }), o = this.n.byteLength(), f = this.n.sub(new Un(2));; ) {
        var p = new Un(r.generate(o));
        if (!(p.cmp(f) > 0))
          return p.iaddn(1), this.keyFromPrivate(p);
      }
    };
    Sr.prototype._truncateToN = function(e2, r) {
      var o = e2.byteLength() * 8 - this.n.bitLength();
      return o > 0 && (e2 = e2.ushrn(o)), !r && e2.cmp(this.n) >= 0 ? e2.sub(this.n) : e2;
    };
    Sr.prototype.sign = function(e2, r, o, f) {
      typeof o == "object" && (f = o, o = null), f || (f = {}), r = this.keyFromPrivate(r, o), e2 = this._truncateToN(new Un(e2, 16));
      for (var p = this.n.byteLength(), m = r.getPrivate().toArray("be", p), y = e2.toArray("be", p), M = new by({ hash: this.hash, entropy: m, nonce: y, pers: f.pers, persEnc: f.persEnc || "utf8" }), x = this.n.sub(new Un(1)), S = 0;; S++) {
        var E = f.k ? f.k(S) : new Un(M.generate(this.n.byteLength()));
        if (E = this._truncateToN(E, true), !(E.cmpn(1) <= 0 || E.cmp(x) >= 0)) {
          var B = this.g.mul(E);
          if (!B.isInfinity()) {
            var q = B.getX(), L = q.umod(this.n);
            if (L.cmpn(0) !== 0) {
              var ge = E.invm(this.n).mul(L.mul(r.getPrivate()).iadd(e2));
              if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
                var _e = (B.getY().isOdd() ? 1 : 0) | (q.cmp(L) !== 0 ? 2 : 0);
                return f.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e ^= 1), new n0({ r: L, s: ge, recoveryParam: _e });
              }
            }
          }
        }
      }
    };
    Sr.prototype.verify = function(e2, r, o, f) {
      e2 = this._truncateToN(new Un(e2, 16)), o = this.keyFromPublic(o, f), r = new n0(r, "hex");
      var { r: p, s: m } = r;
      if (p.cmpn(1) < 0 || p.cmp(this.n) >= 0 || m.cmpn(1) < 0 || m.cmp(this.n) >= 0)
        return false;
      var y = m.invm(this.n), M = y.mul(e2).umod(this.n), x = y.mul(p).umod(this.n), S;
      return this.curve._maxwellTrick ? (S = this.g.jmulAdd(M, o.getPublic(), x), S.isInfinity() ? false : S.eqXToP(p)) : (S = this.g.mulAdd(M, o.getPublic(), x), S.isInfinity() ? false : S.getX().umod(this.n).cmp(p) === 0);
    };
    Sr.prototype.recoverPubKey = function(t, e2, r, o) {
      my((3 & r) === r, "The recovery param is more than two bits"), e2 = new n0(e2, o);
      var f = this.n, p = new Un(t), m = e2.r, y = e2.s, M = r & 1, x = r >> 1;
      if (m.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
        throw new Error("Unable to find sencond key candinate");
      x ? m = this.curve.pointFromX(m.add(this.curve.n), M) : m = this.curve.pointFromX(m, M);
      var S = e2.r.invm(f), E = f.sub(p).mul(S).umod(f), B = y.mul(S).umod(f);
      return this.g.mulAdd(E, m, B);
    };
    Sr.prototype.getKeyRecoveryParam = function(t, e2, r, o) {
      if (e2 = new n0(e2, o), e2.recoveryParam !== null)
        return e2.recoveryParam;
      for (var f = 0;f < 4; f++) {
        var p;
        try {
          p = this.recoverPubKey(t, e2, f);
        } catch {
          continue;
        }
        if (p.eq(r))
          return f;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  xy = T((Zk, _y) => {
    var za = or(), My = za.assert, wy = za.parseBytes, Cf = za.cachedProperty;
    function Ft(t, e2) {
      this.eddsa = t, this._secret = wy(e2.secret), t.isPoint(e2.pub) ? this._pub = e2.pub : this._pubBytes = wy(e2.pub);
    }
    Ft.fromPublic = function(e2, r) {
      return r instanceof Ft ? r : new Ft(e2, { pub: r });
    };
    Ft.fromSecret = function(e2, r) {
      return r instanceof Ft ? r : new Ft(e2, { secret: r });
    };
    Ft.prototype.secret = function() {
      return this._secret;
    };
    Cf(Ft, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Cf(Ft, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Cf(Ft, "privBytes", function() {
      var e2 = this.eddsa, r = this.hash(), o = e2.encodingLength - 1, f = r.slice(0, e2.encodingLength);
      return f[0] &= 248, f[o] &= 127, f[o] |= 64, f;
    });
    Cf(Ft, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Cf(Ft, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Cf(Ft, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft.prototype.sign = function(e2) {
      return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e2, this);
    };
    Ft.prototype.verify = function(e2, r) {
      return this.eddsa.verify(e2, r, this);
    };
    Ft.prototype.getSecret = function(e2) {
      return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e2);
    };
    Ft.prototype.getPublic = function(e2) {
      return za.encode(this.pubBytes(), e2);
    };
    _y.exports = Ft;
  });
  Ey = T((Vk, Sy) => {
    var eB = ri(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
    function zn(t, e2) {
      this.eddsa = t, typeof e2 != "object" && (e2 = rB(e2)), Array.isArray(e2) && (e2 = { R: e2.slice(0, t.encodingLength), S: e2.slice(t.encodingLength) }), tB(e2.R && e2.S, "Signature without R or S"), t.isPoint(e2.R) && (this._R = e2.R), e2.S instanceof eB && (this._S = e2.S), this._Rencoded = Array.isArray(e2.R) ? e2.R : e2.Rencoded, this._Sencoded = Array.isArray(e2.S) ? e2.S : e2.Sencoded;
    }
    a0(zn, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    a0(zn, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    a0(zn, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    a0(zn, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    zn.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    zn.prototype.toHex = function() {
      return f0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Sy.exports = zn;
  });
  Iy = T(($k, qy) => {
    var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
    function nr(t) {
      if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
    }
    qy.exports = nr;
    nr.prototype.sign = function(e2, r) {
      e2 = Ry(e2);
      var o = this.keyFromSecret(r), f = this.hashInt(o.messagePrefix(), e2), p = this.g.mul(f), m = this.encodePoint(p), y = this.hashInt(m, o.pubBytes(), e2).mul(o.priv()), M = f.add(y).umod(this.curve.n);
      return this.makeSignature({ R: p, S: M, Rencoded: m });
    };
    nr.prototype.verify = function(e2, r, o) {
      e2 = Ry(e2), r = this.makeSignature(r);
      var f = this.keyFromPublic(o), p = this.hashInt(r.Rencoded(), f.pubBytes(), e2), m = this.g.mul(r.S()), y = r.R().add(f.pub().mul(p));
      return y.eq(m);
    };
    nr.prototype.hashInt = function() {
      for (var e2 = this.hash(), r = 0;r < arguments.length; r++)
        e2.update(arguments[r]);
      return Of.intFromLE(e2.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e2) {
      return By.fromPublic(this, e2);
    };
    nr.prototype.keyFromSecret = function(e2) {
      return By.fromSecret(this, e2);
    };
    nr.prototype.makeSignature = function(e2) {
      return e2 instanceof Ay ? e2 : new Ay(this, e2);
    };
    nr.prototype.encodePoint = function(e2) {
      var r = e2.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e2.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e2) {
      e2 = Of.parseBytes(e2);
      var r = e2.length - 1, o = e2.slice(0, r).concat(e2[r] & -129), f = (e2[r] & 128) !== 0, p = Of.intFromLE(o);
      return this.curve.pointFromY(p, f);
    };
    nr.prototype.encodeInt = function(e2) {
      return e2.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e2) {
      return Of.intFromLE(e2);
    };
    nr.prototype.isPoint = function(e2) {
      return e2 instanceof this.pointClass;
    };
  });
  o0 = T((Ty) => {
    var Hn = Ty;
    Hn.version = s2().version;
    Hn.utils = or();
    Hn.rand = As();
    Hn.curve = Pl();
    Hn.curves = t0();
    Hn.ec = yy();
    Hn.eddsa = Iy();
  });
  td = T((ky, ed) => {
    (function(t, e2) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e2.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q3) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q3) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q3) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q3) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q3) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q3) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q3) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q3) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q3) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q3) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q3) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q3) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q3) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q3) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q3) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q3), n = Math.imul(G, ee), n = n + Math.imul(Y, Q3) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P5(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P5(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P5.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P5.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P5.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P5.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P5.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P5.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P5.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P5.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P5.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P5.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P5.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P5.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P5.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P5.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P5.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P5.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P5.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P5.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P5.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P5), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof ed > "u" || ed, ky);
  });
  h0 = T((Yk, Ly) => {
    var s0 = Ut(), Ff = s0.Buffer, Er = {}, Ar;
    for (Ar in s0)
      !s0.hasOwnProperty(Ar) || Ar === "SlowBuffer" || Ar === "Buffer" || (Er[Ar] = s0[Ar]);
    var Uf = Er.Buffer = {};
    for (Ar in Ff)
      !Ff.hasOwnProperty(Ar) || Ar === "allocUnsafe" || Ar === "allocUnsafeSlow" || (Uf[Ar] = Ff[Ar]);
    Er.Buffer.prototype = Ff.prototype;
    (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e2, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Ff(t, e2, r);
    });
    Uf.alloc || (Uf.alloc = function(t, e2, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o = Ff(t);
      return !e2 || e2.length === 0 ? o.fill(0) : typeof r == "string" ? o.fill(e2, r) : o.fill(e2), o;
    });
    if (!Er.kStringMaxLength)
      try {
        Er.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    Er.constants || (Er.constants = { MAX_LENGTH: Er.kMaxLength }, Er.kStringMaxLength && (Er.constants.MAX_STRING_LENGTH = Er.kStringMaxLength));
    Ly.exports = Er;
  });
  u0 = T((Ny) => {
    var aB = Ie();
    function Rr(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    Ny.Reporter = Rr;
    Rr.prototype.isError = function(e2) {
      return e2 instanceof zf;
    };
    Rr.prototype.save = function() {
      let e2 = this._reporterState;
      return { obj: e2.obj, pathLen: e2.path.length };
    };
    Rr.prototype.restore = function(e2) {
      let r = this._reporterState;
      r.obj = e2.obj, r.path = r.path.slice(0, e2.pathLen);
    };
    Rr.prototype.enterKey = function(e2) {
      return this._reporterState.path.push(e2);
    };
    Rr.prototype.exitKey = function(e2) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e2 - 1);
    };
    Rr.prototype.leaveKey = function(e2, r, o) {
      let f = this._reporterState;
      this.exitKey(e2), f.obj !== null && (f.obj[r] = o);
    };
    Rr.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Rr.prototype.enterObject = function() {
      let e2 = this._reporterState, r = e2.obj;
      return e2.obj = {}, r;
    };
    Rr.prototype.leaveObject = function(e2) {
      let r = this._reporterState, o = r.obj;
      return r.obj = e2, o;
    };
    Rr.prototype.error = function(e2) {
      let r, o = this._reporterState, f = e2 instanceof zf;
      if (f ? r = e2 : r = new zf(o.path.map(function(p) {
        return "[" + JSON.stringify(p) + "]";
      }).join(""), e2.message || e2, e2.stack), !o.options.partial)
        throw r;
      return f || o.errors.push(r), r;
    };
    Rr.prototype.wrapResult = function(e2) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e2) ? null : e2, errors: r.errors } : e2;
    };
    function zf(t, e2) {
      this.path = t, this.rethrow(e2);
    }
    aB(zf, Error);
    zf.prototype.rethrow = function(e2) {
      if (this.message = e2 + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Kf = T((rd) => {
    var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
    function Br(t, e2) {
      if (l0.call(this, e2), !Hf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    oB(Br, l0);
    rd.DecoderBuffer = Br;
    Br.isDecoderBuffer = function(e2) {
      return e2 instanceof Br ? true : typeof e2 == "object" && Hf.isBuffer(e2.base) && e2.constructor.name === "DecoderBuffer" && typeof e2.offset == "number" && typeof e2.length == "number" && typeof e2.save == "function" && typeof e2.restore == "function" && typeof e2.isEmpty == "function" && typeof e2.readUInt8 == "function" && typeof e2.skip == "function" && typeof e2.raw == "function";
    };
    Br.prototype.save = function() {
      return { offset: this.offset, reporter: l0.prototype.save.call(this) };
    };
    Br.prototype.restore = function(e2) {
      let r = new Br(this.base);
      return r.offset = e2.offset, r.length = this.offset, this.offset = e2.offset, l0.prototype.restore.call(this, e2.reporter), r;
    };
    Br.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    Br.prototype.readUInt8 = function(e2) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e2 || "DecoderBuffer overrun");
    };
    Br.prototype.skip = function(e2, r) {
      if (!(this.offset + e2 <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o = new Br(this.base);
      return o._reporterState = this._reporterState, o.offset = this.offset, o.length = this.offset + e2, this.offset += e2, o;
    };
    Br.prototype.raw = function(e2) {
      return this.base.slice(e2 ? e2.offset : this.offset, this.length);
    };
    function Wf(t, e2) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Wf.isEncoderBuffer(r) || (r = new Wf(r, e2)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e2.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = Hf.byteLength(t);
      else if (Hf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e2.error("Unsupported type: " + typeof t);
    }
    rd.EncoderBuffer = Wf;
    Wf.isEncoderBuffer = function(e2) {
      return e2 instanceof Wf ? true : typeof e2 == "object" && e2.constructor.name === "EncoderBuffer" && typeof e2.length == "number" && typeof e2.join == "function";
    };
    Wf.prototype.join = function(e2, r) {
      return e2 || (e2 = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o) {
        o.join(e2, r), r += o.length;
      }) : (typeof this.value == "number" ? e2[r] = this.value : typeof this.value == "string" ? e2.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e2, r), r += this.length)), e2;
    };
  });
  d0 = T((Qk, Py) => {
    var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt = ar(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e2, r) {
      let o = {};
      this._baseState = o, o.name = r, o.enc = t, o.parent = e2 || null, o.children = null, o.tag = null, o.args = null, o.reverseArgs = null, o.choice = null, o.optional = false, o.any = false, o.obj = false, o.use = null, o.useDecoder = null, o.key = null, o.default = null, o.explicit = null, o.implicit = null, o.contains = null, o.parent || (o.children = [], this._wrap());
    }
    Py.exports = Ue;
    var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e2 = this._baseState, r = {};
      cB.forEach(function(f) {
        r[f] = e2[f];
      });
      let o = new this.constructor(r.parent);
      return o._baseState = r, o;
    };
    Ue.prototype._wrap = function() {
      let e2 = this._baseState;
      lB.forEach(function(r) {
        this[r] = function() {
          let f = new this.constructor(this);
          return e2.children.push(f), f[r].apply(f, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e2) {
      let r = this._baseState;
      Qt(r.parent === null), e2.call(this), r.children = r.children.filter(function(o) {
        return o._baseState.parent === this;
      }, this), Qt.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e2) {
      let r = this._baseState, o = e2.filter(function(f) {
        return f instanceof this.constructor;
      }, this);
      e2 = e2.filter(function(f) {
        return !(f instanceof this.constructor);
      }, this), o.length !== 0 && (Qt(r.children === null), r.children = o, o.forEach(function(f) {
        f._baseState.parent = this;
      }, this)), e2.length !== 0 && (Qt(r.args === null), r.args = e2, r.reverseArgs = e2.map(function(f) {
        if (typeof f != "object" || f.constructor !== Object)
          return f;
        let p = {};
        return Object.keys(f).forEach(function(m) {
          m == (m | 0) && (m |= 0);
          let y = f[m];
          p[y] = m;
        }), p;
      }));
    };
    dB.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    Dy.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o = Array.prototype.slice.call(arguments);
        return Qt(r.tag === null), r.tag = t, this._useArgs(o), this;
      };
    });
    Ue.prototype.use = function(e2) {
      Qt(e2);
      let r = this._baseState;
      return Qt(r.use === null), r.use = e2, this;
    };
    Ue.prototype.optional = function() {
      let e2 = this._baseState;
      return e2.optional = true, this;
    };
    Ue.prototype.def = function(e2) {
      let r = this._baseState;
      return Qt(r.default === null), r.default = e2, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e2) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.explicit = e2, this;
    };
    Ue.prototype.implicit = function(e2) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.implicit = e2, this;
    };
    Ue.prototype.obj = function() {
      let e2 = this._baseState, r = Array.prototype.slice.call(arguments);
      return e2.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e2) {
      let r = this._baseState;
      return Qt(r.key === null), r.key = e2, this;
    };
    Ue.prototype.any = function() {
      let e2 = this._baseState;
      return e2.any = true, this;
    };
    Ue.prototype.choice = function(e2) {
      let r = this._baseState;
      return Qt(r.choice === null), r.choice = e2, this._useArgs(Object.keys(e2).map(function(o) {
        return e2[o];
      })), this;
    };
    Ue.prototype.contains = function(e2) {
      let r = this._baseState;
      return Qt(r.use === null), r.contains = e2, this;
    };
    Ue.prototype._decode = function(e2, r) {
      let o = this._baseState;
      if (o.parent === null)
        return e2.wrapResult(o.children[0]._decode(e2, r));
      let f = o.default, p = true, m = null;
      if (o.key !== null && (m = e2.enterKey(o.key)), o.optional) {
        let M = null;
        if (o.explicit !== null ? M = o.explicit : o.implicit !== null ? M = o.implicit : o.tag !== null && (M = o.tag), M === null && !o.any) {
          let x = e2.save();
          try {
            o.choice === null ? this._decodeGeneric(o.tag, e2, r) : this._decodeChoice(e2, r), p = true;
          } catch {
            p = false;
          }
          e2.restore(x);
        } else if (p = this._peekTag(e2, M, o.any), e2.isError(p))
          return p;
      }
      let y;
      if (o.obj && p && (y = e2.enterObject()), p) {
        if (o.explicit !== null) {
          let x = this._decodeTag(e2, o.explicit);
          if (e2.isError(x))
            return x;
          e2 = x;
        }
        let M = e2.offset;
        if (o.use === null && o.choice === null) {
          let x;
          o.any && (x = e2.save());
          let S = this._decodeTag(e2, o.implicit !== null ? o.implicit : o.tag, o.any);
          if (e2.isError(S))
            return S;
          o.any ? f = e2.raw(x) : e2 = S;
        }
        if (r && r.track && o.tag !== null && r.track(e2.path(), M, e2.length, "tagged"), r && r.track && o.tag !== null && r.track(e2.path(), e2.offset, e2.length, "content"), o.any || (o.choice === null ? f = this._decodeGeneric(o.tag, e2, r) : f = this._decodeChoice(e2, r)), e2.isError(f))
          return f;
        if (!o.any && o.choice === null && o.children !== null && o.children.forEach(function(S) {
          S._decode(e2, r);
        }), o.contains && (o.tag === "octstr" || o.tag === "bitstr")) {
          let x = new uB(f);
          f = this._getUse(o.contains, e2._reporterState.obj)._decode(x, r);
        }
      }
      return o.obj && p && (f = e2.leaveObject(y)), o.key !== null && (f !== null || p === true) ? e2.leaveKey(m, o.key, f) : m !== null && e2.exitKey(m), f;
    };
    Ue.prototype._decodeGeneric = function(e2, r, o) {
      let f = this._baseState;
      return e2 === "seq" || e2 === "set" ? null : e2 === "seqof" || e2 === "setof" ? this._decodeList(r, e2, f.args[0], o) : /str$/.test(e2) ? this._decodeStr(r, e2, o) : e2 === "objid" && f.args ? this._decodeObjid(r, f.args[0], f.args[1], o) : e2 === "objid" ? this._decodeObjid(r, null, null, o) : e2 === "gentime" || e2 === "utctime" ? this._decodeTime(r, e2, o) : e2 === "null_" ? this._decodeNull(r, o) : e2 === "bool" ? this._decodeBool(r, o) : e2 === "objDesc" ? this._decodeStr(r, e2, o) : e2 === "int" || e2 === "enum" ? this._decodeInt(r, f.args && f.args[0], o) : f.use !== null ? this._getUse(f.use, r._reporterState.obj)._decode(r, o) : r.error("unknown tag: " + e2);
    };
    Ue.prototype._getUse = function(e2, r) {
      let o = this._baseState;
      return o.useDecoder = this._use(e2, r), Qt(o.useDecoder._baseState.parent === null), o.useDecoder = o.useDecoder._baseState.children[0], o.implicit !== o.useDecoder._baseState.implicit && (o.useDecoder = o.useDecoder.clone(), o.useDecoder._baseState.implicit = o.implicit), o.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e2, r) {
      let o = this._baseState, f = null, p = false;
      return Object.keys(o.choice).some(function(m) {
        let y = e2.save(), M = o.choice[m];
        try {
          let x = M._decode(e2, r);
          if (e2.isError(x))
            return false;
          f = { type: m, value: x }, p = true;
        } catch {
          return e2.restore(y), false;
        }
        return true;
      }, this), p ? f : e2.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e2) {
      return new hB(e2, this.reporter);
    };
    Ue.prototype._encode = function(e2, r, o) {
      let f = this._baseState;
      if (f.default !== null && f.default === e2)
        return;
      let p = this._encodeValue(e2, r, o);
      if (p !== undefined && !this._skipDefault(p, r, o))
        return p;
    };
    Ue.prototype._encodeValue = function(e2, r, o) {
      let f = this._baseState;
      if (f.parent === null)
        return f.children[0]._encode(e2, r || new sB);
      let p = null;
      if (this.reporter = r, f.optional && e2 === undefined)
        if (f.default !== null)
          e2 = f.default;
        else
          return;
      let m = null, y = false;
      if (f.any)
        p = this._createEncoderBuffer(e2);
      else if (f.choice)
        p = this._encodeChoice(e2, r);
      else if (f.contains)
        m = this._getUse(f.contains, o)._encode(e2, r), y = true;
      else if (f.children)
        m = f.children.map(function(M) {
          if (M._baseState.tag === "null_")
            return M._encode(null, r, e2);
          if (M._baseState.key === null)
            return r.error("Child should have a key");
          let x = r.enterKey(M._baseState.key);
          if (typeof e2 != "object")
            return r.error("Child expected, but input is not object");
          let S = M._encode(e2[M._baseState.key], r, e2);
          return r.leaveKey(x), S;
        }, this).filter(function(M) {
          return M;
        }), m = this._createEncoderBuffer(m);
      else if (f.tag === "seqof" || f.tag === "setof") {
        if (!(f.args && f.args.length === 1))
          return r.error("Too many args for : " + f.tag);
        if (!Array.isArray(e2))
          return r.error("seqof/setof, but data is not Array");
        let M = this.clone();
        M._baseState.implicit = null, m = this._createEncoderBuffer(e2.map(function(x) {
          let S = this._baseState;
          return this._getUse(S.args[0], e2)._encode(x, r);
        }, M));
      } else
        f.use !== null ? p = this._getUse(f.use, o)._encode(e2, r) : (m = this._encodePrimitive(f.tag, e2), y = true);
      if (!f.any && f.choice === null) {
        let M = f.implicit !== null ? f.implicit : f.tag, x = f.implicit === null ? "universal" : "context";
        M === null ? f.use === null && r.error("Tag could be omitted only for .use()") : f.use === null && (p = this._encodeComposite(M, y, x, m));
      }
      return f.explicit !== null && (p = this._encodeComposite(f.explicit, false, "context", p)), p;
    };
    Ue.prototype._encodeChoice = function(e2, r) {
      let o = this._baseState, f = o.choice[e2.type];
      return f || Qt(false, e2.type + " not found in " + JSON.stringify(Object.keys(o.choice))), f._encode(e2.value, r);
    };
    Ue.prototype._encodePrimitive = function(e2, r) {
      let o = this._baseState;
      if (/str$/.test(e2))
        return this._encodeStr(r, e2);
      if (e2 === "objid" && o.args)
        return this._encodeObjid(r, o.reverseArgs[0], o.args[1]);
      if (e2 === "objid")
        return this._encodeObjid(r, null, null);
      if (e2 === "gentime" || e2 === "utctime")
        return this._encodeTime(r, e2);
      if (e2 === "null_")
        return this._encodeNull();
      if (e2 === "int" || e2 === "enum")
        return this._encodeInt(r, o.args && o.reverseArgs[0]);
      if (e2 === "bool")
        return this._encodeBool(r);
      if (e2 === "objDesc")
        return this._encodeStr(r, e2);
      throw new Error("Unsupported tag: " + e2);
    };
    Ue.prototype._isNumstr = function(e2) {
      return /^[0-9 ]*$/.test(e2);
    };
    Ue.prototype._isPrintstr = function(e2) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e2);
    };
  });
  c0 = T((Wn) => {
    function Cy(t) {
      let e2 = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o = t[r];
        e2[o] = r;
      }), e2;
    }
    Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    Wn.tagClassByName = Cy(Wn.tagClass);
    Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    Wn.tagByName = Cy(Wn.tag);
  });
  nd = T((tL, Uy) => {
    var pB = Ie(), Ii = h0().Buffer, Oy = d0(), id = c0();
    function Fy(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur, this.tree._init(t.body);
    }
    Uy.exports = Fy;
    Fy.prototype.encode = function(e2, r) {
      return this.tree._encode(e2, r).join();
    };
    function Ur(t) {
      Oy.call(this, "der", t);
    }
    pB(Ur, Oy);
    Ur.prototype._encodeComposite = function(e2, r, o, f) {
      let p = vB(e2, r, o, this.reporter);
      if (f.length < 128) {
        let M = Ii.alloc(2);
        return M[0] = p, M[1] = f.length, this._createEncoderBuffer([M, f]);
      }
      let m = 1;
      for (let M = f.length;M >= 256; M >>= 8)
        m++;
      let y = Ii.alloc(1 + 1 + m);
      y[0] = p, y[1] = 128 | m;
      for (let M = 1 + m, x = f.length;x > 0; M--, x >>= 8)
        y[M] = x & 255;
      return this._createEncoderBuffer([y, f]);
    };
    Ur.prototype._encodeStr = function(e2, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e2.unused | 0, e2.data]);
      if (r === "bmpstr") {
        let o = Ii.alloc(e2.length * 2);
        for (let f = 0;f < e2.length; f++)
          o.writeUInt16BE(e2.charCodeAt(f), f * 2);
        return this._createEncoderBuffer(o);
      } else
        return r === "numstr" ? this._isNumstr(e2) ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e2) ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e2) : r === "objDesc" ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur.prototype._encodeObjid = function(e2, r, o) {
      if (typeof e2 == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e2))
          return this.reporter.error("objid not found in values map");
        e2 = r[e2].split(/[\s.]+/g);
        for (let y = 0;y < e2.length; y++)
          e2[y] |= 0;
      } else if (Array.isArray(e2)) {
        e2 = e2.slice();
        for (let y = 0;y < e2.length; y++)
          e2[y] |= 0;
      }
      if (!Array.isArray(e2))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e2));
      if (!o) {
        if (e2[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e2.splice(0, 2, e2[0] * 40 + e2[1]);
      }
      let f = 0;
      for (let y = 0;y < e2.length; y++) {
        let M = e2[y];
        for (f++;M >= 128; M >>= 7)
          f++;
      }
      let p = Ii.alloc(f), m = p.length - 1;
      for (let y = e2.length - 1;y >= 0; y--) {
        let M = e2[y];
        for (p[m--] = M & 127;(M >>= 7) > 0; )
          p[m--] = 128 | M & 127;
      }
      return this._createEncoderBuffer(p);
    };
    function qr(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur.prototype._encodeTime = function(e2, r) {
      let o, f = new Date(e2);
      return r === "gentime" ? o = [qr(f.getUTCFullYear()), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o = [qr(f.getUTCFullYear() % 100), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o, "octstr");
    };
    Ur.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur.prototype._encodeInt = function(e2, r) {
      if (typeof e2 == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e2))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e2));
        e2 = r[e2];
      }
      if (typeof e2 != "number" && !Ii.isBuffer(e2)) {
        let p = e2.toArray();
        !e2.sign && p[0] & 128 && p.unshift(0), e2 = Ii.from(p);
      }
      if (Ii.isBuffer(e2)) {
        let p = e2.length;
        e2.length === 0 && p++;
        let m = Ii.alloc(p);
        return e2.copy(m), e2.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
      }
      if (e2 < 128)
        return this._createEncoderBuffer(e2);
      if (e2 < 256)
        return this._createEncoderBuffer([0, e2]);
      let o = 1;
      for (let p = e2;p >= 256; p >>= 8)
        o++;
      let f = new Array(o);
      for (let p = f.length - 1;p >= 0; p--)
        f[p] = e2 & 255, e2 >>= 8;
      return f[0] & 128 && f.unshift(0), this._createEncoderBuffer(Ii.from(f));
    };
    Ur.prototype._encodeBool = function(e2) {
      return this._createEncoderBuffer(e2 ? 255 : 0);
    };
    Ur.prototype._use = function(e2, r) {
      return typeof e2 == "function" && (e2 = e2(r)), e2._getEncoder("der").tree;
    };
    Ur.prototype._skipDefault = function(e2, r, o) {
      let f = this._baseState, p;
      if (f.default === null)
        return false;
      let m = e2.join();
      if (f.defaultBuffer === undefined && (f.defaultBuffer = this._encodeValue(f.default, r, o).join()), m.length !== f.defaultBuffer.length)
        return false;
      for (p = 0;p < m.length; p++)
        if (m[p] !== f.defaultBuffer[p])
          return false;
      return true;
    };
    function vB(t, e2, r, o) {
      let f;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
        f = id.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f = t;
      else
        return o.error("Unknown tag: " + t);
      return f >= 31 ? o.error("Multi-octet tag encoding unsupported") : (e2 || (f |= 32), f |= id.tagClassByName[r || "universal"] << 6, f);
    }
  });
  Hy = T((rL, zy) => {
    var bB = Ie(), fd = nd();
    function ad(t) {
      fd.call(this, t), this.enc = "pem";
    }
    bB(ad, fd);
    zy.exports = ad;
    ad.prototype.encode = function(e2, r) {
      let f = fd.prototype.encode.call(this, e2).toString("base64"), p = ["-----BEGIN " + r.label + "-----"];
      for (let m = 0;m < f.length; m += 64)
        p.push(f.slice(m, m + 64));
      return p.push("-----END " + r.label + "-----"), p.join(`
`);
    };
  });
  od = T((Ky) => {
    var Wy = Ky;
    Wy.der = nd();
    Wy.pem = Hy();
  });
  hd = T((nL, Yy) => {
    var mB = Ie(), gB = td(), jy = Kf().DecoderBuffer, Vy = d0(), Zy = c0();
    function $y(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    Yy.exports = $y;
    $y.prototype.decode = function(e2, r) {
      return jy.isDecoderBuffer(e2) || (e2 = new jy(e2, r)), this.tree._decode(e2, r);
    };
    function sr(t) {
      Vy.call(this, "der", t);
    }
    mB(sr, Vy);
    sr.prototype._peekTag = function(e2, r, o) {
      if (e2.isEmpty())
        return false;
      let f = e2.save(), p = sd(e2, 'Failed to peek tag: "' + r + '"');
      return e2.isError(p) ? p : (e2.restore(f), p.tag === r || p.tagStr === r || p.tagStr + "of" === r || o);
    };
    sr.prototype._decodeTag = function(e2, r, o) {
      let f = sd(e2, 'Failed to decode tag of "' + r + '"');
      if (e2.isError(f))
        return f;
      let p = Gy(e2, f.primitive, 'Failed to get length of "' + r + '"');
      if (e2.isError(p))
        return p;
      if (!o && f.tag !== r && f.tagStr !== r && f.tagStr + "of" !== r)
        return e2.error('Failed to match tag: "' + r + '"');
      if (f.primitive || p !== null)
        return e2.skip(p, 'Failed to match body of: "' + r + '"');
      let m = e2.save(), y = this._skipUntilEnd(e2, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e2.isError(y) ? y : (p = e2.offset - m.offset, e2.restore(m), e2.skip(p, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e2, r) {
      for (;; ) {
        let o = sd(e2, r);
        if (e2.isError(o))
          return o;
        let f = Gy(e2, o.primitive, r);
        if (e2.isError(f))
          return f;
        let p;
        if (o.primitive || f !== null ? p = e2.skip(f) : p = this._skipUntilEnd(e2, r), e2.isError(p))
          return p;
        if (o.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e2, r, o, f) {
      let p = [];
      for (;!e2.isEmpty(); ) {
        let m = this._peekTag(e2, "end");
        if (e2.isError(m))
          return m;
        let y = o.decode(e2, "der", f);
        if (e2.isError(y) && m)
          break;
        p.push(y);
      }
      return p;
    };
    sr.prototype._decodeStr = function(e2, r) {
      if (r === "bitstr") {
        let o = e2.readUInt8();
        return e2.isError(o) ? o : { unused: o, data: e2.raw() };
      } else if (r === "bmpstr") {
        let o = e2.raw();
        if (o.length % 2 === 1)
          return e2.error("Decoding of string type: bmpstr length mismatch");
        let f = "";
        for (let p = 0;p < o.length / 2; p++)
          f += String.fromCharCode(o.readUInt16BE(p * 2));
        return f;
      } else if (r === "numstr") {
        let o = e2.raw().toString("ascii");
        return this._isNumstr(o) ? o : e2.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e2.raw();
        if (r === "objDesc")
          return e2.raw();
        if (r === "printstr") {
          let o = e2.raw().toString("ascii");
          return this._isPrintstr(o) ? o : e2.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e2.raw().toString() : e2.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e2, r, o) {
      let f, p = [], m = 0, y = 0;
      for (;!e2.isEmpty(); )
        y = e2.readUInt8(), m <<= 7, m |= y & 127, (y & 128) === 0 && (p.push(m), m = 0);
      y & 128 && p.push(m);
      let M = p[0] / 40 | 0, x = p[0] % 40;
      if (o ? f = p : f = [M, x].concat(p.slice(1)), r) {
        let S = r[f.join(" ")];
        S === undefined && (S = r[f.join(".")]), S !== undefined && (f = S);
      }
      return f;
    };
    sr.prototype._decodeTime = function(e2, r) {
      let o = e2.raw().toString(), f, p, m, y, M, x;
      if (r === "gentime")
        f = o.slice(0, 4) | 0, p = o.slice(4, 6) | 0, m = o.slice(6, 8) | 0, y = o.slice(8, 10) | 0, M = o.slice(10, 12) | 0, x = o.slice(12, 14) | 0;
      else if (r === "utctime")
        f = o.slice(0, 2) | 0, p = o.slice(2, 4) | 0, m = o.slice(4, 6) | 0, y = o.slice(6, 8) | 0, M = o.slice(8, 10) | 0, x = o.slice(10, 12) | 0, f < 70 ? f = 2000 + f : f = 1900 + f;
      else
        return e2.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f, p - 1, m, y, M, x, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e2) {
      let r = e2.readUInt8();
      return e2.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e2, r) {
      let o = e2.raw(), f = new gB(o);
      return r && (f = r[f.toString(10)] || f), f;
    };
    sr.prototype._use = function(e2, r) {
      return typeof e2 == "function" && (e2 = e2(r)), e2._getDecoder("der").tree;
    };
    function sd(t, e2) {
      let r = t.readUInt8(e2);
      if (t.isError(r))
        return r;
      let o = Zy.tagClass[r >> 6], f = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m = r;
        for (r = 0;(m & 128) === 128; ) {
          if (m = t.readUInt8(e2), t.isError(m))
            return m;
          r <<= 7, r |= m & 127;
        }
      } else
        r &= 31;
      let p = Zy.tag[r];
      return { cls: o, primitive: f, tag: r, tagStr: p };
    }
    function Gy(t, e2, r) {
      let o = t.readUInt8(r);
      if (t.isError(o))
        return o;
      if (!e2 && o === 128)
        return null;
      if ((o & 128) === 0)
        return o;
      let f = o & 127;
      if (f > 4)
        return t.error("length octect is too long");
      o = 0;
      for (let p = 0;p < f; p++) {
        o <<= 8;
        let m = t.readUInt8(r);
        if (t.isError(m))
          return m;
        o |= m;
      }
      return o;
    }
  });
  Jy = T((fL, Xy) => {
    var yB = Ie(), wB = h0().Buffer, ud = hd();
    function ld(t) {
      ud.call(this, t), this.enc = "pem";
    }
    yB(ld, ud);
    Xy.exports = ld;
    ld.prototype.decode = function(e2, r) {
      let o = e2.toString().split(/[\r\n]+/g), f = r.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/, m = -1, y = -1;
      for (let S = 0;S < o.length; S++) {
        let E = o[S].match(p);
        if (E !== null && E[2] === f)
          if (m === -1) {
            if (E[1] !== "BEGIN")
              break;
            m = S;
          } else {
            if (E[1] !== "END")
              break;
            y = S;
            break;
          }
      }
      if (m === -1 || y === -1)
        throw new Error("PEM section not found for: " + f);
      let M = o.slice(m + 1, y).join("");
      M.replace(/[^a-z0-9+/=]+/gi, "");
      let x = wB.from(M, "base64");
      return ud.prototype.decode.call(this, x, r);
    };
  });
  dd = T((e3) => {
    var Qy = e3;
    Qy.der = hd();
    Qy.pem = Jy();
  });
  r3 = T((t3) => {
    var MB = od(), _B = dd(), xB = Ie(), SB = t3;
    SB.define = function(e2, r) {
      return new jf(e2, r);
    };
    function jf(t, e2) {
      this.name = t, this.body = e2, this.decoders = {}, this.encoders = {};
    }
    jf.prototype._createNamed = function(e2) {
      let r = this.name;
      function o(f) {
        this._initNamed(f, r);
      }
      return xB(o, e2), o.prototype._initNamed = function(p, m) {
        e2.call(this, p, m);
      }, new o(this);
    };
    jf.prototype._getDecoder = function(e2) {
      return e2 = e2 || "der", this.decoders.hasOwnProperty(e2) || (this.decoders[e2] = this._createNamed(_B[e2])), this.decoders[e2];
    };
    jf.prototype.decode = function(e2, r, o) {
      return this._getDecoder(r).decode(e2, o);
    };
    jf.prototype._getEncoder = function(e2) {
      return e2 = e2 || "der", this.encoders.hasOwnProperty(e2) || (this.encoders[e2] = this._createNamed(MB[e2])), this.encoders[e2];
    };
    jf.prototype.encode = function(e2, r, o) {
      return this._getEncoder(r).encode(e2, o);
    };
  });
  n3 = T((i3) => {
    var p0 = i3;
    p0.Reporter = u0().Reporter;
    p0.DecoderBuffer = Kf().DecoderBuffer;
    p0.EncoderBuffer = Kf().EncoderBuffer;
    p0.Node = d0();
  });
  o3 = T((a3) => {
    var f3 = a3;
    f3._reverse = function(e2) {
      let r = {};
      return Object.keys(e2).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        let f = e2[o];
        r[f] = o;
      }), r;
    };
    f3.der = c0();
  });
  cd = T((s3) => {
    var Zf = s3;
    Zf.bignum = td();
    Zf.define = r3().define;
    Zf.base = n3();
    Zf.constants = o3();
    Zf.decoders = dd();
    Zf.encoders = od();
  });
  d3 = T((lL, l3) => {
    var zr = cd(), h3 = zr.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), EB = zr.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), pd = zr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), AB = zr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
    }), RB = zr.define("RelativeDistinguishedName", function() {
      this.setof(EB);
    }), BB = zr.define("RDNSequence", function() {
      this.seqof(RB);
    }), u3 = zr.define("Name", function() {
      this.choice({ rdnSequence: this.use(BB) });
    }), qB = zr.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(h3), this.key("notAfter").use(h3));
    }), IB = zr.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TB = zr.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
    }), kB = zr.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
    });
    l3.exports = kB;
  });
  p3 = T((Wr) => {
    var Hr = cd();
    Wr.certificate = d3();
    var LB = Hr.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = LB;
    var NB = Hr.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = NB;
    var DB = Hr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = DB;
    var c3 = Hr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PB = Hr.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = PB;
    var CB = Hr.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = CB;
    var OB = Hr.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = OB;
    Wr.DSAparam = Hr.define("DSAparam", function() {
      this.int();
    });
    var FB = Hr.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = FB;
    var UB = Hr.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  v3 = T((cL, zB) => {
    zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  m3 = T((pL, b3) => {
    var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
    b3.exports = function(t, e2) {
      var r = t.toString(), o = r.match(HB), f;
      if (o) {
        var m = "aes" + o[1], y = v0.from(o[2], "hex"), M = v0.from(o[3].replace(/[\r\n]/g, ""), "base64"), x = jB(e2, y.slice(0, 8), parseInt(o[1], 10)).key, S = [], E = ZB.createDecipheriv(m, x, y);
        S.push(E.update(M)), S.push(E.final()), f = v0.concat(S);
      } else {
        var p = r.match(KB);
        f = v0.from(p[2].replace(/[\r\n]/g, ""), "base64");
      }
      var B = r.match(WB)[1];
      return { tag: B, data: f };
    };
  });
  Ha = T((vL, y3) => {
    var fr = p3(), VB = v3(), $B = m3(), GB = Es(), YB = Iu(), vd = Te().Buffer;
    y3.exports = g3;
    function g3(t) {
      var e2;
      typeof t == "object" && !vd.isBuffer(t) && (e2 = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
      var r = $B(t, e2), o = r.tag, f = r.data, p, m;
      switch (o) {
        case "CERTIFICATE":
          m = fr.certificate.decode(f, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m || (m = fr.PublicKey.decode(f, "der")), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m.subjectPrivateKey = m.subjectPublicKey, { type: "ec", data: m };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.pub_key = fr.DSAparam.decode(m.subjectPublicKey.data, "der"), { type: "dsa", data: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "ENCRYPTED PRIVATE KEY":
          f = fr.EncryptedPrivateKey.decode(f, "der"), f = XB(f, e2);
        case "PRIVATE KEY":
          switch (m = fr.PrivateKey.decode(f, "der"), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.priv_key = fr.DSAparam.decode(m.subjectPrivateKey, "der"), { type: "dsa", params: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f, "der") };
        case "EC PRIVATE KEY":
          return f = fr.ECPrivateKey.decode(f, "der"), { curve: f.parameters.value, privateKey: f.privateKey };
        default:
          throw new Error("unknown key type " + o);
      }
    }
    g3.signature = fr.signature;
    function XB(t, e2) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f = VB[t.algorithm.decrypt.cipher.algo.join(".")], p = t.algorithm.decrypt.cipher.iv, m = t.subjectPrivateKey, y = parseInt(f.split("-")[1], 10) / 8, M = YB.pbkdf2Sync(e2, r, o, y, "sha1"), x = GB.createDecipheriv(f, M, p), S = [];
      return S.push(x.update(m)), S.push(x.final()), vd.concat(S);
    }
  });
  bd = T((bL, JB) => {
    JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  _3 = T((mL, m0) => {
    var Yt = Te().Buffer, Kn = wu(), QB = Ks(), eq = o0().ec, b0 = Ws(), tq = Ha(), rq = bd();
    function iq(t, e2, r, o, f) {
      var p = tq(e2);
      if (p.curve) {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return nq(t, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong private key type");
        return fq(t, p, r);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f, t]);
      for (var m = p.modulus.byteLength(), y = [0, 1];t.length + y.length + 1 < m; )
        y.push(255);
      y.push(0);
      for (var M = -1;++M < t.length; )
        y.push(t[M]);
      var x = QB(y, p);
      return x;
    }
    function nq(t, e2) {
      var r = rq[e2.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e2.curve.join("."));
      var o = new eq(r), f = o.keyFromPrivate(e2.privateKey), p = f.sign(t);
      return Yt.from(p.toDER());
    }
    function fq(t, e2, r) {
      for (var o = e2.params.priv_key, f = e2.params.p, p = e2.params.q, m = e2.params.g, y = new b0(0), M, x = md(t, p).mod(p), S = false, E = w3(o, p, t, r);S === false; )
        M = M3(p, E, r), y = sq(m, M, f, p), S = M.invm(p).imul(x.add(o.mul(y))).mod(p), S.cmpn(0) === 0 && (S = false, y = new b0(0));
      return aq(y, S);
    }
    function aq(t, e2) {
      t = t.toArray(), e2 = e2.toArray(), t[0] & 128 && (t = [0].concat(t)), e2[0] & 128 && (e2 = [0].concat(e2));
      var r = t.length + e2.length + 4, o = [48, r, 2, t.length];
      return o = o.concat(t, [2, e2.length], e2), Yt.from(o);
    }
    function w3(t, e2, r, o) {
      if (t = Yt.from(t.toArray()), t.length < e2.byteLength()) {
        var f = Yt.alloc(e2.byteLength() - t.length);
        t = Yt.concat([f, t]);
      }
      var p = r.length, m = oq(r, e2), y = Yt.alloc(p);
      y.fill(1);
      var M = Yt.alloc(p);
      return M = Kn(o, M).update(y).update(Yt.from([0])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), M = Kn(o, M).update(y).update(Yt.from([1])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), { k: M, v: y };
    }
    function md(t, e2) {
      var r = new b0(t), o = (t.length << 3) - e2.bitLength();
      return o > 0 && r.ishrn(o), r;
    }
    function oq(t, e2) {
      t = md(t, e2), t = t.mod(e2);
      var r = Yt.from(t.toArray());
      if (r.length < e2.byteLength()) {
        var o = Yt.alloc(e2.byteLength() - r.length);
        r = Yt.concat([o, r]);
      }
      return r;
    }
    function M3(t, e2, r) {
      var o, f;
      do {
        for (o = Yt.alloc(0);o.length * 8 < t.bitLength(); )
          e2.v = Kn(r, e2.k).update(e2.v).digest(), o = Yt.concat([o, e2.v]);
        f = md(o, t), e2.k = Kn(r, e2.k).update(e2.v).update(Yt.from([0])).digest(), e2.v = Kn(r, e2.k).update(e2.v).digest();
      } while (f.cmp(t) !== -1);
      return f;
    }
    function sq(t, e2, r, o) {
      return t.toRed(b0.mont(r)).redPow(e2).fromRed().mod(o);
    }
    m0.exports = iq;
    m0.exports.getKey = w3;
    m0.exports.makeKey = M3;
  });
  A3 = T((gL, E3) => {
    var gd = Te().Buffer, Wa = Ws(), hq = o0().ec, S3 = Ha(), uq = bd();
    function lq(t, e2, r, o, f) {
      var p = S3(r);
      if (p.type === "ec") {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return dq(t, e2, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong public key type");
        return cq(t, e2, p);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e2 = gd.concat([f, e2]);
      for (var m = p.modulus.byteLength(), y = [1], M = 0;e2.length + y.length + 2 < m; )
        y.push(255), M++;
      y.push(0);
      for (var x = -1;++x < e2.length; )
        y.push(e2[x]);
      y = gd.from(y);
      var S = Wa.mont(p.modulus);
      t = new Wa(t).toRed(S), t = t.redPow(new Wa(p.publicExponent)), t = gd.from(t.fromRed().toArray());
      var E = M < 8 ? 1 : 0;
      for (m = Math.min(t.length, y.length), t.length !== y.length && (E = 1), x = -1;++x < m; )
        E |= t[x] ^ y[x];
      return E === 0;
    }
    function dq(t, e2, r) {
      var o = uq[r.data.algorithm.curve.join(".")];
      if (!o)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f = new hq(o), p = r.data.subjectPrivateKey.data;
      return f.verify(e2, t, p);
    }
    function cq(t, e2, r) {
      var o = r.data.p, f = r.data.q, p = r.data.g, m = r.data.pub_key, y = S3.signature.decode(t, "der"), M = y.s, x = y.r;
      x3(M, f), x3(x, f);
      var S = Wa.mont(o), E = M.invm(f), B = p.toRed(S).redPow(new Wa(e2).mul(E).mod(f)).fromRed().mul(m.toRed(S).redPow(x.mul(E).mod(f)).fromRed()).mod(o).mod(f);
      return B.cmp(x) === 0;
    }
    function x3(t, e2) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e2) >= e2)
        throw new Error("invalid sig");
    }
    E3.exports = lq;
  });
  k3 = T((yL, T3) => {
    var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I3 = Ie(), pq = _3(), vq = A3(), jn = Mu();
    Object.keys(jn).forEach(function(t) {
      jn[t].id = g0.from(jn[t].id, "hex"), jn[t.toLowerCase()] = jn[t];
    });
    function Ka(t) {
      y0.Writable.call(this);
      var e2 = jn[t];
      if (!e2)
        throw new Error("Unknown message digest");
      this._hashType = e2.hash, this._hash = q3(e2.hash), this._tag = e2.id, this._signType = e2.sign;
    }
    I3(Ka, y0.Writable);
    Ka.prototype._write = function(e2, r, o) {
      this._hash.update(e2), o();
    };
    Ka.prototype.update = function(e2, r) {
      return typeof e2 == "string" && (e2 = g0.from(e2, r)), this._hash.update(e2), this;
    };
    Ka.prototype.sign = function(e2, r) {
      this.end();
      var o = this._hash.digest(), f = pq(o, e2, this._hashType, this._signType, this._tag);
      return r ? f.toString(r) : f;
    };
    function ja(t) {
      y0.Writable.call(this);
      var e2 = jn[t];
      if (!e2)
        throw new Error("Unknown message digest");
      this._hash = q3(e2.hash), this._tag = e2.id, this._signType = e2.sign;
    }
    I3(ja, y0.Writable);
    ja.prototype._write = function(e2, r, o) {
      this._hash.update(e2), o();
    };
    ja.prototype.update = function(e2, r) {
      return typeof e2 == "string" && (e2 = g0.from(e2, r)), this._hash.update(e2), this;
    };
    ja.prototype.verify = function(e2, r, o) {
      typeof r == "string" && (r = g0.from(r, o)), this.end();
      var f = this._hash.digest();
      return vq(r, f, e2, this._signType, this._tag);
    };
    function R3(t) {
      return new Ka(t);
    }
    function B3(t) {
      return new ja(t);
    }
    T3.exports = { Sign: R3, Verify: B3, createSign: R3, createVerify: B3 };
  });
  N3 = T((L3, yd) => {
    (function(t, e2) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e2.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q3) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q3) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q3) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q3) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q3) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q3) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q3) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q3) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q3) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q3) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q3) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q3) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q3) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q3) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q3) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q3), n = Math.imul(G, ee), n = n + Math.imul(Y, Q3) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P5(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P5(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P5.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P5.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P5.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P5.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P5.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P5.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P5.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P5.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P5.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P5.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P5.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P5.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P5.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P5.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P5.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P5.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P5.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P5.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P5.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P5), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof yd > "u" || yd, L3);
  });
  P32 = T((wL, D3) => {
    var bq = o0(), mq = N3();
    D3.exports = function(e2) {
      return new Zn(e2);
    };
    var hr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr.p224 = hr.secp224r1;
    hr.p256 = hr.secp256r1 = hr.prime256v1;
    hr.p192 = hr.secp192r1 = hr.prime192v1;
    hr.p384 = hr.secp384r1;
    hr.p521 = hr.secp521r1;
    function Zn(t) {
      this.curveType = hr[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
    }
    Zn.prototype.generateKeys = function(t, e2) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e2);
    };
    Zn.prototype.computeSecret = function(t, e2, r) {
      e2 = e2 || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e2));
      var o = this.curve.keyFromPublic(t).getPublic(), f = o.mul(this.keys.getPrivate()).getX();
      return wd(f, r, this.curveType.byteLength);
    };
    Zn.prototype.getPublicKey = function(t, e2) {
      var r = this.keys.getPublic(e2 === "compressed", true);
      return e2 === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
    };
    Zn.prototype.getPrivateKey = function(t) {
      return wd(this.keys.getPrivate(), t);
    };
    Zn.prototype.setPublicKey = function(t, e2) {
      return e2 = e2 || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e2)), this.keys._importPublic(t), this;
    };
    Zn.prototype.setPrivateKey = function(t, e2) {
      e2 = e2 || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e2));
      var r = new mq(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function wd(t, e2, r) {
      Array.isArray(t) || (t = t.toArray());
      var o = new Buffer(t);
      if (r && o.length < r) {
        var f = new Buffer(r - o.length);
        f.fill(0), o = Buffer.concat([f, o]);
      }
      return e2 ? o.toString(e2) : o;
    }
  });
  _d = T((ML, C3) => {
    var gq = bf(), Md = Te().Buffer;
    C3.exports = function(t, e2) {
      for (var r = Md.alloc(0), o = 0, f;r.length < e2; )
        f = yq(o++), r = Md.concat([r, gq("sha1").update(t).update(f).digest()]);
      return r.slice(0, e2);
    };
    function yq(t) {
      var e2 = Md.allocUnsafe(4);
      return e2.writeUInt32BE(t, 0), e2;
    }
  });
  xd = T((_L, O3) => {
    O3.exports = function(e2, r) {
      for (var o = e2.length, f = -1;++f < o; )
        e2[f] ^= r[f];
      return e2;
    };
  });
  w0 = T((F3, Sd) => {
    (function(t, e2) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e2.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q3) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q3) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q3) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q3) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q3) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q3) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q3) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q3) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q3) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q3) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q3) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q3) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q3) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q3) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q3) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q3), n = Math.imul(G, ee), n = n + Math.imul(Y, Q3) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P5(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P5(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P5.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P5.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P5.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P5.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P5.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P5.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P5.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P5.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P5.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P5.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P5.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P5.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P5.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P5.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P5.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P5.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P5.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P5.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P5.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P5), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Sd > "u" || Sd, F3);
  });
  Ed = T((xL, z3) => {
    var U3 = w0(), wq = Te().Buffer;
    function Mq(t, e2) {
      return wq.from(t.toRed(U3.mont(e2.modulus)).redPow(new U3(e2.publicExponent)).fromRed().toArray());
    }
    z3.exports = Mq;
  });
  j3 = T((SL, K3) => {
    var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd(), Rd = w0(), Sq = Ed(), Eq = Ks(), Kr = Te().Buffer;
    K3.exports = function(e2, r, o) {
      var f;
      e2.padding ? f = e2.padding : o ? f = 1 : f = 4;
      var p = _q(e2), m;
      if (f === 4)
        m = Aq(p, r);
      else if (f === 1)
        m = Rq(p, r, o);
      else if (f === 3) {
        if (m = new Rd(r), m.cmp(p.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o ? Eq(m, p) : Sq(m, p);
    };
    function Aq(t, e2) {
      var r = t.modulus.byteLength(), o = e2.length, f = xq("sha1").update(Kr.alloc(0)).digest(), p = f.length, m = 2 * p;
      if (o > r - m - 2)
        throw new Error("message too long");
      var y = Kr.alloc(r - o - m - 2), M = r - p - 1, x = Ad(p), S = W3(Kr.concat([f, y, Kr.alloc(1, 1), e2], M), H3(x, M)), E = W3(x, H3(S, p));
      return new Rd(Kr.concat([Kr.alloc(1), E, S], r));
    }
    function Rq(t, e2, r) {
      var o = e2.length, f = t.modulus.byteLength();
      if (o > f - 11)
        throw new Error("message too long");
      var p;
      return r ? p = Kr.alloc(f - o - 3, 255) : p = Bq(f - o - 3), new Rd(Kr.concat([Kr.from([0, r ? 1 : 2]), p, Kr.alloc(1), e2], f));
    }
    function Bq(t) {
      for (var e2 = Kr.allocUnsafe(t), r = 0, o = Ad(t * 2), f = 0, p;r < t; )
        f === o.length && (o = Ad(t * 2), f = 0), p = o[f++], p && (e2[r++] = p);
      return e2;
    }
  });
  Y3 = T((EL, G3) => {
    var qq = Ha(), Z3 = _d(), V3 = xd(), $3 = w0(), Iq = Ks(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
    G3.exports = function(e2, r, o) {
      var f;
      e2.padding ? f = e2.padding : o ? f = 1 : f = 4;
      var p = qq(e2), m = p.modulus.byteLength();
      if (r.length > m || new $3(r).cmp(p.modulus) >= 0)
        throw new Error("decryption error");
      var y;
      o ? y = kq(new $3(r), p) : y = Iq(r, p);
      var M = Za.alloc(m - y.length);
      if (y = Za.concat([M, y], m), f === 4)
        return Lq(p, y);
      if (f === 1)
        return Nq(p, y, o);
      if (f === 3)
        return y;
      throw new Error("unknown padding");
    };
    function Lq(t, e2) {
      var r = t.modulus.byteLength(), o = Tq("sha1").update(Za.alloc(0)).digest(), f = o.length;
      if (e2[0] !== 0)
        throw new Error("decryption error");
      var p = e2.slice(1, f + 1), m = e2.slice(f + 1), y = V3(p, Z3(m, f)), M = V3(m, Z3(y, r - f - 1));
      if (Dq(o, M.slice(0, f)))
        throw new Error("decryption error");
      for (var x = f;M[x] === 0; )
        x++;
      if (M[x++] !== 1)
        throw new Error("decryption error");
      return M.slice(x);
    }
    function Nq(t, e2, r) {
      for (var o = e2.slice(0, 2), f = 2, p = 0;e2[f++] !== 0; )
        if (f >= e2.length) {
          p++;
          break;
        }
      var m = e2.slice(2, f - 1);
      if ((o.toString("hex") !== "0002" && !r || o.toString("hex") !== "0001" && r) && p++, m.length < 8 && p++, p)
        throw new Error("decryption error");
      return e2.slice(f);
    }
    function Dq(t, e2) {
      t = Za.from(t), e2 = Za.from(e2);
      var r = 0, o = t.length;
      t.length !== e2.length && (r++, o = Math.min(t.length, e2.length));
      for (var f = -1;++f < o; )
        r += t[f] ^ e2[f];
      return r;
    }
  });
  X3 = T((Vn) => {
    Vn.publicEncrypt = j3();
    Vn.privateDecrypt = Y3();
    Vn.privateEncrypt = function(e2, r) {
      return Vn.publicEncrypt(e2, r, true);
    };
    Vn.publicDecrypt = function(e2, r) {
      return Vn.privateDecrypt(e2, r, true);
    };
  });
  ow = T((Va) => {
    function J3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var ew = Te(), Q3 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
    function nw(t, e2) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > iw || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > rw || t > e2)
        throw new RangeError("offset out of range");
    }
    function fw(t, e2, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > iw || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e2 > r || t > rw)
        throw new RangeError("buffer too small");
    }
    Bd && Bd.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
    function Pq(t, e2, r, o) {
      if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e2 == "function")
        o = e2, e2 = 0, r = t.length;
      else if (typeof r == "function")
        o = r, r = t.length - e2;
      else if (typeof o != "function")
        throw new TypeError('"cb" argument must be a function');
      return nw(e2, t.length), fw(r, e2, t.length), aw(t, e2, r, o);
    }
    function aw(t, e2, r, o) {
      if (true) {
        var f = t.buffer, p = new Uint8Array(f, e2, r);
        if (Bd.getRandomValues(p), o) {
          process.nextTick(function() {
            o(null, t);
          });
          return;
        }
        return t;
      }
      if (o) {
        Q3(r, function(y, M) {
          if (y)
            return o(y);
          M.copy(t, e2), o(null, t);
        });
        return;
      }
      var m = Q3(r);
      return m.copy(t, e2), t;
    }
    function Cq(t, e2, r) {
      if (typeof e2 > "u" && (e2 = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return nw(e2, t.length), r === undefined && (r = t.length - e2), fw(r, e2, t.length), aw(t, e2, r);
    }
  });
  qd = T((ke) => {
    ke.randomBytes = ke.rng = ke.pseudoRandomBytes = ke.prng = on();
    ke.createHash = ke.Hash = bf();
    ke.createHmac = ke.Hmac = wu();
    var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
    ke.getHashes = function() {
      return Uq;
    };
    var sw = Iu();
    ke.pbkdf2 = sw.pbkdf2;
    ke.pbkdf2Sync = sw.pbkdf2Sync;
    var ui = Vm();
    ke.Cipher = ui.Cipher;
    ke.createCipher = ui.createCipher;
    ke.Cipheriv = ui.Cipheriv;
    ke.createCipheriv = ui.createCipheriv;
    ke.Decipher = ui.Decipher;
    ke.createDecipher = ui.createDecipher;
    ke.Decipheriv = ui.Decipheriv;
    ke.createDecipheriv = ui.createDecipheriv;
    ke.getCiphers = ui.getCiphers;
    ke.listCiphers = ui.listCiphers;
    var $a = hg();
    ke.DiffieHellmanGroup = $a.DiffieHellmanGroup;
    ke.createDiffieHellmanGroup = $a.createDiffieHellmanGroup;
    ke.getDiffieHellman = $a.getDiffieHellman;
    ke.createDiffieHellman = $a.createDiffieHellman;
    ke.DiffieHellman = $a.DiffieHellman;
    var M0 = k3();
    ke.createSign = M0.createSign;
    ke.Sign = M0.Sign;
    ke.createVerify = M0.createVerify;
    ke.Verify = M0.Verify;
    ke.createECDH = P32();
    var _0 = X3();
    ke.publicEncrypt = _0.publicEncrypt;
    ke.privateEncrypt = _0.privateEncrypt;
    ke.publicDecrypt = _0.publicDecrypt;
    ke.privateDecrypt = _0.privateDecrypt;
    var hw = ow();
    ke.randomFill = hw.randomFill;
    ke.randomFillSync = hw.randomFillSync;
    ke.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt = {};
  Ja(Xt, { DEFAULT_ENCODING: () => Ga, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td, scryptSync: () => Id, timingSafeEqual: () => x0, webcrypto: () => cw });
  ot(Xt, rn(qd()));
  zq = rn(qd());
  Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  x0 = "timingSafeEqual" in crypto ? (t, e2) => {
    let { byteLength: r } = t, { byteLength: o } = e2;
    if (typeof r != "number" || typeof o != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e2);
  } : undefined;
  Id = "scryptSync" in crypto ? (t, e2, r, o) => {
    let f = crypto.scryptSync(t, e2, r, o);
    return Ga !== "buffer" ? new Buffer(f).toString(Ga) : new Buffer(f);
  } : undefined;
  Td = "scryptSync" in crypto ? function(t, e2, r, o, f) {
    if (typeof o == "function" && (f = o, o = undefined), typeof f != "function") {
      var p = new TypeError("callback must be a function");
      throw p.code = "ERR_INVALID_CALLBACK", p;
    }
    try {
      let m = crypto.scryptSync(t, e2, r, o);
      process.nextTick(f, null, Ga !== "buffer" ? new Buffer(m).toString(Ga) : new Buffer(m));
    } catch (m) {
      throw m;
    }
  } : undefined;
  x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td, "name", { value: "::bunternal::" }), Object.defineProperty(Id, "name", { value: "::bunternal::" }));
  cw = crypto;
  Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id, scrypt: Td, webcrypto: cw, getCurves: dw };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS((exports, module) => {
  (function(global2, pool, math) {
    var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten2(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
        if (state) {
          if (state.S) {
            copy(state, arc4);
          }
          prng2.state = function() {
            return copy(arc4, {});
          };
        }
        if (is_math_call) {
          math[rngname] = prng2;
          return seed2;
        } else
          return prng2;
      })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
    }
    function ARC4(key) {
      var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0;i < width; i++) {
        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
        s[j] = t;
      }
      (me.g = function(count) {
        var t3, r = 0, i3 = me.i, j2 = me.j, s3 = me.S;
        while (count--) {
          t3 = s3[i3 = mask & i3 + 1];
          r = r * width + s3[mask & (s3[i3] = s3[j2 = mask & j2 + t3]) + (s3[j2] = t3)];
        }
        me.i = i3;
        me.j = j2;
        return r;
      })(width);
    }
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    function flatten2(obj, depth) {
      var result = [], typ = typeof obj, prop;
      if (depth && typ == "object") {
        for (prop in obj) {
          try {
            result.push(flatten2(obj[prop], depth - 1));
          } catch (e2) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj : obj + "\x00";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e2) {
        var browser = global2.navigator, plugins = browser && browser.plugins;
        return [+new Date, global2, plugins, global2.screen, tostring(pool)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(math.random(), pool);
    if (typeof module == "object" && module.exports) {
      module.exports = seedrandom;
      try {
        nodecrypto = (init_crypto(), __toCommonJS(exports_crypto));
      } catch (ex) {
      }
    } else if (typeof define == "function" && define.amd) {
      define(function() {
        return seedrandom;
      });
    } else {
      math["seed" + rngname] = seedrandom;
    }
  })(typeof self !== "undefined" ? self : exports, [], Math);
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS((exports, module) => {
  var alea = require_alea();
  var xor128 = require_xor128();
  var xorwow = require_xorwow();
  var xorshift7 = require_xorshift7();
  var xor4096 = require_xor4096();
  var tychei = require_tychei();
  var sr = require_seedrandom();
  sr.alea = alea;
  sr.xor128 = xor128;
  sr.xorwow = xorwow;
  sr.xorshift7 = xorshift7;
  sr.xor4096 = xor4096;
  sr.tychei = tychei;
  module.exports = sr;
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1;e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/mathjs/lib/esm/core/config.js
var DEFAULT_CONFIG = {
  relTol: 0.000000000001,
  absTol: 0.000000000000001,
  matrix: "Matrix",
  number: "number",
  numberFallback: "number",
  precision: 64,
  predictable: false,
  randomSeed: null
};

// node_modules/mathjs/lib/esm/utils/customs.js
function getSafeProperty(object, prop) {
  if (isSafeProperty(object, prop)) {
    return object[prop];
  }
  if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object, prop, value) {
  if (isSafeProperty(object, prop)) {
    object[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function isSafeProperty(object, prop) {
  if (!isPlainObject(object) && !Array.isArray(object)) {
    return false;
  }
  if (hasOwnProperty(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function getSafeMethod(object, method) {
  if (!isSafeMethod(object, method)) {
    throw new Error('No access to method "' + method + '"');
  }
  return object[method];
}
function isSafeMethod(object, method) {
  if (object === null || object === undefined || typeof object[method] !== "function") {
    return false;
  }
  if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
    return false;
  }
  if (hasOwnProperty(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject(object) {
  return typeof object === "object" && object && object.constructor === Object;
}
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};

// node_modules/mathjs/lib/esm/utils/map.js
class ObjectWrappingMap {
  constructor(object) {
    this.wrappedObject = object;
    this[Symbol.iterator] = this.entries;
  }
  keys() {
    return Object.keys(this.wrappedObject).filter((key) => this.has(key)).values();
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return isSafeProperty(this.wrappedObject, key) && key in this.wrappedObject;
  }
  entries() {
    return mapIterator(this.keys(), (key) => [key, this.get(key)]);
  }
  forEach(callback) {
    for (var key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    if (isSafeProperty(this.wrappedObject, key)) {
      delete this.wrappedObject[key];
    }
  }
  clear() {
    for (var key of this.keys()) {
      this.delete(key);
    }
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
}

class PartitionedMap {
  constructor(a, b, bKeys) {
    this.a = a;
    this.b = b;
    this.bKeys = bKeys;
    this[Symbol.iterator] = this.entries;
  }
  get(key) {
    return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);
  }
  set(key, value) {
    if (this.bKeys.has(key)) {
      this.b.set(key, value);
    } else {
      this.a.set(key, value);
    }
    return this;
  }
  has(key) {
    return this.b.has(key) || this.a.has(key);
  }
  keys() {
    return new Set([...this.a.keys(), ...this.b.keys()])[Symbol.iterator]();
  }
  entries() {
    return mapIterator(this.keys(), (key) => [key, this.get(key)]);
  }
  forEach(callback) {
    for (var key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    return this.bKeys.has(key) ? this.b.delete(key) : this.a.delete(key);
  }
  clear() {
    this.a.clear();
    this.b.clear();
  }
  get size() {
    return [...this.keys()].length;
  }
}
function mapIterator(it, callback) {
  return {
    next: () => {
      var n = it.next();
      return n.done ? n : {
        value: callback(n.value),
        done: false
      };
    }
  };
}
function createEmptyMap() {
  return new Map;
}
function createMap(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(mapOrObject);
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject(map) {
  if (map instanceof ObjectWrappingMap) {
    return map.wrappedObject;
  }
  var object = {};
  for (var key of map.keys()) {
    var value = map.get(key);
    setSafeProperty(object, key, value);
  }
  return object;
}

// node_modules/mathjs/lib/esm/utils/is.js
function isNumber(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
    return true;
  }
  return false;
}
function isBigInt(x) {
  return typeof x === "bigint";
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  return x && x.constructor.prototype.isUnit === true || false;
}
function isString(x) {
  return typeof x === "string";
}
var isArray = Array.isArray;
function isMatrix(x) {
  return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
  return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
  return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
  return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isMap(object) {
  if (!object) {
    return false;
  }
  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === undefined;
}
function isAccessorNode(x) {
  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function rule2Node(node) {
  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
}
function isFunctionAssignmentNode(x) {
  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isRelationalNode(x) {
  return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
  return x && x.constructor.prototype.isChain === true || false;
}
function typeOf(x) {
  var t = typeof x;
  if (t === "object") {
    if (x === null)
      return "null";
    if (isBigNumber(x))
      return "BigNumber";
    if (x.constructor && x.constructor.name)
      return x.constructor.name;
    return "Object";
  }
  return t;
}

// node_modules/mathjs/lib/esm/utils/object.js
function clone(x) {
  var type = typeof x;
  if (type === "number" || type === "bigint" || type === "string" || type === "boolean" || x === null || x === undefined) {
    return x;
  }
  if (typeof x.clone === "function") {
    return x.clone();
  }
  if (Array.isArray(x)) {
    return x.map(function(value) {
      return clone(value);
    });
  }
  if (x instanceof Date)
    return new Date(x.valueOf());
  if (isBigNumber(x))
    return x;
  if (isObject(x)) {
    return mapObject(x, clone);
  }
  if (type === "function") {
    return x;
  }
  throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x, ")"));
}
function mapObject(object, callback) {
  var clone2 = {};
  for (var key in object) {
    if (hasOwnProperty(object, key)) {
      clone2[key] = callback(object[key]);
    }
  }
  return clone2;
}
function extend(a, b) {
  for (var prop in b) {
    if (hasOwnProperty(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  var prop, i, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0, len = a.length;i < len; i++) {
      if (!deepStrictEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a) {
      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function lazy(object, prop, valueResolver) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function get() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function set(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty(object, property) {
  return object && Object.hasOwnProperty.call(object, property);
}
function pickShallow(object, properties) {
  var copy = {};
  for (var i = 0;i < properties.length; i++) {
    var key = properties[i];
    var value = object[key];
    if (value !== undefined) {
      copy[key] = value;
    }
  }
  return copy;
}

// node_modules/mathjs/lib/esm/core/function/config.js
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];

// node_modules/mathjs/lib/esm/entry/configReadonly.js
var config = function config2(options) {
  if (options) {
    throw new Error(`The global config is readonly. 
` + `Please create a mathjs instance if you want to change the default configuration. 
` + `Example:
` + `
` + `  import { create, all } from 'mathjs';
` + `  const mathjs = create(all);
` + `  mathjs.config({ number: 'BigNumber' });
`);
  }
  return Object.freeze(DEFAULT_CONFIG);
};
_extends(config, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});

// node_modules/mathjs/lib/esm/core/function/typed.js
var import_typed_function = __toESM(require_typed_function(), 1);

// node_modules/mathjs/lib/esm/utils/factory.js
function factory(name, dependencies, create, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));
    assertDependencies(name, dependencies, scope);
    return create(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name;
  assertAndCreate.dependencies = dependencies.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function assertDependencies(name, dependencies, scope) {
  var allDefined = dependencies.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== undefined);
  if (!allDefined) {
    var missingDependencies = dependencies.filter((dependency) => scope[dependency] === undefined);
    throw new Error('Cannot create function "'.concat(name, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}

// node_modules/mathjs/lib/esm/utils/number.js
function isInteger(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
function safeNumberType(numberStr, config3) {
  if (config3.number === "bigint") {
    try {
      BigInt(numberStr);
    } catch (_unused) {
      return config3.numberFallback;
    }
  }
  return config3.number;
}
var sign = Math.sign || function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var log2 = Math.log2 || function log22(x) {
  return Math.log(x) / Math.LN2;
};
var log10 = Math.log10 || function log102(x) {
  return Math.log(x) / Math.LN10;
};
var log1p = Math.log1p || function(x) {
  return Math.log(x + 1);
};
var cbrt = Math.cbrt || function cbrt2(x) {
  if (x === 0) {
    return x;
  }
  var negate = x < 0;
  var result;
  if (negate) {
    x = -x;
  }
  if (isFinite(x)) {
    result = Math.exp(Math.log(x) / 3);
    result = (x / (result * result) + 2 * result) / 3;
  } else {
    result = x;
  }
  return negate ? -result : result;
};
var expm1 = Math.expm1 || function expm12(x) {
  return x >= 0.0002 || x <= -0.0002 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
};
function formatNumberToBase(n, base, size) {
  var prefixes = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix = prefixes[base];
  var suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
    }
    if (!isInteger(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size;
    }
    suffix = "i".concat(size);
  }
  var sign2 = "";
  if (n < 0) {
    n = -n;
    sign2 = "-";
  }
  return "".concat(sign2).concat(prefix).concat(n.toString(base)).concat(suffix);
}
function format(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var {
    notation,
    precision,
    wordSize
  } = normalizeFormatOptions(options);
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits = arguments[2];
        var e = arguments[4];
        return digits !== "." ? digits + e : e;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function normalizeFormatOptions(options) {
  var notation = "auto";
  var precision;
  var wordSize;
  if (options !== undefined) {
    if (isNumber(options)) {
      precision = options;
    } else if (isBigNumber(options)) {
      precision = options.toNumber();
    } else if (isObject(options)) {
      if (options.precision !== undefined) {
        precision = _toNumberOrThrow(options.precision, () => {
          throw new Error('Option "precision" must be a number or BigNumber');
        });
      }
      if (options.wordSize !== undefined) {
        wordSize = _toNumberOrThrow(options.wordSize, () => {
          throw new Error('Option "wordSize" must be a number or BigNumber');
        });
      }
      if (options.notation) {
        notation = options.notation;
      }
    } else {
      throw new Error("Unsupported type of options, number, BigNumber, or object expected");
    }
  }
  return {
    notation,
    precision,
    wordSize
  };
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign2 = match[1];
  var digits = match[2];
  var exponent = parseFloat(match[4] || "0");
  var dot = digits.indexOf(".");
  exponent += dot !== -1 ? dot - 1 : digits.length - 1;
  var coefficients = digits.replace(".", "").replace(/^0*/, function(zeros) {
    exponent -= zeros.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return {
    sign: sign2,
    coefficients,
    exponent
  };
}
function toEngineering(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e = rounded.exponent;
  var c = rounded.coefficients;
  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
  if (isNumber(precision)) {
    while (precision > c.length || e - newExp + 1 > c.length) {
      c.push(0);
    }
  } else {
    var missingZeros = Math.abs(e - newExp) - (c.length - 1);
    for (var i = 0;i < missingZeros; i++) {
      c.push(0);
    }
  }
  var expDiff = Math.abs(e - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c.slice(decimalIdx).join("");
  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c = rounded.coefficients;
  var p = rounded.exponent + 1;
  var pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros(pp - c.length));
  }
  if (p < 0) {
    c = zeros(-p + 1).concat(c);
    p = 1;
  }
  if (p < c.length) {
    c.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c.join("");
}
function toExponential(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c = rounded.coefficients;
  var e = rounded.exponent;
  if (c.length < precision) {
    c = c.concat(zeros(precision - c.length));
  }
  var first = c.shift();
  return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e >= 0 ? "+" : "") + e;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = _toNumberOrDefault(options === null || options === undefined ? undefined : options.lowerExp, -3);
  var upperExp = _toNumberOrDefault(options === null || options === undefined ? undefined : options.upperExp, 5);
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential(value, precision);
  } else {
    var c = rounded.coefficients;
    var e = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
    c = zeros(-e).concat(c);
    var dot = e > 0 ? e : 0;
    if (dot < c.length - 1) {
      c.splice(dot + 1, 0, ".");
    }
    return rounded.sign + c.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c = rounded.coefficients;
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);
    if (removed[0] >= 5) {
      var i = precision - 1;
      c[i]++;
      while (c[i] === 10) {
        c.pop();
        if (i === 0) {
          c.unshift(0);
          rounded.exponent++;
          i++;
        }
        i--;
        c[i]++;
      }
    }
  }
  return rounded;
}
function zeros(length) {
  var arr = [];
  for (var i = 0;i < length; i++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
function nearlyEqual(a, b) {
  var relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.00000001;
  var absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  if (relTol <= 0) {
    throw new Error("Relative tolerance must be greater than 0");
  }
  if (absTol < 0) {
    throw new Error("Absolute tolerance must be at least 0");
  }
  if (isNaN(a) || isNaN(b)) {
    return false;
  }
  if (!isFinite(a) || !isFinite(b)) {
    return a === b;
  }
  if (a === b) {
    return true;
  }
  return Math.abs(a - b) <= Math.max(relTol * Math.max(Math.abs(a), Math.abs(b)), absTol);
}
var acosh = Math.acosh || function(x) {
  return Math.log(Math.sqrt(x * x - 1) + x);
};
var asinh = Math.asinh || function(x) {
  return Math.log(Math.sqrt(x * x + 1) + x);
};
var atanh = Math.atanh || function(x) {
  return Math.log((1 + x) / (1 - x)) / 2;
};
var cosh = Math.cosh || function(x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
};
var sinh = Math.sinh || function(x) {
  return (Math.exp(x) - Math.exp(-x)) / 2;
};
var tanh = Math.tanh || function(x) {
  var e = Math.exp(2 * x);
  return (e - 1) / (e + 1);
};
function copysign(x, y) {
  var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
  var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
  return signx ^ signy ? -x : x;
}
function _toNumberOrThrow(value, onError) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    onError();
  }
}
function _toNumberOrDefault(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}

// node_modules/mathjs/lib/esm/core/function/typed.js
var _createTyped2 = function _createTyped() {
  _createTyped2 = import_typed_function.default.create;
  return import_typed_function.default;
};
var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
  var {
    BigNumber,
    Complex,
    DenseMatrix,
    Fraction
  } = _ref;
  var typed = _createTyped2();
  typed.clear();
  typed.addTypes([
    {
      name: "number",
      test: isNumber
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "bigint",
      test: isBigInt
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    {
      name: "identifier",
      test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s)
    },
    {
      name: "string",
      test: isString
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction
    },
    {
      name: "Date",
      test: isDate
    },
    {
      name: "RegExp",
      test: isRegExp
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "RelationalNode",
      test: isRelationalNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap
    },
    {
      name: "Object",
      test: isObject
    }
  ]);
  typed.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber) {
        throwNoBignumber(x);
      }
      if (digits(x) > 15) {
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber " + "(value: " + x + "). " + "Use function bignumber(x) to convert to BigNumber.");
      }
      return new BigNumber(x);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      return new Complex(x, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      return new Complex(x.toNumber(), 0);
    }
  }, {
    from: "bigint",
    to: "number",
    convert: function convert(x) {
      if (x > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("Cannot implicitly convert bigint to number: " + "value exceeds the max safe integer value (value: " + x + ")");
      }
      return Number(x);
    }
  }, {
    from: "bigint",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber) {
        throwNoBignumber(x);
      }
      return new BigNumber(x.toString());
    }
  }, {
    from: "bigint",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction) {
        throwNoFraction(x);
      }
      return new Fraction(x);
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function convert(x) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. " + "Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      return new Complex(x.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction) {
        throwNoFraction(x);
      }
      var f = new Fraction(x);
      if (f.valueOf() !== x) {
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision " + "(value: " + x + "). " + "Use function fraction(x) to convert to Fraction.");
      }
      return f;
    }
  }, {
    from: "string",
    to: "number",
    convert: function convert(x) {
      var n = Number(x);
      if (isNaN(n)) {
        throw new Error('Cannot convert "' + x + '" to a number');
      }
      return n;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber) {
        throwNoBignumber(x);
      }
      try {
        return new BigNumber(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "bigint",
    convert: function convert(x) {
      try {
        return BigInt(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigInt');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction) {
        throwNoFraction(x);
      }
      try {
        return new Fraction(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex) {
        throwNoComplex(x);
      }
      try {
        return new Complex(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function convert(x) {
      return +x;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber) {
        throwNoBignumber(x);
      }
      return new BigNumber(+x);
    }
  }, {
    from: "boolean",
    to: "bigint",
    convert: function convert(x) {
      return BigInt(+x);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction) {
        throwNoFraction(x);
      }
      return new Fraction(+x);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function convert(x) {
      return String(x);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function convert(array) {
      if (!DenseMatrix) {
        throwNoMatrix();
      }
      return new DenseMatrix(array);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function convert(matrix) {
      return matrix.valueOf();
    }
  }]);
  typed.onMismatch = (name, args, signatures) => {
    var usualError = typed.createError(name, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  typed.onMismatch = (name, args, signatures) => {
    var usualError = typed.createError(name, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  return typed;
});
function throwNoBignumber(x) {
  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
}
// node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
var name = "ResultSet";
var dependencies2 = [];
var createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
  function ResultSet(entries) {
    if (!(this instanceof ResultSet)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.entries = entries || [];
  }
  ResultSet.prototype.type = "ResultSet";
  ResultSet.prototype.isResultSet = true;
  ResultSet.prototype.valueOf = function() {
    return this.entries;
  };
  ResultSet.prototype.toString = function() {
    return "[" + this.entries.map(String).join(", ") + "]";
  };
  ResultSet.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  };
  ResultSet.fromJSON = function(json) {
    return new ResultSet(json.entries);
  };
  return ResultSet;
}, {
  isClass: true
});
// node_modules/decimal.js/decimal.mjs
/*!
 *  decimal.js v10.5.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9000000000000000;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min, max) {
  var k, x = this, Ctor = x.constructor;
  min = new Ctor(min);
  max = new Ctor(max);
  if (!min.s || !max.s)
    return new Ctor(NaN);
  if (min.gt(max))
    throw Error(invalidArgument + max);
  k = x.cmp(min);
  return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL;i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (;w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (;i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (;k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k;i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (;i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== undefined)
      for (i = j;r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0];k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 100000000000000) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k;i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0;i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len;i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length;i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i;j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (;xd[--len] === 0; )
    xd.pop();
  for (;xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (;i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0;i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length;xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== undefined && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL;i--; )
    r.push(0);
  for (i = ydL;--i >= 0; ) {
    carry = 0;
    for (k = xdL + i;k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (;!r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === undefined)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === undefined)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (;; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === undefined) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 100000000000000) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === undefined) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === undefined) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1;i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (;w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0];k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1000 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (;i < strL; ) {
    for (arrL = arr.length;arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0;j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === undefined)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k;i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice();i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0;i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (;aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (;!a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0;yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (;(i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (;remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== undefined) && sd--);
        more = rem[0] !== undefined;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0];k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits2 = 1, k = xd[0];k >= 10; k /= 10)
        digits2++;
      i = sd - digits2;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (;k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits2 = 1;k >= 10; k /= 10)
            digits2++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== undefined || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (;; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0];j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1;j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length;xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits2, e) {
  var w = digits2[0];
  for (e *= LOG_BASE;w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits2) {
  var w = digits2.length - 1, len = w * LOG_BASE + 1;
  w = digits2[w];
  if (w) {
    for (;w % 10 == 0; w /= 10)
      len--;
    for (w = digits2[0];w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (;k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (;; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k, y, x = new Ctor(args[0]), i = 0;
  for (;++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    }
    k = x.cmp(y);
    if (k === n || k === 0 && x.s === n) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(1);
  Ctor.precision = wpr;
  for (;; ) {
    pow = finalise(pow.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum = finalise(sum.times(sum), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 1500000000000000) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (;; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0)
        sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0;str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length;str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE;i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (;i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe;xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (;k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (;; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== undefined) {
      for (j = k;t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== undefined;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (;xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== undefined;
      roundUp = rm < 4 ? (i !== undefined || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (;++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length;!xd[len - 1]; --len)
        ;
      for (i = 0, str = "";i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len;len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length;!xd[len - 1]; --len)
              ;
            for (i = 1, str = "1.";i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (;++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len;e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh2(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh2(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh2(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt3(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min, max) {
  return new this(x).clamp(min, max);
}
function config3(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0;i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== undefined) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== undefined) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh2(x) {
  return new this(x).cosh();
}
function clone2(obj) {
  var i, p, ps;
  function Decimal(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal))
      return new Decimal(v);
    x.constructor = Decimal;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v;i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      }
      if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    }
    if (t === "string") {
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43)
          v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    if (t === "bigint") {
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      return parseDecimal(x, v.toString());
    }
    throw Error(invalidArgument + v);
  }
  Decimal.prototype = P;
  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;
  Decimal.config = Decimal.set = config3;
  Decimal.clone = clone2;
  Decimal.isDecimal = isDecimalInstance;
  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh2;
  Decimal.add = add;
  Decimal.asin = asin;
  Decimal.asinh = asinh2;
  Decimal.atan = atan;
  Decimal.atanh = atanh2;
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt3;
  Decimal.ceil = ceil;
  Decimal.clamp = clamp;
  Decimal.cos = cos;
  Decimal.cosh = cosh2;
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log103;
  Decimal.log2 = log23;
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul;
  Decimal.pow = pow;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign2;
  Decimal.sin = sin;
  Decimal.sinh = sinh2;
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.sum = sum;
  Decimal.tan = tan;
  Decimal.tanh = tanh2;
  Decimal.trunc = trunc;
  if (obj === undefined)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0;i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal.config(obj);
  return Decimal;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0;i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log23(x) {
  return new this(x).log(2);
}
function log103(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === undefined)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (;i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (;i < k; ) {
      n = d[i];
      if (n >= 4290000000) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (;i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 2140000000) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (;rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (;rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0];n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign2(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh2(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (;x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh2(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone2(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
var name2 = "BigNumber";
var dependencies3 = ["?on", "config"];
var createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
  var {
    on,
    config: config4
  } = _ref;
  var BigNumber = decimal_default.clone({
    precision: config4.precision,
    modulo: decimal_default.EUCLID
  });
  BigNumber.prototype = Object.create(BigNumber.prototype);
  BigNumber.prototype.type = "BigNumber";
  BigNumber.prototype.isBigNumber = true;
  BigNumber.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber.fromJSON = function(json) {
    return new BigNumber(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber;
}, {
  isClass: true
});
// node_modules/complex.js/dist/complex.mjs
var cosh3 = Math.cosh || function(x) {
  return Math.abs(x) < 0.000000001 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
};
var sinh3 = Math.sinh || function(x) {
  return Math.abs(x) < 0.000000001 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
};
var cosm1 = function(x) {
  const b = Math.PI / 4;
  if (-b > x || x > b) {
    return Math.cos(x) - 1;
  }
  const xx = x * x;
  return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888000 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
};
var hypot2 = function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  if (x < y)
    [x, y] = [y, x];
  if (x < 1e8)
    return Math.sqrt(x * x + y * y);
  y /= x;
  return x * Math.sqrt(1 + y * y);
};
var parser_exit = function() {
  throw SyntaxError("Invalid Param");
};
function logHypot(a, b) {
  const _a = Math.abs(a);
  const _b = Math.abs(b);
  if (a === 0) {
    return Math.log(_b);
  }
  if (b === 0) {
    return Math.log(_a);
  }
  if (_a < 3000 && _b < 3000) {
    return Math.log(a * a + b * b) * 0.5;
  }
  a = a * 0.5;
  b = b * 0.5;
  return 0.5 * Math.log(a * a + b * b) + Math.LN2;
}
var P2 = { re: 0, im: 0 };
var parse = function(a, b) {
  const z = P2;
  if (a === undefined || a === null) {
    z["re"] = z["im"] = 0;
  } else if (b !== undefined) {
    z["re"] = a;
    z["im"] = b;
  } else
    switch (typeof a) {
      case "object":
        if ("im" in a && "re" in a) {
          z["re"] = a["re"];
          z["im"] = a["im"];
        } else if ("abs" in a && "arg" in a) {
          if (!isFinite(a["abs"]) && isFinite(a["arg"])) {
            return Complex["INFINITY"];
          }
          z["re"] = a["abs"] * Math.cos(a["arg"]);
          z["im"] = a["abs"] * Math.sin(a["arg"]);
        } else if ("r" in a && "phi" in a) {
          if (!isFinite(a["r"]) && isFinite(a["phi"])) {
            return Complex["INFINITY"];
          }
          z["re"] = a["r"] * Math.cos(a["phi"]);
          z["im"] = a["r"] * Math.sin(a["phi"]);
        } else if (a.length === 2) {
          z["re"] = a[0];
          z["im"] = a[1];
        } else {
          parser_exit();
        }
        break;
      case "string":
        z["im"] = z["re"] = 0;
        const tokens = a.replace(/_/g, "").match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
        let plus = 1;
        let minus = 0;
        if (tokens === null) {
          parser_exit();
        }
        for (let i = 0;i < tokens.length; i++) {
          const c = tokens[i];
          if (c === " " || c === "\t" || c === `
`) {
          } else if (c === "+") {
            plus++;
          } else if (c === "-") {
            minus++;
          } else if (c === "i" || c === "I") {
            if (plus + minus === 0) {
              parser_exit();
            }
            if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
              i++;
            } else {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
            }
            plus = minus = 0;
          } else {
            if (plus + minus === 0 || isNaN(c)) {
              parser_exit();
            }
            if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
              z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
              i++;
            } else {
              z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
            }
            plus = minus = 0;
          }
        }
        if (plus + minus > 0) {
          parser_exit();
        }
        break;
      case "number":
        z["im"] = 0;
        z["re"] = a;
        break;
      default:
        parser_exit();
    }
  if (isNaN(z["re"]) || isNaN(z["im"])) {
  }
  return z;
};
function Complex(a, b) {
  if (!(this instanceof Complex)) {
    return new Complex(a, b);
  }
  const z = parse(a, b);
  this["re"] = z["re"];
  this["im"] = z["im"];
}
Complex.prototype = {
  re: 0,
  im: 0,
  sign: function() {
    const abs2 = hypot2(this["re"], this["im"]);
    return new Complex(this["re"] / abs2, this["im"] / abs2);
  },
  add: function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    if (tInfin || zInfin) {
      if (tInfin && zInfin) {
        return Complex["NAN"];
      }
      return Complex["INFINITY"];
    }
    return new Complex(this["re"] + z["re"], this["im"] + z["im"]);
  },
  sub: function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    if (tInfin || zInfin) {
      if (tInfin && zInfin) {
        return Complex["NAN"];
      }
      return Complex["INFINITY"];
    }
    return new Complex(this["re"] - z["re"], this["im"] - z["im"]);
  },
  mul: function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (tInfin && zIsZero || zInfin && tIsZero) {
      return Complex["NAN"];
    }
    if (tInfin || zInfin) {
      return Complex["INFINITY"];
    }
    if (z["im"] === 0 && this["im"] === 0) {
      return new Complex(this["re"] * z["re"], 0);
    }
    return new Complex(this["re"] * z["re"] - this["im"] * z["im"], this["re"] * z["im"] + this["im"] * z["re"]);
  },
  div: function(a, b) {
    const z = parse(a, b);
    const tInfin = this["isInfinite"]();
    const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (tIsZero && zIsZero || tInfin && zInfin) {
      return Complex["NAN"];
    }
    if (zIsZero || tInfin) {
      return Complex["INFINITY"];
    }
    if (tIsZero || zInfin) {
      return Complex["ZERO"];
    }
    if (z["im"] === 0) {
      return new Complex(this["re"] / z["re"], this["im"] / z["re"]);
    }
    if (Math.abs(z["re"]) < Math.abs(z["im"])) {
      const x = z["re"] / z["im"];
      const t = z["re"] * x + z["im"];
      return new Complex((this["re"] * x + this["im"]) / t, (this["im"] * x - this["re"]) / t);
    } else {
      const x = z["im"] / z["re"];
      const t = z["im"] * x + z["re"];
      return new Complex((this["re"] + this["im"] * x) / t, (this["im"] - this["re"] * x) / t);
    }
  },
  pow: function(a, b) {
    const z = parse(a, b);
    const tIsZero = this["re"] === 0 && this["im"] === 0;
    const zIsZero = z["re"] === 0 && z["im"] === 0;
    if (zIsZero) {
      return Complex["ONE"];
    }
    if (z["im"] === 0) {
      if (this["im"] === 0 && this["re"] > 0) {
        return new Complex(Math.pow(this["re"], z["re"]), 0);
      } else if (this["re"] === 0) {
        switch ((z["re"] % 4 + 4) % 4) {
          case 0:
            return new Complex(Math.pow(this["im"], z["re"]), 0);
          case 1:
            return new Complex(0, Math.pow(this["im"], z["re"]));
          case 2:
            return new Complex(-Math.pow(this["im"], z["re"]), 0);
          case 3:
            return new Complex(0, -Math.pow(this["im"], z["re"]));
        }
      }
    }
    if (tIsZero && z["re"] > 0) {
      return Complex["ZERO"];
    }
    const arg = Math.atan2(this["im"], this["re"]);
    const loh = logHypot(this["re"], this["im"]);
    let re = Math.exp(z["re"] * loh - z["im"] * arg);
    let im = z["im"] * loh + z["re"] * arg;
    return new Complex(re * Math.cos(im), re * Math.sin(im));
  },
  sqrt: function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      if (a >= 0) {
        return new Complex(Math.sqrt(a), 0);
      } else {
        return new Complex(0, Math.sqrt(-a));
      }
    }
    const r = hypot2(a, b);
    let re = Math.sqrt(0.5 * (r + Math.abs(a)));
    let im = Math.abs(b) / (2 * re);
    if (a >= 0) {
      return new Complex(re, b < 0 ? -im : im);
    } else {
      return new Complex(im, b < 0 ? -re : re);
    }
  },
  exp: function() {
    const er = Math.exp(this["re"]);
    if (this["im"] === 0) {
      return new Complex(er, 0);
    }
    return new Complex(er * Math.cos(this["im"]), er * Math.sin(this["im"]));
  },
  expm1: function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));
  },
  log: function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0 && a > 0) {
      return new Complex(Math.log(a), 0);
    }
    return new Complex(logHypot(a, b), Math.atan2(b, a));
  },
  abs: function() {
    return hypot2(this["re"], this["im"]);
  },
  arg: function() {
    return Math.atan2(this["im"], this["re"]);
  },
  sin: function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(Math.sin(a) * cosh3(b), Math.cos(a) * sinh3(b));
  },
  cos: function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(Math.cos(a) * cosh3(b), -Math.sin(a) * sinh3(b));
  },
  tan: function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = Math.cos(a) + cosh3(b);
    return new Complex(Math.sin(a) / d, sinh3(b) / d);
  },
  cot: function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = Math.cos(a) - cosh3(b);
    return new Complex(-Math.sin(a) / d, sinh3(b) / d);
  },
  sec: function() {
    const a = this["re"];
    const b = this["im"];
    const d = 0.5 * cosh3(2 * b) + 0.5 * Math.cos(2 * a);
    return new Complex(Math.cos(a) * cosh3(b) / d, Math.sin(a) * sinh3(b) / d);
  },
  csc: function() {
    const a = this["re"];
    const b = this["im"];
    const d = 0.5 * cosh3(2 * b) - 0.5 * Math.cos(2 * a);
    return new Complex(Math.sin(a) * cosh3(b) / d, -Math.cos(a) * sinh3(b) / d);
  },
  asin: function() {
    const a = this["re"];
    const b = this["im"];
    const t1 = new Complex(b * b - a * a + 1, -2 * a * b)["sqrt"]();
    const t2 = new Complex(t1["re"] - b, t1["im"] + a)["log"]();
    return new Complex(t2["im"], -t2["re"]);
  },
  acos: function() {
    const a = this["re"];
    const b = this["im"];
    const t1 = new Complex(b * b - a * a + 1, -2 * a * b)["sqrt"]();
    const t2 = new Complex(t1["re"] - b, t1["im"] + a)["log"]();
    return new Complex(Math.PI / 2 - t2["im"], t2["re"]);
  },
  atan: function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0) {
      if (b === 1) {
        return new Complex(0, Infinity);
      }
      if (b === -1) {
        return new Complex(0, -Infinity);
      }
    }
    const d = a * a + (1 - b) * (1 - b);
    const t1 = new Complex((1 - b * b - a * a) / d, -2 * a / d).log();
    return new Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
  },
  acot: function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      return new Complex(Math.atan2(1, a), 0);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(a / d, -b / d).atan() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();
  },
  asec: function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex(0, Infinity);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(a / d, -b / d).acos() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();
  },
  acsc: function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex(Math.PI / 2, Infinity);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(a / d, -b / d).asin() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();
  },
  sinh: function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(sinh3(a) * Math.cos(b), cosh3(a) * Math.sin(b));
  },
  cosh: function() {
    const a = this["re"];
    const b = this["im"];
    return new Complex(cosh3(a) * Math.cos(b), sinh3(a) * Math.sin(b));
  },
  tanh: function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = cosh3(a) + Math.cos(b);
    return new Complex(sinh3(a) / d, Math.sin(b) / d);
  },
  coth: function() {
    const a = 2 * this["re"];
    const b = 2 * this["im"];
    const d = cosh3(a) - Math.cos(b);
    return new Complex(sinh3(a) / d, -Math.sin(b) / d);
  },
  csch: function() {
    const a = this["re"];
    const b = this["im"];
    const d = Math.cos(2 * b) - cosh3(2 * a);
    return new Complex(-2 * sinh3(a) * Math.cos(b) / d, 2 * cosh3(a) * Math.sin(b) / d);
  },
  sech: function() {
    const a = this["re"];
    const b = this["im"];
    const d = Math.cos(2 * b) + cosh3(2 * a);
    return new Complex(2 * cosh3(a) * Math.cos(b) / d, -2 * sinh3(a) * Math.sin(b) / d);
  },
  asinh: function() {
    let tmp = this["im"];
    this["im"] = -this["re"];
    this["re"] = tmp;
    const res = this["asin"]();
    this["re"] = -this["im"];
    this["im"] = tmp;
    tmp = res["re"];
    res["re"] = -res["im"];
    res["im"] = tmp;
    return res;
  },
  acosh: function() {
    const res = this["acos"]();
    if (res["im"] <= 0) {
      const tmp = res["re"];
      res["re"] = -res["im"];
      res["im"] = tmp;
    } else {
      const tmp = res["im"];
      res["im"] = -res["re"];
      res["re"] = tmp;
    }
    return res;
  },
  atanh: function() {
    const a = this["re"];
    const b = this["im"];
    const noIM = a > 1 && b === 0;
    const oneMinus = 1 - a;
    const onePlus = 1 + a;
    const d = oneMinus * oneMinus + b * b;
    const x = d !== 0 ? new Complex((onePlus * oneMinus - b * b) / d, (b * oneMinus + onePlus * b) / d) : new Complex(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);
    const temp = x["re"];
    x["re"] = logHypot(x["re"], x["im"]) / 2;
    x["im"] = Math.atan2(x["im"], temp) / 2;
    if (noIM) {
      x["im"] = -x["im"];
    }
    return x;
  },
  acoth: function() {
    const a = this["re"];
    const b = this["im"];
    if (a === 0 && b === 0) {
      return new Complex(0, Math.PI / 2);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(a / d, -b / d).atanh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atanh();
  },
  acsch: function() {
    const a = this["re"];
    const b = this["im"];
    if (b === 0) {
      return new Complex(a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity, 0);
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(a / d, -b / d).asinh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asinh();
  },
  asech: function() {
    const a = this["re"];
    const b = this["im"];
    if (this["isZero"]()) {
      return Complex["INFINITY"];
    }
    const d = a * a + b * b;
    return d !== 0 ? new Complex(a / d, -b / d).acosh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acosh();
  },
  inverse: function() {
    if (this["isZero"]()) {
      return Complex["INFINITY"];
    }
    if (this["isInfinite"]()) {
      return Complex["ZERO"];
    }
    const a = this["re"];
    const b = this["im"];
    const d = a * a + b * b;
    return new Complex(a / d, -b / d);
  },
  conjugate: function() {
    return new Complex(this["re"], -this["im"]);
  },
  neg: function() {
    return new Complex(-this["re"], -this["im"]);
  },
  ceil: function(places) {
    places = Math.pow(10, places || 0);
    return new Complex(Math.ceil(this["re"] * places) / places, Math.ceil(this["im"] * places) / places);
  },
  floor: function(places) {
    places = Math.pow(10, places || 0);
    return new Complex(Math.floor(this["re"] * places) / places, Math.floor(this["im"] * places) / places);
  },
  round: function(places) {
    places = Math.pow(10, places || 0);
    return new Complex(Math.round(this["re"] * places) / places, Math.round(this["im"] * places) / places);
  },
  equals: function(a, b) {
    const z = parse(a, b);
    return Math.abs(z["re"] - this["re"]) <= Complex["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex["EPSILON"];
  },
  clone: function() {
    return new Complex(this["re"], this["im"]);
  },
  toString: function() {
    let a = this["re"];
    let b = this["im"];
    let ret = "";
    if (this["isNaN"]()) {
      return "NaN";
    }
    if (this["isInfinite"]()) {
      return "Infinity";
    }
    if (Math.abs(a) < Complex["EPSILON"]) {
      a = 0;
    }
    if (Math.abs(b) < Complex["EPSILON"]) {
      b = 0;
    }
    if (b === 0) {
      return ret + a;
    }
    if (a !== 0) {
      ret += a;
      ret += " ";
      if (b < 0) {
        b = -b;
        ret += "-";
      } else {
        ret += "+";
      }
      ret += " ";
    } else if (b < 0) {
      b = -b;
      ret += "-";
    }
    if (b !== 1) {
      ret += b;
    }
    return ret + "i";
  },
  toVector: function() {
    return [this["re"], this["im"]];
  },
  valueOf: function() {
    if (this["im"] === 0) {
      return this["re"];
    }
    return null;
  },
  isNaN: function() {
    return isNaN(this["re"]) || isNaN(this["im"]);
  },
  isZero: function() {
    return this["im"] === 0 && this["re"] === 0;
  },
  isFinite: function() {
    return isFinite(this["re"]) && isFinite(this["im"]);
  },
  isInfinite: function() {
    return !this["isFinite"]();
  }
};
Complex["ZERO"] = new Complex(0, 0);
Complex["ONE"] = new Complex(1, 0);
Complex["I"] = new Complex(0, 1);
Complex["PI"] = new Complex(Math.PI, 0);
Complex["E"] = new Complex(Math.E, 0);
Complex["INFINITY"] = new Complex(Infinity, Infinity);
Complex["NAN"] = new Complex(NaN, NaN);
Complex["EPSILON"] = 0.000000000000001;

// node_modules/mathjs/lib/esm/type/complex/Complex.js
var name3 = "Complex";
var dependencies4 = [];
var createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
  Object.defineProperty(Complex, "name", {
    value: "Complex"
  });
  Complex.prototype.constructor = Complex;
  Complex.prototype.type = "Complex";
  Complex.prototype.isComplex = true;
  Complex.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  Complex.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  Complex.prototype.format = function(options) {
    var str = "";
    var im = this.im;
    var re = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re / im) < epsilon) {
        re = 0;
      }
      if (Math.abs(im / re) < epsilon) {
        im = 0;
      }
    }
    if (im === 0) {
      str = strRe;
    } else if (re === 0) {
      if (im === 1) {
        str = "i";
      } else if (im === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im < 0) {
        if (im === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  Complex.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg = arguments[0];
        if (typeof arg === "object") {
          return Complex(arg);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi) && phi.hasBase("ANGLE")) {
            phi = phi.toNumber("rad");
          }
          if (isNumber(phi)) {
            return new Complex({
              r,
              phi
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  Complex.prototype.valueOf = Complex.prototype.toString;
  Complex.fromJSON = function(json) {
    return new Complex(json);
  };
  Complex.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return Complex;
}, {
  isClass: true
});
// node_modules/mathjs/node_modules/fraction.js/dist/fraction.mjs
if (typeof BigInt === "undefined")
  BigInt = function(n) {
    if (isNaN(n))
      throw new Error("");
    return n;
  };
var C_ZERO = BigInt(0);
var C_ONE = BigInt(1);
var C_TWO = BigInt(2);
var C_FIVE = BigInt(5);
var C_TEN = BigInt(10);
var MAX_CYCLE_LEN = 2000;
var P3 = {
  s: C_ONE,
  n: C_ZERO,
  d: C_ONE
};
function assign(n, s) {
  try {
    n = BigInt(n);
  } catch (e) {
    throw InvalidParameter();
  }
  return n * s;
}
function trunc2(x) {
  return typeof x === "bigint" ? x : Math.floor(x);
}
function newFraction(n, d) {
  if (d === C_ZERO) {
    throw DivisionByZero();
  }
  const f = Object.create(Fraction.prototype);
  f["s"] = n < C_ZERO ? -C_ONE : C_ONE;
  n = n < C_ZERO ? -n : n;
  const a = gcd(n, d);
  f["n"] = n / a;
  f["d"] = d / a;
  return f;
}
function factorize(num) {
  const factors = {};
  let n = num;
  let i = C_TWO;
  let s = C_FIVE - C_ONE;
  while (s <= n) {
    while (n % i === C_ZERO) {
      n /= i;
      factors[i] = (factors[i] || C_ZERO) + C_ONE;
    }
    s += C_ONE + C_TWO * i++;
  }
  if (n !== num) {
    if (n > 1)
      factors[n] = (factors[n] || C_ZERO) + C_ONE;
  } else {
    factors[num] = (factors[num] || C_ZERO) + C_ONE;
  }
  return factors;
}
var parse2 = function(p1, p2) {
  let n = C_ZERO, d = C_ONE, s = C_ONE;
  if (p1 === undefined || p1 === null) {
  } else if (p2 !== undefined) {
    if (typeof p1 === "bigint") {
      n = p1;
    } else if (isNaN(p1)) {
      throw InvalidParameter();
    } else if (p1 % 1 !== 0) {
      throw NonIntegerParameter();
    } else {
      n = BigInt(p1);
    }
    if (typeof p2 === "bigint") {
      d = p2;
    } else if (isNaN(p2)) {
      throw InvalidParameter();
    } else if (p2 % 1 !== 0) {
      throw NonIntegerParameter();
    } else {
      d = BigInt(p2);
    }
    s = n * d;
  } else if (typeof p1 === "object") {
    if ("d" in p1 && "n" in p1) {
      n = BigInt(p1["n"]);
      d = BigInt(p1["d"]);
      if ("s" in p1)
        n *= BigInt(p1["s"]);
    } else if (0 in p1) {
      n = BigInt(p1[0]);
      if (1 in p1)
        d = BigInt(p1[1]);
    } else if (typeof p1 === "bigint") {
      n = p1;
    } else {
      throw InvalidParameter();
    }
    s = n * d;
  } else if (typeof p1 === "number") {
    if (isNaN(p1)) {
      throw InvalidParameter();
    }
    if (p1 < 0) {
      s = -C_ONE;
      p1 = -p1;
    }
    if (p1 % 1 === 0) {
      n = BigInt(p1);
    } else if (p1 > 0) {
      let z = 1;
      let A = 0, B = 1;
      let C = 1, D = 1;
      let N = 1e7;
      if (p1 >= 1) {
        z = 10 ** Math.floor(1 + Math.log10(p1));
        p1 /= z;
      }
      while (B <= N && D <= N) {
        let M = (A + C) / (B + D);
        if (p1 === M) {
          if (B + D <= N) {
            n = A + C;
            d = B + D;
          } else if (D > B) {
            n = C;
            d = D;
          } else {
            n = A;
            d = B;
          }
          break;
        } else {
          if (p1 > M) {
            A += C;
            B += D;
          } else {
            C += A;
            D += B;
          }
          if (B > N) {
            n = C;
            d = D;
          } else {
            n = A;
            d = B;
          }
        }
      }
      n = BigInt(n) * BigInt(z);
      d = BigInt(d);
    }
  } else if (typeof p1 === "string") {
    let ndx = 0;
    let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;
    let match = p1.replace(/_/g, "").match(/\d+|./g);
    if (match === null)
      throw InvalidParameter();
    if (match[ndx] === "-") {
      s = -C_ONE;
      ndx++;
    } else if (match[ndx] === "+") {
      ndx++;
    }
    if (match.length === ndx + 1) {
      w = assign(match[ndx++], s);
    } else if (match[ndx + 1] === "." || match[ndx] === ".") {
      if (match[ndx] !== ".") {
        v = assign(match[ndx++], s);
      }
      ndx++;
      if (ndx + 1 === match.length || match[ndx + 1] === "(" && match[ndx + 3] === ")" || match[ndx + 1] === "'" && match[ndx + 3] === "'") {
        w = assign(match[ndx], s);
        y = C_TEN ** BigInt(match[ndx].length);
        ndx++;
      }
      if (match[ndx] === "(" && match[ndx + 2] === ")" || match[ndx] === "'" && match[ndx + 2] === "'") {
        x = assign(match[ndx + 1], s);
        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;
        ndx += 3;
      }
    } else if (match[ndx + 1] === "/" || match[ndx + 1] === ":") {
      w = assign(match[ndx], s);
      y = assign(match[ndx + 2], C_ONE);
      ndx += 3;
    } else if (match[ndx + 3] === "/" && match[ndx + 1] === " ") {
      v = assign(match[ndx], s);
      w = assign(match[ndx + 2], s);
      y = assign(match[ndx + 4], C_ONE);
      ndx += 5;
    }
    if (match.length <= ndx) {
      d = y * z;
      s = n = x + d * v + z * w;
    } else {
      throw InvalidParameter();
    }
  } else if (typeof p1 === "bigint") {
    n = p1;
    s = p1;
    d = C_ONE;
  } else {
    throw InvalidParameter();
  }
  if (d === C_ZERO) {
    throw DivisionByZero();
  }
  P3["s"] = s < C_ZERO ? -C_ONE : C_ONE;
  P3["n"] = n < C_ZERO ? -n : n;
  P3["d"] = d < C_ZERO ? -d : d;
};
function modpow(b, e, m) {
  let r = C_ONE;
  for (;e > C_ZERO; b = b * b % m, e >>= C_ONE) {
    if (e & C_ONE) {
      r = r * b % m;
    }
  }
  return r;
}
function cycleLen(n, d) {
  for (;d % C_TWO === C_ZERO; d /= C_TWO) {
  }
  for (;d % C_FIVE === C_ZERO; d /= C_FIVE) {
  }
  if (d === C_ONE)
    return C_ZERO;
  let rem = C_TEN % d;
  let t = 1;
  for (;rem !== C_ONE; t++) {
    rem = rem * C_TEN % d;
    if (t > MAX_CYCLE_LEN)
      return C_ZERO;
  }
  return BigInt(t);
}
function cycleStart(n, d, len) {
  let rem1 = C_ONE;
  let rem2 = modpow(C_TEN, len, d);
  for (let t = 0;t < 300; t++) {
    if (rem1 === rem2)
      return BigInt(t);
    rem1 = rem1 * C_TEN % d;
    rem2 = rem2 * C_TEN % d;
  }
  return 0;
}
function gcd(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  while (true) {
    a %= b;
    if (!a)
      return b;
    b %= a;
    if (!b)
      return a;
  }
}
function Fraction(a, b) {
  parse2(a, b);
  if (this instanceof Fraction) {
    a = gcd(P3["d"], P3["n"]);
    this["s"] = P3["s"];
    this["n"] = P3["n"] / a;
    this["d"] = P3["d"] / a;
  } else {
    return newFraction(P3["s"] * P3["n"], P3["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction.prototype = {
  s: C_ONE,
  n: C_ZERO,
  d: C_ONE,
  abs: function() {
    return newFraction(this["n"], this["d"]);
  },
  neg: function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  add: function(a, b) {
    parse2(a, b);
    return newFraction(this["s"] * this["n"] * P3["d"] + P3["s"] * this["d"] * P3["n"], this["d"] * P3["d"]);
  },
  sub: function(a, b) {
    parse2(a, b);
    return newFraction(this["s"] * this["n"] * P3["d"] - P3["s"] * this["d"] * P3["n"], this["d"] * P3["d"]);
  },
  mul: function(a, b) {
    parse2(a, b);
    return newFraction(this["s"] * P3["s"] * this["n"] * P3["n"], this["d"] * P3["d"]);
  },
  div: function(a, b) {
    parse2(a, b);
    return newFraction(this["s"] * P3["s"] * this["n"] * P3["d"], this["d"] * P3["n"]);
  },
  clone: function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  mod: function(a, b) {
    if (a === undefined) {
      return newFraction(this["s"] * this["n"] % this["d"], C_ONE);
    }
    parse2(a, b);
    if (C_ZERO === P3["n"] * this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(this["s"] * (P3["d"] * this["n"]) % (P3["n"] * this["d"]), P3["d"] * this["d"]);
  },
  gcd: function(a, b) {
    parse2(a, b);
    return newFraction(gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]), P3["d"] * this["d"]);
  },
  lcm: function(a, b) {
    parse2(a, b);
    if (P3["n"] === C_ZERO && this["n"] === C_ZERO) {
      return newFraction(C_ZERO, C_ONE);
    }
    return newFraction(P3["n"] * this["n"], gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]));
  },
  inverse: function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  pow: function(a, b) {
    parse2(a, b);
    if (P3["d"] === C_ONE) {
      if (P3["s"] < C_ZERO) {
        return newFraction((this["s"] * this["d"]) ** P3["n"], this["n"] ** P3["n"]);
      } else {
        return newFraction((this["s"] * this["n"]) ** P3["n"], this["d"] ** P3["n"]);
      }
    }
    if (this["s"] < C_ZERO)
      return null;
    let N = factorize(this["n"]);
    let D = factorize(this["d"]);
    let n = C_ONE;
    let d = C_ONE;
    for (let k in N) {
      if (k === "1")
        continue;
      if (k === "0") {
        n = C_ZERO;
        break;
      }
      N[k] *= P3["n"];
      if (N[k] % P3["d"] === C_ZERO) {
        N[k] /= P3["d"];
      } else
        return null;
      n *= BigInt(k) ** N[k];
    }
    for (let k in D) {
      if (k === "1")
        continue;
      D[k] *= P3["n"];
      if (D[k] % P3["d"] === C_ZERO) {
        D[k] /= P3["d"];
      } else
        return null;
      d *= BigInt(k) ** D[k];
    }
    if (P3["s"] < C_ZERO) {
      return newFraction(d, n);
    }
    return newFraction(n, d);
  },
  log: function(a, b) {
    parse2(a, b);
    if (this["s"] <= C_ZERO || P3["s"] <= C_ZERO)
      return null;
    const allPrimes = {};
    const baseFactors = factorize(P3["n"]);
    const T1 = factorize(P3["d"]);
    const numberFactors = factorize(this["n"]);
    const T2 = factorize(this["d"]);
    for (const prime in T1) {
      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];
    }
    for (const prime in T2) {
      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];
    }
    for (const prime in baseFactors) {
      if (prime === "1")
        continue;
      allPrimes[prime] = true;
    }
    for (const prime in numberFactors) {
      if (prime === "1")
        continue;
      allPrimes[prime] = true;
    }
    let retN = null;
    let retD = null;
    for (const prime in allPrimes) {
      const baseExponent = baseFactors[prime] || C_ZERO;
      const numberExponent = numberFactors[prime] || C_ZERO;
      if (baseExponent === C_ZERO) {
        if (numberExponent !== C_ZERO) {
          return null;
        }
        continue;
      }
      let curN = numberExponent;
      let curD = baseExponent;
      const gcdValue = gcd(curN, curD);
      curN /= gcdValue;
      curD /= gcdValue;
      if (retN === null && retD === null) {
        retN = curN;
        retD = curD;
      } else if (curN * retD !== retN * curD) {
        return null;
      }
    }
    return retN !== null && retD !== null ? newFraction(retN, retD) : null;
  },
  equals: function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P3["d"] === P3["s"] * P3["n"] * this["d"];
  },
  lt: function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P3["d"] < P3["s"] * P3["n"] * this["d"];
  },
  lte: function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P3["d"] <= P3["s"] * P3["n"] * this["d"];
  },
  gt: function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P3["d"] > P3["s"] * P3["n"] * this["d"];
  },
  gte: function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P3["d"] >= P3["s"] * P3["n"] * this["d"];
  },
  compare: function(a, b) {
    parse2(a, b);
    let t = this["s"] * this["n"] * P3["d"] - P3["s"] * P3["n"] * this["d"];
    return (C_ZERO < t) - (t < C_ZERO);
  },
  ceil: function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(trunc2(this["s"] * places * this["n"] / this["d"]) + (places * this["n"] % this["d"] > C_ZERO && this["s"] >= C_ZERO ? C_ONE : C_ZERO), places);
  },
  floor: function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(trunc2(this["s"] * places * this["n"] / this["d"]) - (places * this["n"] % this["d"] > C_ZERO && this["s"] < C_ZERO ? C_ONE : C_ZERO), places);
  },
  round: function(places) {
    places = C_TEN ** BigInt(places || 0);
    return newFraction(trunc2(this["s"] * places * this["n"] / this["d"]) + this["s"] * ((this["s"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this["n"] % this["d"]) > this["d"] ? C_ONE : C_ZERO), places);
  },
  roundTo: function(a, b) {
    parse2(a, b);
    const n = this["n"] * P3["d"];
    const d = this["d"] * P3["n"];
    const r = n % d;
    let k = trunc2(n / d);
    if (r + r >= d) {
      k++;
    }
    return newFraction(this["s"] * k * P3["n"], P3["d"]);
  },
  divisible: function(a, b) {
    parse2(a, b);
    return !(!(P3["n"] * this["d"]) || this["n"] * P3["d"] % (P3["n"] * this["d"]));
  },
  valueOf: function() {
    return Number(this["s"] * this["n"]) / Number(this["d"]);
  },
  toString: function(dec) {
    let N = this["n"];
    let D = this["d"];
    dec = dec || 15;
    let cycLen = cycleLen(N, D);
    let cycOff = cycleStart(N, D, cycLen);
    let str = this["s"] < C_ZERO ? "-" : "";
    str += trunc2(N / D);
    N %= D;
    N *= C_TEN;
    if (N)
      str += ".";
    if (cycLen) {
      for (let i = cycOff;i--; ) {
        str += trunc2(N / D);
        N %= D;
        N *= C_TEN;
      }
      str += "(";
      for (let i = cycLen;i--; ) {
        str += trunc2(N / D);
        N %= D;
        N *= C_TEN;
      }
      str += ")";
    } else {
      for (let i = dec;N && i--; ) {
        str += trunc2(N / D);
        N %= D;
        N *= C_TEN;
      }
    }
    return str;
  },
  toFraction: function(showMixed) {
    let n = this["n"];
    let d = this["d"];
    let str = this["s"] < C_ZERO ? "-" : "";
    if (d === C_ONE) {
      str += n;
    } else {
      let whole = trunc2(n / d);
      if (showMixed && whole > C_ZERO) {
        str += whole;
        str += " ";
        n %= d;
      }
      str += n;
      str += "/";
      str += d;
    }
    return str;
  },
  toLatex: function(showMixed) {
    let n = this["n"];
    let d = this["d"];
    let str = this["s"] < C_ZERO ? "-" : "";
    if (d === C_ONE) {
      str += n;
    } else {
      let whole = trunc2(n / d);
      if (showMixed && whole > C_ZERO) {
        str += whole;
        n %= d;
      }
      str += "\\frac{";
      str += n;
      str += "}{";
      str += d;
      str += "}";
    }
    return str;
  },
  toContinued: function() {
    let a = this["n"];
    let b = this["d"];
    let res = [];
    do {
      res.push(trunc2(a / b));
      let t = a % b;
      a = b;
      b = t;
    } while (a !== C_ONE);
    return res;
  },
  simplify: function(eps) {
    const ieps = BigInt(1 / (eps || 0.001) | 0);
    const thisABS = this["abs"]();
    const cont = thisABS["toContinued"]();
    for (let i = 1;i < cont.length; i++) {
      let s = newFraction(cont[i - 1], C_ONE);
      for (let k = i - 2;k >= 0; k--) {
        s = s["inverse"]()["add"](cont[k]);
      }
      let t = s["sub"](thisABS);
      if (t["n"] * ieps < t["d"]) {
        return s["mul"](this["s"]);
      }
    }
    return this;
  }
};

// node_modules/mathjs/lib/esm/type/fraction/Fraction.js
var name4 = "Fraction";
var dependencies5 = [];
var createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
  Object.defineProperty(Fraction, "name", {
    value: "Fraction"
  });
  Fraction.prototype.constructor = Fraction;
  Fraction.prototype.type = "Fraction";
  Fraction.prototype.isFraction = true;
  Fraction.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: String(this.s * this.n),
      d: String(this.d)
    };
  };
  Fraction.fromJSON = function(json) {
    return new Fraction(json);
  };
  return Fraction;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/type/matrix/Range.js
var name5 = "Range";
var dependencies6 = [];
var createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    var hasStart = start !== null && start !== undefined;
    var hasEnd = end !== null && end !== undefined;
    var hasStep = step !== null && step !== undefined;
    if (hasStart) {
      if (isBigNumber(start)) {
        start = start.toNumber();
      } else if (typeof start !== "number" && !isBigInt(start)) {
        throw new TypeError("Parameter start must be a number or bigint");
      }
    }
    if (hasEnd) {
      if (isBigNumber(end)) {
        end = end.toNumber();
      } else if (typeof end !== "number" && !isBigInt(end)) {
        throw new TypeError("Parameter end must be a number or bigint");
      }
    }
    if (hasStep) {
      if (isBigNumber(step)) {
        step = step.toNumber();
      } else if (typeof step !== "number" && !isBigInt(step)) {
        throw new TypeError("Parameter step must be a number or bigint");
      }
    }
    this.start = hasStart ? parseFloat(start) : 0;
    this.end = hasEnd ? parseFloat(end) : 0;
    this.step = hasStep ? parseFloat(step) : 1;
  }
  Range.prototype.type = "Range";
  Range.prototype.isRange = true;
  Range.parse = function(str) {
    if (typeof str !== "string") {
      return null;
    }
    var args = str.split(":");
    var nums = args.map(function(arg) {
      return parseFloat(arg);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return new Range(nums[0], nums[1]);
      case 3:
        return new Range(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };
  Range.prototype.clone = function() {
    return new Range(this.start, this.end, this.step);
  };
  Range.prototype.size = function() {
    var len = 0;
    var start = this.start;
    var step = this.step;
    var end = this.end;
    var diff = end - start;
    if (sign(step) === sign(diff)) {
      len = Math.ceil(diff / step);
    } else if (diff === 0) {
      len = 0;
    }
    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };
  Range.prototype.min = function() {
    var size = this.size()[0];
    if (size > 0) {
      if (this.step > 0) {
        return this.start;
      } else {
        return this.start + (size - 1) * this.step;
      }
    } else {
      return;
    }
  };
  Range.prototype.max = function() {
    var size = this.size()[0];
    if (size > 0) {
      if (this.step > 0) {
        return this.start + (size - 1) * this.step;
      } else {
        return this.start;
      }
    } else {
      return;
    }
  };
  Range.prototype.forEach = function(callback) {
    var x = this.start;
    var step = this.step;
    var end = this.end;
    var i = 0;
    if (step > 0) {
      while (x < end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    } else if (step < 0) {
      while (x > end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    }
  };
  Range.prototype.map = function(callback) {
    var array = [];
    this.forEach(function(value, index, obj) {
      array[index[0]] = callback(value, index, obj);
    });
    return array;
  };
  Range.prototype.toArray = function() {
    var array = [];
    this.forEach(function(value, index) {
      array[index[0]] = value;
    });
    return array;
  };
  Range.prototype.valueOf = function() {
    return this.toArray();
  };
  Range.prototype.format = function(options) {
    var str = format(this.start, options);
    if (this.step !== 1) {
      str += ":" + format(this.step, options);
    }
    str += ":" + format(this.end, options);
    return str;
  };
  Range.prototype.toString = function() {
    return this.format();
  };
  Range.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  };
  Range.fromJSON = function(json) {
    return new Range(json.start, json.end, json.step);
  };
  return Range;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/type/matrix/Matrix.js
var name6 = "Matrix";
var dependencies7 = [];
var createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
  function Matrix() {
    if (!(this instanceof Matrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix.prototype.type = "Matrix";
  Matrix.prototype.isMatrix = true;
  Matrix.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix.prototype.subset = function(index, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix.prototype.get = function(index) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix.prototype.set = function(index, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix.prototype.resize = function(size, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix.prototype.reshape = function(size, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
function formatBigNumberToBase(n, base, size) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size) {
    if (size < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size));
    }
    suffix = "i".concat(size);
  }
  switch (base) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base, " not supported "));
  }
}
function format2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var {
    notation,
    precision,
    wordSize
  } = normalizeFormatOptions(options);
  switch (notation) {
    case "fixed":
      return toFixed2(value, precision);
    case "exponential":
      return toExponential2(value, precision);
    case "engineering":
      return toEngineering2(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = _toNumberOrDefault2(options === null || options === undefined ? undefined : options.lowerExp, -3);
      var upperExp = _toNumberOrDefault2(options === null || options === undefined ? undefined : options.upperExp, 5);
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp2 = rounded.e;
      if (exp2 >= lowerExp && exp2 < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential2(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e = arguments[4];
        return digits2 !== "." ? digits2 + e : e;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering2(value, precision) {
  var e = value.e;
  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.includes("e")) {
    var BigNumber = value.constructor;
    valueStr = new BigNumber(valueStr).toFixed();
  }
  return valueStr + "e" + (e >= 0 ? "+" : "") + newExp.toString();
}
function toExponential2(value, precision) {
  if (precision !== undefined) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed2(value, precision) {
  return value.toFixed(precision);
}
function _toNumberOrDefault2(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}

// node_modules/mathjs/lib/esm/utils/string.js
function endsWith(text, search) {
  var start = text.length - search.length;
  var end = text.length;
  return text.substring(start, end) === search;
}
function format3(value, options) {
  var result = _format(value, options);
  if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
    return result.substring(0, options.truncate - 3) + "...";
  }
  return result;
}
function _format(value, options) {
  if (typeof value === "number") {
    return format(value, options);
  }
  if (isBigNumber(value)) {
    return format2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      return "".concat(value.s * value.n, "/").concat(value.d);
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString(value)) {
    return stringify(value);
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      var entries = Object.keys(value).map((key) => {
        return stringify(key) + ": " + format3(value[key], options);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
}
function stringify(value) {
  var text = String(value);
  var escaped = "";
  var i = 0;
  while (i < text.length) {
    var c = text.charAt(i);
    escaped += c in controlCharacters ? controlCharacters[c] : c;
    i++;
  }
  return '"' + escaped + '"';
}
var controlCharacters = {
  '"': "\\\"",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "\t": "\\t"
};
function escape(value) {
  var text = String(value);
  text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text;
}
function formatArray(array, options) {
  if (Array.isArray(array)) {
    var str = "[";
    var len = array.length;
    for (var i = 0;i < len; i++) {
      if (i !== 0) {
        str += ", ";
      }
      str += formatArray(array[i], options);
    }
    str += "]";
    return str;
  } else {
    return format3(array, options);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "bigint" && typeof value.n === "bigint" && typeof value.d === "bigint" || false;
}
function compareText(x, y) {
  if (!isString(x)) {
    throw new TypeError("Unexpected type of argument in function compareText " + "(expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)");
  }
  if (!isString(y)) {
    throw new TypeError("Unexpected type of argument in function compareText " + "(expected: string or Array or Matrix, actual: " + typeOf(y) + ", index: 1)");
  }
  return x === y ? 0 : x > y ? 1 : -1;
}

// node_modules/mathjs/lib/esm/error/DimensionError.js
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError;
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = true;

// node_modules/mathjs/lib/esm/error/IndexError.js
function IndexError(index, min2, max2) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min2;
  } else {
    this.min = min2;
    this.max = max2;
  }
  if (this.min !== undefined && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== undefined && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
IndexError.prototype = new RangeError;
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = true;

// node_modules/mathjs/lib/esm/utils/array.js
function arraySize(x) {
  var s = [];
  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }
  return s;
}
function _validate(array, size, dim) {
  var i;
  var len = array.length;
  if (len !== size[dim]) {
    throw new DimensionError(len, size[dim]);
  }
  if (dim < size.length - 1) {
    var dimNext = dim + 1;
    for (i = 0;i < len; i++) {
      var child = array[i];
      if (!Array.isArray(child)) {
        throw new DimensionError(size.length - 1, size.length, "<");
      }
      _validate(array[i], size, dimNext);
    }
  } else {
    for (i = 0;i < len; i++) {
      if (Array.isArray(array[i])) {
        throw new DimensionError(size.length + 1, size.length, ">");
      }
    }
  }
}
function validate(array, size) {
  var isScalar = size.length === 0;
  if (isScalar) {
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  } else {
    _validate(array, size, 0);
  }
}
function validateIndexSourceSize(value, index) {
  var valueSize = value.isMatrix ? value._size : arraySize(value);
  var sourceSize = index._sourceSize;
  sourceSize.forEach((sourceDim, i) => {
    if (sourceDim !== null && sourceDim !== valueSize[i]) {
      throw new DimensionError(sourceDim, valueSize[i]);
    }
  });
}
function validateIndex(index, length) {
  if (index !== undefined) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError("Index must be an integer (value: " + index + ")");
    }
    if (index < 0 || typeof length === "number" && index >= length) {
      throw new IndexError(index, length);
    }
  }
}
function isEmptyIndex(index) {
  for (var i = 0;i < index._dimensions.length; ++i) {
    var dimension = index._dimensions[i];
    if (dimension._data && isArray(dimension._data)) {
      if (dimension._size[0] === 0) {
        return true;
      }
    } else if (dimension.isRange) {
      if (dimension.start === dimension.end) {
        return true;
      }
    } else if (isString(dimension)) {
      if (dimension.length === 0) {
        return true;
      }
    }
  }
  return false;
}
function resize(array, size, defaultValue) {
  if (!Array.isArray(size)) {
    throw new TypeError("Array expected");
  }
  if (size.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size.forEach(function(value) {
    if (!isNumber(value) || !isInteger(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers " + "(size: " + format3(size) + ")");
    }
  });
  if (isNumber(array) || isBigNumber(array)) {
    array = [array];
  }
  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;
  _resize(array, size, 0, _defaultValue);
  return array;
}
function _resize(array, size, dim, defaultValue) {
  var i;
  var elem;
  var oldLen = array.length;
  var newLen = size[dim];
  var minLen = Math.min(oldLen, newLen);
  array.length = newLen;
  if (dim < size.length - 1) {
    var dimNext = dim + 1;
    for (i = 0;i < minLen; i++) {
      elem = array[i];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array[i] = elem;
      }
      _resize(elem, size, dimNext, defaultValue);
    }
    for (i = minLen;i < newLen; i++) {
      elem = [];
      array[i] = elem;
      _resize(elem, size, dimNext, defaultValue);
    }
  } else {
    for (i = 0;i < minLen; i++) {
      while (Array.isArray(array[i])) {
        array[i] = array[i][0];
      }
    }
    for (i = minLen;i < newLen; i++) {
      array[i] = defaultValue;
    }
  }
}
function reshape(array, sizes) {
  var flatArray = flatten(array);
  var currentLength = flatArray.length;
  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e) {
    if (e instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
function product(array) {
  return array.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array, sizes) {
  var tmpArray = array;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1;sizeIndex > 0; sizeIndex--) {
    var size = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size;
    for (var i = 0;i < length; i++) {
      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function squeeze(array, size) {
  var s = size || arraySize(array);
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }
  return array;
}
function _squeeze(array, dims, dim) {
  var i, ii;
  if (dim < dims) {
    var next = dim + 1;
    for (i = 0, ii = array.length;i < ii; i++) {
      array[i] = _squeeze(array[i], dims, next);
    }
  } else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }
  return array;
}
function unsqueeze(array, dims, outer, size) {
  var s = size || arraySize(array);
  if (outer) {
    for (var i = 0;i < outer; i++) {
      array = [array];
      s.unshift(1);
    }
  }
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return array;
}
function _unsqueeze(array, dims, dim) {
  var i, ii;
  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i = 0, ii = array.length;i < ii; i++) {
      array[i] = _unsqueeze(array[i], dims, next);
    }
  } else {
    for (var d = dim;d < dims; d++) {
      array = [array];
    }
  }
  return array;
}
function flatten(array) {
  if (!Array.isArray(array)) {
    return array;
  }
  var flat = [];
  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function map(array, callback) {
  return Array.prototype.map.call(array, callback);
}
function forEach(array, callback) {
  Array.prototype.forEach.call(array, callback);
}
function filter(array, callback) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
}
function join(array, separator) {
  return Array.prototype.join.call(array, separator);
}
function identify(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  var count = 0;
  b[0] = {
    value: a[0],
    identifier: 0
  };
  for (var i = 1;i < a.length; i++) {
    if (a[i] === a[i - 1]) {
      count++;
    } else {
      count = 0;
    }
    b.push({
      value: a[i],
      identifier: count
    });
  }
  return b;
}
function generalize(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  for (var i = 0;i < a.length; i++) {
    b.push(a[i].value);
  }
  return b;
}
function getArrayDataType(array, typeOf2) {
  var type;
  var length = 0;
  for (var i = 0;i < array.length; i++) {
    var item = array[i];
    var _isArray = Array.isArray(item);
    if (i === 0 && _isArray) {
      length = item.length;
    }
    if (_isArray && item.length !== length) {
      return;
    }
    var itemType = _isArray ? getArrayDataType(item, typeOf2) : typeOf2(item);
    if (type === undefined) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else {
    }
  }
  return type;
}
function concatRecursive(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    var c = [];
    for (var i = 0;i < a.length; i++) {
      c[i] = concatRecursive(a[i], b[i], concatDim, dim + 1);
    }
    return c;
  } else {
    return a.concat(b);
  }
}
function concat() {
  var arrays = Array.prototype.slice.call(arguments, 0, -1);
  var concatDim = Array.prototype.slice.call(arguments, -1);
  if (arrays.length === 1) {
    return arrays[0];
  }
  if (arrays.length > 1) {
    return arrays.slice(1).reduce(function(A, B) {
      return concatRecursive(A, B, concatDim, 0);
    }, arrays[0]);
  } else {
    throw new Error("Wrong number of arguments in function concat");
  }
}
function broadcastSizes() {
  for (var _len = arguments.length, sizes = new Array(_len), _key = 0;_key < _len; _key++) {
    sizes[_key] = arguments[_key];
  }
  var dimensions = sizes.map((s) => s.length);
  var N = Math.max(...dimensions);
  var sizeMax = new Array(N).fill(null);
  for (var i = 0;i < sizes.length; i++) {
    var size = sizes[i];
    var dim = dimensions[i];
    for (var j = 0;j < dim; j++) {
      var n = N - dim + j;
      if (size[j] > sizeMax[n]) {
        sizeMax[n] = size[j];
      }
    }
  }
  for (var _i = 0;_i < sizes.length; _i++) {
    checkBroadcastingRules(sizes[_i], sizeMax);
  }
  return sizeMax;
}
function checkBroadcastingRules(size, toSize) {
  var N = toSize.length;
  var dim = size.length;
  for (var j = 0;j < dim; j++) {
    var n = N - dim + j;
    if (size[j] < toSize[n] && size[j] > 1 || size[j] > toSize[n]) {
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size[j], " to size ").concat(toSize[n]));
    }
  }
}
function broadcastTo(array, toSize) {
  var Asize = arraySize(array);
  if (deepStrictEqual(Asize, toSize)) {
    return array;
  }
  checkBroadcastingRules(Asize, toSize);
  var broadcastedSize = broadcastSizes(Asize, toSize);
  var N = broadcastedSize.length;
  var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
  var A = clone3(array);
  if (Asize.length < N) {
    A = reshape(A, paddedSize);
    Asize = arraySize(A);
  }
  for (var dim = 0;dim < N; dim++) {
    if (Asize[dim] < broadcastedSize[dim]) {
      A = stretch(A, broadcastedSize[dim], dim);
      Asize = arraySize(A);
    }
  }
  return A;
}
function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
  return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
}
function get(array, index) {
  if (!Array.isArray(array)) {
    throw new Error("Array expected");
  }
  var size = arraySize(array);
  if (index.length !== size.length) {
    throw new DimensionError(index.length, size.length);
  }
  for (var x = 0;x < index.length; x++) {
    validateIndex(index[x], size[x]);
  }
  return index.reduce((acc, curr) => acc[curr], array);
}
function recurse(value, index, array, callback) {
  if (Array.isArray(value)) {
    return value.map(function(child, i) {
      return recurse(child, index.concat(i), array, callback);
    });
  } else {
    return callback(value, index, array);
  }
}
function clone3(array) {
  return _extends([], array);
}

// node_modules/mathjs/lib/esm/utils/optimizeCallback.js
var import_typed_function2 = __toESM(require_typed_function(), 1);
function optimizeCallback(callback, array, name7) {
  if (import_typed_function2.default.isTypedFunction(callback)) {
    var firstIndex = (array.isMatrix ? array.size() : arraySize(array)).map(() => 0);
    var firstValue = array.isMatrix ? array.get(firstIndex) : get(array, firstIndex);
    var hasSingleSignature = Object.keys(callback.signatures).length === 1;
    var numberOfArguments = _findNumberOfArguments(callback, firstValue, firstIndex, array);
    var fastCallback = hasSingleSignature ? Object.values(callback.signatures)[0] : callback;
    if (numberOfArguments >= 1 && numberOfArguments <= 3) {
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _tryFunctionWithArgs(fastCallback, args.slice(0, numberOfArguments), name7, callback.name);
      };
    }
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;_key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _tryFunctionWithArgs(fastCallback, args, name7, callback.name);
    };
  }
  return callback;
}
function _findNumberOfArguments(callback, value, index, array) {
  var testArgs = [value, index, array];
  for (var i = 3;i > 0; i--) {
    var args = testArgs.slice(0, i);
    if (import_typed_function2.default.resolve(callback, args) !== null) {
      return i;
    }
  }
}
function _tryFunctionWithArgs(func, args, mappingFnName, callbackName) {
  try {
    return func(...args);
  } catch (err) {
    _createCallbackError(err, args, mappingFnName, callbackName);
  }
}
function _createCallbackError(err, args, mappingFnName, callbackName) {
  var _err$data;
  if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === undefined ? undefined : _err$data.category) === "wrongType") {
    var argsDesc = [];
    argsDesc.push("value: ".concat(typeOf(args[0])));
    if (args.length >= 2) {
      argsDesc.push("index: ".concat(typeOf(args[1])));
    }
    if (args.length >= 3) {
      argsDesc.push("array: ".concat(typeOf(args[2])));
    }
    throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callbackName, "(").concat(argsDesc.join(", "), ") at index ").concat(JSON.stringify(args[1])));
  } else {
    throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callbackName, ": ").concat(err.message));
  }
}

// node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
var name7 = "DenseMatrix";
var dependencies8 = ["Matrix"];
var createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
  var {
    Matrix
  } = _ref;
  function DenseMatrix(data, datatype) {
    if (!(this instanceof DenseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone(data._data);
        this._size = clone(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix.prototype = new Matrix;
  DenseMatrix.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix(data, datatype);
  };
  Object.defineProperty(DenseMatrix, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix.prototype.constructor = DenseMatrix;
  DenseMatrix.prototype.type = "DenseMatrix";
  DenseMatrix.prototype.isDenseMatrix = true;
  DenseMatrix.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  };
  DenseMatrix.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix.prototype.create = function(data, datatype) {
    return new DenseMatrix(data, datatype);
  };
  DenseMatrix.prototype.subset = function(index, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index);
      case 2:
      case 3:
        return _set(this, index, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix.prototype.get = function(index) {
    return get(this._data, index);
  };
  DenseMatrix.prototype.set = function(index, value, defaultValue) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length < this._size.length) {
      throw new DimensionError(index.length, this._size.length, "<");
    }
    var i, ii, indexI;
    var size = index.map(function(i2) {
      return i2 + 1;
    });
    _fit(this, size, defaultValue);
    var data = this._data;
    for (i = 0, ii = index.length - 1;i < ii; i++) {
      indexI = index[i];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index[index.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix, index) {
    if (!isIndex(index)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index.isScalar();
    if (isScalar) {
      return matrix.get(index.min());
    } else {
      var size = index.size();
      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      }
      var min2 = index.min();
      var max2 = index.max();
      for (var i = 0, ii = matrix._size.length;i < ii; i++) {
        validateIndex(min2[i], matrix._size[i]);
        validateIndex(max2[i], matrix._size[i]);
      }
      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
    }
  }
  function _getSubmatrix(data, index, dims, dim) {
    var last = dim === dims - 1;
    var range = index.dimension(dim);
    if (last) {
      return range.map(function(i) {
        validateIndex(i, data.length);
        return data[i];
      }).valueOf();
    } else {
      return range.map(function(i) {
        validateIndex(i, data.length);
        var child = data[i];
        return _getSubmatrix(child, index, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix, index, submatrix, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix.set(index.min(), submatrix, defaultValue);
    } else {
      if (!deepStrictEqual(sSize, iSize)) {
        try {
          if (sSize.length === 0) {
            submatrix = broadcastTo([submatrix], iSize);
          } else {
            submatrix = broadcastTo(submatrix, iSize);
          }
          sSize = arraySize(submatrix);
        } catch (_unused) {
        }
      }
      if (iSize.length < matrix._size.length) {
        throw new DimensionError(iSize.length, matrix._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size = index.max().map(function(i2) {
        return i2 + 1;
      });
      _fit(matrix, size, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix._data, index, submatrix, dims, dim);
    }
    return matrix;
  }
  function _setSubmatrix(data, index, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range = index.dimension(dim);
    if (last) {
      range.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix.prototype.resize = function(size, defaultValue, copy) {
    if (!isCollection(size)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray, defaultValue);
  };
  function _resize2(matrix, size, defaultValue) {
    if (size.length === 0) {
      var v = matrix._data;
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    matrix._size = size.slice(0);
    matrix._data = resize(matrix._data, matrix._size, defaultValue);
    return matrix;
  }
  DenseMatrix.prototype.reshape = function(size, copy) {
    var m = copy ? this.clone() : this;
    m._data = reshape(m._data, size);
    var currentLength = m._size.reduce((length, size2) => length * size2);
    m._size = processSizesWildcard(size, currentLength);
    return m;
  };
  function _fit(matrix, size, defaultValue) {
    var newSize = matrix._size.slice(0);
    var changed = false;
    while (newSize.length < size.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i = 0, ii = size.length;i < ii; i++) {
      if (size[i] > newSize[i]) {
        newSize[i] = size[i];
        changed = true;
      }
    }
    if (changed) {
      _resize2(matrix, newSize, defaultValue);
    }
  }
  DenseMatrix.prototype.clone = function() {
    var m = new DenseMatrix({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix.prototype._forEach = function(callback) {
    var me = this;
    var s = me.size();
    if (s.length === 1) {
      for (var i = 0;i < s[0]; i++) {
        callback(me._data, i, [i]);
      }
      return;
    }
    var index = Array(s.length).fill(0);
    var data = Array(s.length - 1);
    var last = data.length - 1;
    data[0] = me._data[0];
    for (var _i = 0;_i < last; _i++) {
      data[_i + 1] = data[_i][0];
    }
    index[last] = -1;
    while (true) {
      var _i2 = undefined;
      for (_i2 = last;_i2 >= 0; _i2--) {
        index[_i2]++;
        if (index[_i2] === s[_i2]) {
          index[_i2] = 0;
          continue;
        }
        data[_i2] = _i2 === 0 ? me._data[index[_i2]] : data[_i2 - 1][index[_i2]];
        for (var j = _i2;j < last; j++) {
          data[j + 1] = data[j][0];
        }
        for (var _j = 0;_j < s[data.length]; _j++) {
          index[data.length] = _j;
          callback(data[last], _j, index.slice(0));
        }
        break;
      }
      if (_i2 === -1) {
        break;
      }
    }
  };
  DenseMatrix.prototype.map = function(callback) {
    var me = this;
    var result = new DenseMatrix(me);
    var fastCallback = optimizeCallback(callback, me._data, "map");
    result._forEach(function(arr, i, index) {
      arr[i] = fastCallback(arr[i], index, me);
    });
    return result;
  };
  DenseMatrix.prototype.forEach = function(callback) {
    var me = this;
    var fastCallback = optimizeCallback(callback, me._data, "map");
    me._forEach(function(arr, i, index) {
      fastCallback(arr[i], index, me);
    });
  };
  DenseMatrix.prototype[Symbol.iterator] = function* () {
    var _recurse = function* recurse(value, index) {
      if (isArray(value)) {
        for (var i = 0;i < value.length; i++) {
          yield* _recurse(value[i], index.concat(i));
        }
      } else {
        yield {
          value,
          index
        };
      }
    };
    yield* _recurse(this._data, []);
  };
  DenseMatrix.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row of data) {
      result.push(new DenseMatrix([row], this._datatype));
    }
    return result;
  };
  DenseMatrix.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop(i2) {
      var col = data.map((row) => [row[i2]]);
      result.push(new DenseMatrix(col, _this._datatype));
    };
    for (var i = 0;i < s[1]; i++) {
      _loop(i);
    }
    return result;
  };
  DenseMatrix.prototype.toArray = function() {
    return clone(this._data);
  };
  DenseMatrix.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix.prototype.format = function(options) {
    return format3(this._data, options);
  };
  DenseMatrix.prototype.toString = function() {
    return format3(this._data);
  };
  DenseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i = 0;i < n; i++) {
      data[i] = this._data[i + kSub][i + kSuper];
    }
    return new DenseMatrix({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix.diagonal = function(size, value, k, defaultValue) {
    if (!isArray(size)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size = size.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size[0];
    var columns = size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value(i) {
        return value[i];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value(i) {
        return value.get([i]);
      };
    } else {
      _value = function _value() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size.length > 0) {
      data = resize(data, size, defaultValue);
      for (var d = 0;d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix.fromJSON = function(json) {
    return new DenseMatrix(json);
  };
  DenseMatrix.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix._swapRows(i, j, this._data);
    return this;
  };
  DenseMatrix._swapRows = function(i, j, data) {
    var vi = data[i];
    data[i] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    if (isMatrix(data)) {
      return preprocess(data.valueOf());
    }
    if (isArray(data)) {
      return data.map(preprocess);
    }
    return data;
  }
  return DenseMatrix;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/function/utils/clone.js
var name8 = "clone";
var dependencies9 = ["typed"];
var createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name8, {
    any: clone
  });
});
// node_modules/mathjs/lib/esm/utils/switch.js
function _switch(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for (j = 0;j < J; j++) {
    var tmp = [];
    for (i = 0;i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// node_modules/mathjs/lib/esm/utils/collection.js
function containsCollections(array) {
  for (var i = 0;i < array.length; i++) {
    if (isCollection(array[i])) {
      return true;
    }
  }
  return false;
}
function deepForEach(array, callback) {
  if (isMatrix(array)) {
    array = array.valueOf();
  }
  for (var i = 0, ii = array.length;i < ii; i++) {
    var value = array[i];
    if (Array.isArray(value)) {
      deepForEach(value, callback);
    } else {
      callback(value);
    }
  }
}
function deepMap(array, callback, skipZeros) {
  if (array && typeof array.map === "function") {
    return array.map(function(x) {
      return deepMap(x, callback, skipZeros);
    });
  } else {
    return callback(array);
  }
}
function reduce(mat, dim, callback) {
  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size.length) {
    throw new IndexError(dim, size.length);
  }
  if (isMatrix(mat)) {
    return mat.create(_reduce(mat.valueOf(), dim, callback), mat.datatype());
  } else {
    return _reduce(mat, dim, callback);
  }
}
function _reduce(mat, dim, callback) {
  var i, ret, val, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i = 1;i < mat.length; i++) {
        val = callback(val, mat[i]);
      }
      return val;
    } else {
      tran = _switch(mat);
      ret = [];
      for (i = 0;i < tran.length; i++) {
        ret[i] = _reduce(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0;i < mat.length; i++) {
      ret[i] = _reduce(mat[i], dim - 1, callback);
    }
    return ret;
  }
}
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var k, k0, k1, i;
  if (x) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
      i = aindex[k];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
        if (update) {
          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          u[i] = mark;
        } else {
          x[i] = avalues[k];
        }
      } else {
        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
        u[i] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
      i = aindex[k];
      if (w[i] !== mark) {
        w[i] = mark;
        cindex.push(i);
      } else {
        u[i] = mark;
      }
    }
  }
}

// node_modules/mathjs/lib/esm/function/utils/isInteger.js
var name9 = "isInteger";
var dependencies10 = ["typed"];
var createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name9, {
    number: isInteger,
    BigNumber: function BigNumber(x) {
      return x.isInt();
    },
    bigint: function bigint(x) {
      return true;
    },
    Fraction: function Fraction(x) {
      return x.d === 1n;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/plain/number/arithmetic.js
var n1 = "number";
var n2 = "number, number";
function absNumber(a) {
  return Math.abs(a);
}
absNumber.signature = n1;
function addNumber(a, b) {
  return a + b;
}
addNumber.signature = n2;
function subtractNumber(a, b) {
  return a - b;
}
subtractNumber.signature = n2;
function multiplyNumber(a, b) {
  return a * b;
}
multiplyNumber.signature = n2;
function divideNumber(a, b) {
  return a / b;
}
divideNumber.signature = n2;
function unaryMinusNumber(x) {
  return -x;
}
unaryMinusNumber.signature = n1;
function unaryPlusNumber(x) {
  return x;
}
unaryPlusNumber.signature = n1;
function cbrtNumber(x) {
  return cbrt(x);
}
cbrtNumber.signature = n1;
function cubeNumber(x) {
  return x * x * x;
}
cubeNumber.signature = n1;
function expNumber(x) {
  return Math.exp(x);
}
expNumber.signature = n1;
function expm1Number(x) {
  return expm1(x);
}
expm1Number.signature = n1;
function gcdNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function gcd must be integer numbers");
  }
  var r;
  while (b !== 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return a < 0 ? -a : a;
}
gcdNumber.signature = n2;
function lcmNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a === 0 || b === 0) {
    return 0;
  }
  var t;
  var prod = a * b;
  while (b !== 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod / a);
}
lcmNumber.signature = n2;
function logNumber(x, y) {
  if (y) {
    return Math.log(x) / Math.log(y);
  }
  return Math.log(x);
}
function log10Number(x) {
  return log10(x);
}
log10Number.signature = n1;
function log2Number(x) {
  return log2(x);
}
log2Number.signature = n1;
function log1pNumber(x) {
  return log1p(x);
}
log1pNumber.signature = n1;
function modNumber(x, y) {
  return y === 0 ? x : x - y * Math.floor(x / y);
}
modNumber.signature = n2;
function nthRootNumber(a) {
  var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var inv = root < 0;
  if (inv) {
    root = -root;
  }
  if (root === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a < 0 && Math.abs(root) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a === 0) {
    return inv ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv ? 0 : a;
  }
  var x = Math.pow(Math.abs(a), 1 / root);
  x = a < 0 ? -x : x;
  return inv ? 1 / x : x;
}
function signNumber(x) {
  return sign(x);
}
signNumber.signature = n1;
function sqrtNumber(x) {
  return Math.sqrt(x);
}
sqrtNumber.signature = n1;
function squareNumber(x) {
  return x * x;
}
squareNumber.signature = n1;
function xgcdNumber(a, b) {
  var t;
  var q;
  var r;
  var x = 0;
  var lastx = 1;
  var y = 1;
  var lasty = 0;
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a / b);
    r = a - q * b;
    t = x;
    x = lastx - q * x;
    lastx = t;
    t = y;
    y = lasty - q * y;
    lasty = t;
    a = b;
    b = r;
  }
  var res;
  if (a < 0) {
    res = [-a, -lastx, -lasty];
  } else {
    res = [a, a ? lastx : 0, lasty];
  }
  return res;
}
xgcdNumber.signature = n2;
function powNumber(x, y) {
  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
    return 0;
  }
  return Math.pow(x, y);
}
powNumber.signature = n2;
function roundNumber(value) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  }
  return parseFloat(toFixed(value, decimals));
}
function normNumber(x) {
  return Math.abs(x);
}
normNumber.signature = n1;

// node_modules/mathjs/lib/esm/plain/number/bitwise.js
var n12 = "number";
var n22 = "number, number";
function bitAndNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x & y;
}
bitAndNumber.signature = n22;
function bitNotNumber(x) {
  if (!isInteger(x)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x;
}
bitNotNumber.signature = n12;
function bitOrNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x | y;
}
bitOrNumber.signature = n22;
function bitXorNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x ^ y;
}
bitXorNumber.signature = n22;
function leftShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x << y;
}
leftShiftNumber.signature = n22;
function rightArithShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x >> y;
}
rightArithShiftNumber.signature = n22;
function rightLogShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x >>> y;
}
rightLogShiftNumber.signature = n22;

// node_modules/mathjs/lib/esm/utils/product.js
function product2(i, n) {
  if (n < i) {
    return 1;
  }
  if (n === i) {
    return n;
  }
  var half = n + i >> 1;
  return product2(i, half) * product2(half + 1, n);
}

// node_modules/mathjs/lib/esm/plain/number/combinations.js
function combinationsNumber(n, k) {
  if (!isInteger(n) || n < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (!isInteger(k) || k < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (k > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  var nMinusk = n - k;
  var answer = 1;
  var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
  var nextdivisor = 2;
  var lastdivisor = k < nMinusk ? k : nMinusk;
  for (var nextnumerator = firstnumerator;nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product2(nextdivisor, lastdivisor);
  }
  return answer;
}
combinationsNumber.signature = "number, number";

// node_modules/mathjs/lib/esm/plain/number/constants.js
var pi = Math.PI;
var tau = 2 * Math.PI;
var e = Math.E;
var phi = 1.618033988749895;

// node_modules/mathjs/lib/esm/plain/number/logical.js
var n13 = "number";
var n23 = "number, number";
function notNumber(x) {
  return !x;
}
notNumber.signature = n13;
function orNumber(x, y) {
  return !!(x || y);
}
orNumber.signature = n23;
function xorNumber(x, y) {
  return !!x !== !!y;
}
xorNumber.signature = n23;
function andNumber(x, y) {
  return !!(x && y);
}
andNumber.signature = n23;

// node_modules/mathjs/lib/esm/plain/number/probability.js
function gammaNumber(n) {
  var x;
  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product2(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = gammaP[0];
  for (var i = 1;i < gammaP.length; ++i) {
    x += gammaP[i] / (n + i);
  }
  var t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
gammaNumber.signature = "number";
var gammaG = 4.7421875;
var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 0.00003399464998481189, 0.00004652362892704858, -0.00009837447530487956, 0.0001580887032249125, -0.00021026444172410488, 0.00021743961811521265, -0.0001643181065367639, 0.00008441822398385275, -0.000026190838401581408, 0.0000036899182659531625];
var lnSqrt2PI = 0.9189385332046728;
var lgammaG = 5;
var lgammaN = 7;
var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -0.000005395239384953];
function lgammaNumber(n) {
  if (n < 0)
    return NaN;
  if (n === 0)
    return Infinity;
  if (!isFinite(n))
    return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  var base = n + lgammaG + 0.5;
  var sum2 = lgammaSeries[0];
  for (var i = lgammaN - 1;i >= 1; i--) {
    sum2 += lgammaSeries[i] / (n + i);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum2);
}
lgammaNumber.signature = "number";

// node_modules/mathjs/lib/esm/plain/number/trigonometry.js
var n14 = "number";
var n24 = "number, number";
function acosNumber(x) {
  return Math.acos(x);
}
acosNumber.signature = n14;
function acoshNumber(x) {
  return acosh(x);
}
acoshNumber.signature = n14;
function acotNumber(x) {
  return Math.atan(1 / x);
}
acotNumber.signature = n14;
function acothNumber(x) {
  return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
}
acothNumber.signature = n14;
function acscNumber(x) {
  return Math.asin(1 / x);
}
acscNumber.signature = n14;
function acschNumber(x) {
  var xInv = 1 / x;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
acschNumber.signature = n14;
function asecNumber(x) {
  return Math.acos(1 / x);
}
asecNumber.signature = n14;
function asechNumber(x) {
  var xInv = 1 / x;
  var ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
asechNumber.signature = n14;
function asinNumber(x) {
  return Math.asin(x);
}
asinNumber.signature = n14;
function asinhNumber(x) {
  return asinh(x);
}
asinhNumber.signature = n14;
function atanNumber(x) {
  return Math.atan(x);
}
atanNumber.signature = n14;
function atan2Number(y, x) {
  return Math.atan2(y, x);
}
atan2Number.signature = n24;
function atanhNumber(x) {
  return atanh(x);
}
atanhNumber.signature = n14;
function cosNumber(x) {
  return Math.cos(x);
}
cosNumber.signature = n14;
function coshNumber(x) {
  return cosh(x);
}
coshNumber.signature = n14;
function cotNumber(x) {
  return 1 / Math.tan(x);
}
cotNumber.signature = n14;
function cothNumber(x) {
  var e2 = Math.exp(2 * x);
  return (e2 + 1) / (e2 - 1);
}
cothNumber.signature = n14;
function cscNumber(x) {
  return 1 / Math.sin(x);
}
cscNumber.signature = n14;
function cschNumber(x) {
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
  }
}
cschNumber.signature = n14;
function secNumber(x) {
  return 1 / Math.cos(x);
}
secNumber.signature = n14;
function sechNumber(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}
sechNumber.signature = n14;
function sinNumber(x) {
  return Math.sin(x);
}
sinNumber.signature = n14;
function sinhNumber(x) {
  return sinh(x);
}
sinhNumber.signature = n14;
function tanNumber(x) {
  return Math.tan(x);
}
tanNumber.signature = n14;
function tanhNumber(x) {
  return tanh(x);
}
tanhNumber.signature = n14;

// node_modules/mathjs/lib/esm/plain/number/utils.js
var n15 = "number";
function isIntegerNumber(x) {
  return isInteger(x);
}
isIntegerNumber.signature = n15;
function isNegativeNumber(x) {
  return x < 0;
}
isNegativeNumber.signature = n15;
function isPositiveNumber(x) {
  return x > 0;
}
isPositiveNumber.signature = n15;
function isZeroNumber(x) {
  return x === 0;
}
isZeroNumber.signature = n15;
function isNaNNumber(x) {
  return Number.isNaN(x);
}
isNaNNumber.signature = n15;

// node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
function nearlyEqual2(a, b) {
  var relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.000000001;
  var absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  if (relTol <= 0) {
    throw new Error("Relative tolerance must be greater than 0");
  }
  if (absTol < 0) {
    throw new Error("Absolute tolerance must be at least 0");
  }
  if (a.isNaN() || b.isNaN()) {
    return false;
  }
  if (!a.isFinite() || !b.isFinite()) {
    return a.eq(b);
  }
  if (a.eq(b)) {
    return true;
  }
  return a.minus(b).abs().lte(a.constructor.max(a.constructor.max(a.abs(), b.abs()).mul(relTol), absTol));
}

// node_modules/mathjs/lib/esm/function/utils/isNegative.js
var name10 = "isNegative";
var dependencies11 = ["typed", "config"];
var createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
  var {
    typed: typed2,
    config: config4
  } = _ref;
  return typed2(name10, {
    number: (x) => nearlyEqual(x, 0, config4.relTol, config4.absTol) ? false : isNegativeNumber(x),
    BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config4.relTol, config4.absTol) ? false : x.isNeg() && !x.isZero() && !x.isNaN(),
    bigint: (x) => x < 0n,
    Fraction: (x) => x.s < 0n,
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/utils/isNumeric.js
var name11 = "isNumeric";
var dependencies12 = ["typed"];
var createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name11, {
    "number | BigNumber | bigint | Fraction | boolean": () => true,
    "Complex | Unit | string | null | undefined | Node": () => false,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
var name12 = "hasNumericValue";
var dependencies13 = ["typed", "isNumeric"];
var createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
  var {
    typed: typed2,
    isNumeric
  } = _ref;
  return typed2(name12, {
    boolean: () => true,
    string: function string(x) {
      return x.trim().length > 0 && !isNaN(Number(x));
    },
    any: function any(x) {
      return isNumeric(x);
    }
  });
});
// node_modules/mathjs/lib/esm/function/utils/isPositive.js
var name13 = "isPositive";
var dependencies14 = ["typed", "config"];
var createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
  var {
    typed: typed2,
    config: config4
  } = _ref;
  return typed2(name13, {
    number: (x) => nearlyEqual(x, 0, config4.relTol, config4.absTol) ? false : isPositiveNumber(x),
    BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config4.relTol, config4.absTol) ? false : !x.isNeg() && !x.isZero() && !x.isNaN(),
    bigint: (x) => x > 0n,
    Fraction: (x) => x.s > 0n && x.n > 0n,
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/utils/isZero.js
var name14 = "isZero";
var dependencies15 = ["typed", "equalScalar"];
var createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return typed2(name14, {
    "number | BigNumber | Complex | Fraction": (x) => equalScalar(x, 0),
    bigint: (x) => x === 0n,
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/utils/isNaN.js
var name15 = "isNaN";
var dependencies16 = ["typed"];
var createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name15, {
    number: isNaNNumber,
    BigNumber: function BigNumber(x) {
      return x.isNaN();
    },
    bigint: function bigint(x) {
      return false;
    },
    Fraction: function Fraction(x) {
      return false;
    },
    Complex: function Complex(x) {
      return x.isNaN();
    },
    Unit: function Unit(x) {
      return Number.isNaN(x.value);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/utils/typeOf.js
var name16 = "typeOf";
var dependencies17 = ["typed"];
var createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name16, {
    any: typeOf
  });
});
// node_modules/mathjs/lib/esm/utils/complex.js
function complexEquals(x, y, relTol, absTol) {
  return nearlyEqual(x.re, y.re, relTol, absTol) && nearlyEqual(x.im, y.im, relTol, absTol);
}

// node_modules/mathjs/lib/esm/function/relational/compareUnits.js
var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return typed2.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/relational/equalScalar.js
var name17 = "equalScalar";
var dependencies18 = ["typed", "config"];
var createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
  var {
    typed: typed2,
    config: config4
  } = _ref;
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name17, {
    "boolean, boolean": function boolean_boolean(x, y) {
      return x === y;
    },
    "number, number": function number_number(x, y) {
      return nearlyEqual(x, y, config4.relTol, config4.absTol);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.eq(y) || nearlyEqual2(x, y, config4.relTol, config4.absTol);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x === y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.equals(y);
    },
    "Complex, Complex": function Complex_Complex(x, y) {
      return complexEquals(x, y, config4.relTol, config4.absTol);
    }
  }, compareUnits);
});
var createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config4
  } = _ref2;
  return typed2(name17, {
    "number, number": function number_number(x, y) {
      return nearlyEqual(x, y, config4.relTol, config4.absTol);
    }
  });
});
// node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
var name18 = "SparseMatrix";
var dependencies19 = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
  var {
    typed: typed2,
    equalScalar,
    Matrix
  } = _ref;
  function SparseMatrix(data, datatype) {
    if (!(this instanceof SparseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix._values = source._values ? clone(source._values) : undefined;
      matrix._index = clone(source._index);
      matrix._ptr = clone(source._ptr);
      matrix._size = clone(source._size);
      matrix._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix, data, datatype) {
    matrix._values = [];
    matrix._index = [];
    matrix._ptr = [];
    matrix._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar, [datatype, datatype]) || equalScalar;
      zero = typed2.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix._ptr.push(matrix._index.length);
        for (var i = 0;i < rows; i++) {
          var row = data[i];
          if (isArray(row)) {
            if (j === 0 && columns < row.length) {
              columns = row.length;
            }
            if (j < row.length) {
              var v = row[j];
              if (!eq(v, zero)) {
                matrix._values.push(v);
                matrix._index.push(i);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row, zero)) {
              matrix._values.push(row);
              matrix._index.push(i);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix._ptr.push(matrix._index.length);
    matrix._size = [rows, columns];
  }
  SparseMatrix.prototype = new Matrix;
  SparseMatrix.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix(data, datatype);
  };
  Object.defineProperty(SparseMatrix, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix.prototype.constructor = SparseMatrix;
  SparseMatrix.prototype.type = "SparseMatrix";
  SparseMatrix.prototype.isSparseMatrix = true;
  SparseMatrix.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  };
  SparseMatrix.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix.prototype.create = function(data, datatype) {
    return new SparseMatrix(data, datatype);
  };
  SparseMatrix.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix.prototype.subset = function(index, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index);
      case 2:
      case 3:
        return _setsubset(this, index, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix.get(idx.min());
    }
    var size = idx.size();
    if (size.length !== matrix._size.length) {
      throw new DimensionError(size.length, matrix._size.length);
    }
    var i, ii, k, kk;
    var min2 = idx.min();
    var max2 = idx.max();
    for (i = 0, ii = matrix._size.length;i < ii; i++) {
      validateIndex(min2[i], matrix._size[i]);
      validateIndex(max2[i], matrix._size[i]);
    }
    var mvalues = matrix._values;
    var mindex = matrix._index;
    var mptr = matrix._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i2, r) {
      pv[i2] = r[0];
      w[i2] = true;
    });
    var values = mvalues ? [] : undefined;
    var index = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index.length);
      for (k = mptr[j], kk = mptr[j + 1];k < kk; k++) {
        i = mindex[k];
        if (w[i] === true) {
          index.push(pv[i]);
          if (values) {
            values.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size,
      datatype: matrix._datatype
    });
  }
  function _setsubset(matrix, index, submatrix, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index.size();
    var isScalar = index.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix.set(index.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i = 0;
        var outer = 0;
        while (iSize[i] === 1 && sSize[i] === 1) {
          i++;
        }
        while (iSize[i] === 1) {
          outer++;
          i++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range = index.dimension(0);
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index.dimension(0);
        var secondDimensionRange = index.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix;
  }
  SparseMatrix.prototype.get = function(index) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix.prototype.set = function(index, v, defaultValue) {
    if (!isArray(index)) {
      throw new TypeError("Array expected");
    }
    if (index.length !== this._size.length) {
      throw new DimensionError(index.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i = index[0];
    var j = index[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar;
    var zero = 0;
    if (isString(this._datatype)) {
      eq = typed2.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
      zero = typed2.convert(0, this._datatype);
    }
    if (i > rows - 1 || j > columns - 1) {
      _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i) {
      if (!eq(v, zero)) {
        this._values[k] = v;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      if (!eq(v, zero)) {
        _insert(k, i, j, v, this._values, this._index, this._ptr);
      }
    }
    return this;
  };
  function _getValueIndex(i, top, bottom, index) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top;r < bottom; r++) {
      if (index[r] === i) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values, index, ptr) {
    values.splice(k, 1);
    index.splice(k, 1);
    for (var x = j + 1;x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i, j, v, values, index, ptr) {
    values.splice(k, 0, v);
    index.splice(k, 0, i);
    for (var x = j + 1;x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix.prototype.resize = function(size, defaultValue, copy) {
    if (!isCollection(size)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers " + "(size: " + format3(sizeArray) + ")");
      }
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize2(matrix, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar;
    var zero = 0;
    if (isString(matrix._datatype)) {
      eq = typed2.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      zero = typed2.convert(0, matrix._datatype);
      value = typed2.convert(value, matrix._datatype);
    }
    var ins = !eq(value, zero);
    var r = matrix._size[0];
    var c = matrix._size[1];
    var i, j, k;
    if (columns > c) {
      for (j = c;j < columns; j++) {
        matrix._ptr[j] = matrix._values.length;
        if (ins) {
          for (i = 0;i < r; i++) {
            matrix._values.push(value);
            matrix._index.push(i);
          }
        }
      }
      matrix._ptr[columns] = matrix._values.length;
    } else if (columns < c) {
      matrix._ptr.splice(columns + 1, c - columns);
      matrix._values.splice(matrix._ptr[columns], matrix._values.length);
      matrix._index.splice(matrix._ptr[columns], matrix._index.length);
    }
    c = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0;j < c; j++) {
          matrix._ptr[j] = matrix._ptr[j] + n;
          k = matrix._ptr[j + 1] + n;
          var p = 0;
          for (i = r;i < rows; i++, p++) {
            matrix._values.splice(k + p, 0, value);
            matrix._index.splice(k + p, 0, i);
            n++;
          }
        }
        matrix._ptr[c] = matrix._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0;j < c; j++) {
        matrix._ptr[j] = matrix._ptr[j] - d;
        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1] - d;
        for (k = k0;k < k1; k++) {
          i = matrix._index[k];
          if (i > rows - 1) {
            matrix._values.splice(k, 1);
            matrix._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix._ptr[j] = matrix._values.length;
    }
    matrix._size[0] = rows;
    matrix._size[1] = columns;
    return matrix;
  }
  SparseMatrix.prototype.reshape = function(sizes, copy) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 " + "(size: " + format3(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i = 0;i < m._ptr.length; i++) {
      for (var j = 0;j < m._ptr[i + 1] - m._ptr[i]; j++) {
        colIndex.push(i);
      }
    }
    var values = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0;_i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0;_i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h = 0;h < values.length; h++) {
      var _i3 = rowIndex[h];
      var _j = colIndex[h];
      var v = values[h];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix.prototype.clone = function() {
    var m = new SparseMatrix({
      values: this._values ? clone(this._values) : undefined,
      index: clone(this._index),
      ptr: clone(this._ptr),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var fastCallback = optimizeCallback(callback, me, "map");
    var invoke = function invoke(v, i, j) {
      return fastCallback(v, [i, j], me);
    };
    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values = [];
    var index = [];
    var ptr = [];
    var eq = equalScalar;
    var zero = 0;
    if (isString(matrix._datatype)) {
      eq = typed2.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
      zero = typed2.convert(0, matrix._datatype);
    }
    var invoke = function invoke(v, x, y) {
      var value2 = callback(v, x, y);
      if (!eq(value2, zero)) {
        values.push(value2);
        index.push(x);
      }
    };
    for (var j = minColumn;j <= maxColumn; j++) {
      ptr.push(values.length);
      var k0 = matrix._ptr[j];
      var k1 = matrix._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0;k < k1; k++) {
          var i = matrix._index[k];
          if (i >= minRow && i <= maxRow) {
            invoke(matrix._values[k], i - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0;_k < k1; _k++) {
          var _i4 = matrix._index[_k];
          _values[_i4] = matrix._values[_k];
        }
        for (var _i5 = minRow;_i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var fastCallback = optimizeCallback(callback, me, "forEach");
    for (var j = 0;j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0;k < k1; k++) {
          var i = this._index[k];
          fastCallback(this._values[k], [i, j], me);
        }
      } else {
        var values = {};
        for (var _k2 = k0;_k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values[_i6] = this._values[_k2];
        }
        for (var _i7 = 0;_i7 < rows; _i7++) {
          var value = _i7 in values ? values[_i7] : 0;
          fastCallback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0;j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0;k < k1; k++) {
        var i = this._index[k];
        yield {
          value: this._values[k],
          index: [i, j]
        };
      }
    }
  };
  SparseMatrix.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values, index, ptr, size, copy) {
    var rows = size[0];
    var columns = size[1];
    var a = [];
    var i, j;
    for (i = 0;i < rows; i++) {
      a[i] = [];
      for (j = 0;j < columns; j++) {
        a[i][j] = 0;
      }
    }
    for (j = 0;j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0;k < k1; k++) {
        i = index[k];
        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + `
`;
    for (var j = 0;j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0;k < k1; k++) {
        var i = this._index[k];
        str += `
    (` + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix.prototype.toString = function() {
    return format3(this.toArray());
  };
  SparseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values = [];
    var index = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper;j < columns && values.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0;x < k1; x++) {
        var i = this._index[x];
        if (i === j - kSuper + kSub) {
          values.push(this._values[x]);
          index[values.length - 1] = i - kSub;
          break;
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix.fromJSON = function(json) {
    return new SparseMatrix(json);
  };
  SparseMatrix.diagonal = function(size, value, k, defaultValue, datatype) {
    if (!isArray(size)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size = size.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar, [datatype, datatype]) || equalScalar;
      zero = typed2.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size[0];
    var columns = size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value() {
        return value;
      };
    }
    var values = [];
    var index = [];
    var ptr = [];
    for (var j = 0;j < columns; j++) {
      ptr.push(values.length);
      var i = j - kSuper;
      if (i >= 0 && i < n) {
        var v = _value(i);
        if (!eq(v, zero)) {
          index.push(i + kSub);
          values.push(v);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix({
      values,
      index,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix.prototype.swapRows = function(i, j) {
    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix._forEachRow = function(j, values, index, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0;k < k1; k++) {
      callback(index[k], values[k]);
    }
  };
  SparseMatrix._swapRows = function(x, y, columns, values, index, ptr) {
    for (var j = 0;j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index);
      var ky = _getValueIndex(y, k0, k1, index);
      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
        if (values) {
          var v = values[kx];
          values[kx] = values[ky];
          values[ky] = v;
        }
        continue;
      }
      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
        var vx = values ? values[kx] : undefined;
        index.splice(ky, 0, y);
        if (values) {
          values.splice(ky, 0, vx);
        }
        index.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values) {
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
        var vy = values ? values[ky] : undefined;
        index.splice(kx, 0, x);
        if (values) {
          values.splice(kx, 0, vy);
        }
        index.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values) {
          values.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/type/number.js
var name19 = "number";
var dependencies20 = ["typed"];
function getNonDecimalNumberParts(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i = 0;i < parts.fractionalPart.length; i++) {
    var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
    f += digitValue / Math.pow(parts.radix, i + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is not a valid number');
  }
  return result;
}
var createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var number = typed2("number", {
    "": function _() {
      return 0;
    },
    number: function number(x) {
      return x;
    },
    string: function string(x) {
      if (x === "NaN")
        return NaN;
      var nonDecimalNumberParts = getNonDecimalNumberParts(x);
      if (nonDecimalNumberParts) {
        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
      }
      var size = 0;
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        size = Number(wordSizeSuffixMatch[2]);
        x = wordSizeSuffixMatch[1];
      }
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is not a valid number');
      }
      if (wordSizeSuffixMatch) {
        if (num > 2 ** size - 1) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        if (num >= 2 ** (size - 1)) {
          num = num - 2 ** size;
        }
      }
      return num;
    },
    BigNumber: function BigNumber(x) {
      return x.toNumber();
    },
    bigint: function bigint(x) {
      return Number(x);
    },
    Fraction: function Fraction(x) {
      return x.valueOf();
    },
    Unit: typed2.referToSelf((self2) => (x) => {
      var clone4 = x.clone();
      clone4.value = self2(x.value);
      return clone4;
    }),
    null: function _null(x) {
      return 0;
    },
    "Unit, string | Unit": function Unit_string__Unit(unit, valuelessUnit) {
      return unit.toNumber(valuelessUnit);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  number.fromJSON = function(json) {
    return parseFloat(json.value);
  };
  return number;
});
// node_modules/mathjs/lib/esm/type/bigint.js
var name20 = "bigint";
var dependencies21 = ["typed"];
var createBigint = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var bigint = typed2("bigint", {
    "": function _() {
      return 0n;
    },
    bigint: function bigint(x) {
      return x;
    },
    number: function number(x) {
      return BigInt(x.toFixed());
    },
    BigNumber: function BigNumber(x) {
      return BigInt(x.round().toString());
    },
    Fraction: function Fraction(x) {
      return BigInt(x.valueOf().toFixed());
    },
    "string | boolean": function string__boolean(x) {
      return BigInt(x);
    },
    null: function _null(x) {
      return 0n;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  bigint.fromJSON = function(json) {
    return BigInt(json.value);
  };
  return bigint;
});
// node_modules/mathjs/lib/esm/type/string.js
var name21 = "string";
var dependencies22 = ["typed"];
var createString = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name21, {
    "": function _() {
      return "";
    },
    number: format,
    null: function _null(x) {
      return "null";
    },
    boolean: function boolean(x) {
      return x + "";
    },
    string: function string(x) {
      return x;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    any: function any(x) {
      return String(x);
    }
  });
});
// node_modules/mathjs/lib/esm/type/boolean.js
var name22 = "boolean";
var dependencies23 = ["typed"];
var createBoolean = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name22, {
    "": function _() {
      return false;
    },
    boolean: function boolean(x) {
      return x;
    },
    number: function number(x) {
      return !!x;
    },
    null: function _null(x) {
      return false;
    },
    BigNumber: function BigNumber(x) {
      return !x.isZero();
    },
    string: function string(x) {
      var lcase = x.toLowerCase();
      if (lcase === "true") {
        return true;
      } else if (lcase === "false") {
        return false;
      }
      var num = Number(x);
      if (x !== "" && !isNaN(num)) {
        return !!num;
      }
      throw new Error('Cannot convert "' + x + '" to a boolean');
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
var name23 = "bignumber";
var dependencies24 = ["typed", "BigNumber"];
var createBignumber = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
  var {
    typed: typed2,
    BigNumber
  } = _ref;
  return typed2("bignumber", {
    "": function _() {
      return new BigNumber(0);
    },
    number: function number(x) {
      return new BigNumber(x + "");
    },
    string: function string(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size = wordSizeSuffixMatch[2];
        var n = BigNumber(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber(2).pow(Number(size));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber(x);
    },
    BigNumber: function BigNumber(x) {
      return x;
    },
    bigint: function bigint(x) {
      return new BigNumber(x.toString());
    },
    Unit: typed2.referToSelf((self2) => (x) => {
      var clone4 = x.clone();
      clone4.value = self2(x.value);
      return clone4;
    }),
    Fraction: function Fraction(x) {
      return new BigNumber(String(x.n)).div(String(x.d)).times(String(x.s));
    },
    null: function _null(_x) {
      return new BigNumber(0);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/type/complex/function/complex.js
var name24 = "complex";
var dependencies25 = ["typed", "Complex"];
var createComplex = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
  var {
    typed: typed2,
    Complex: Complex2
  } = _ref;
  return typed2("complex", {
    "": function _() {
      return Complex2.ZERO;
    },
    number: function number(x) {
      return new Complex2(x, 0);
    },
    "number, number": function number_number(re, im) {
      return new Complex2(re, im);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(re, im) {
      return new Complex2(re.toNumber(), im.toNumber());
    },
    Fraction: function Fraction(x) {
      return new Complex2(x.valueOf(), 0);
    },
    Complex: function Complex(x) {
      return x.clone();
    },
    string: function string(x) {
      return Complex2(x);
    },
    null: function _null(x) {
      return Complex2(0);
    },
    Object: function Object(x) {
      if ("re" in x && "im" in x) {
        return new Complex2(x.re, x.im);
      }
      if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
        return new Complex2(x);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
var name25 = "fraction";
var dependencies26 = ["typed", "Fraction"];
var createFraction = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
  var {
    typed: typed2,
    Fraction: Fraction2
  } = _ref;
  return typed2("fraction", {
    number: function number(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction2(x);
    },
    string: function string(x) {
      return new Fraction2(x);
    },
    "number, number": function number_number(numerator, denominator) {
      return new Fraction2(numerator, denominator);
    },
    "bigint, bigint": function bigint_bigint(numerator, denominator) {
      return new Fraction2(numerator, denominator);
    },
    null: function _null(x) {
      return new Fraction2(0);
    },
    BigNumber: function BigNumber(x) {
      return new Fraction2(x.toString());
    },
    bigint: function bigint(x) {
      return new Fraction2(x.toString());
    },
    Fraction: function Fraction(x) {
      return x;
    },
    Unit: typed2.referToSelf((self2) => (x) => {
      var clone4 = x.clone();
      clone4.value = self2(x.value);
      return clone4;
    }),
    Object: function Object(x) {
      return new Fraction2(x);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
var name26 = "matrix";
var dependencies27 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
  var {
    typed: typed2,
    Matrix,
    DenseMatrix,
    SparseMatrix
  } = _ref;
  return typed2(name26, {
    "": function _() {
      return _create([]);
    },
    string: function string(format4) {
      return _create([], format4);
    },
    "string, string": function string_string(format4, datatype) {
      return _create([], format4, datatype);
    },
    Array: function Array(data) {
      return _create(data);
    },
    Matrix: function Matrix(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format4, datatype) {
    if (format4 === "dense" || format4 === "default" || format4 === undefined) {
      return new DenseMatrix(data, datatype);
    }
    if (format4 === "sparse") {
      return new SparseMatrix(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
  }
});
// node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
var name27 = "matrixFromFunction";
var dependencies28 = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
  var {
    typed: typed2,
    matrix,
    isZero
  } = _ref;
  return typed2(name27, {
    "Array | Matrix, function, string, string": function Array__Matrix_function_string_string(size, fn, format4, datatype) {
      return _create(size, fn, format4, datatype);
    },
    "Array | Matrix, function, string": function Array__Matrix_function_string(size, fn, format4) {
      return _create(size, fn, format4);
    },
    "Matrix, function": function Matrix_function(size, fn) {
      return _create(size, fn, "dense");
    },
    "Array, function": function Array_function(size, fn) {
      return _create(size, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function Array__Matrix_string_function(size, format4, fn) {
      return _create(size, fn, format4);
    },
    "Array | Matrix, string, string, function": function Array__Matrix_string_string_function(size, format4, datatype, fn) {
      return _create(size, fn, format4, datatype);
    }
  });
  function _create(size, fn, format4, datatype) {
    var m;
    if (datatype !== undefined) {
      m = matrix(format4, datatype);
    } else {
      m = matrix(format4);
    }
    m.resize(size);
    m.forEach(function(_, index) {
      var val = fn(index);
      if (isZero(val))
        return;
      m.set(index, val);
    });
    return m;
  }
});
// node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
var name28 = "matrixFromRows";
var dependencies29 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
  var {
    typed: typed2,
    matrix,
    flatten: flatten2,
    size
  } = _ref;
  return typed2(name28, {
    "...Array": function Array(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix(arr) {
      return matrix(_createArray(arr.map((m) => m.toArray())));
    }
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " ≠ " + (rowLength | 0));
      }
      result.push(flatten2(row));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
var name29 = "matrixFromColumns";
var dependencies30 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
  var {
    typed: typed2,
    matrix,
    flatten: flatten2,
    size
  } = _ref;
  return typed2(name29, {
    "...Array": function Array(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix(arr) {
      return matrix(_createArray(arr.map((m) => m.toArray())));
    }
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i = 0;i < N; i++) {
      result[i] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " ≠ " + (colLength | 0));
      }
      var f = flatten2(col);
      for (var _i = 0;_i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
// node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
var name30 = "splitUnit";
var dependencies31 = ["typed"];
var createSplitUnit = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name30, {
    "Unit, Array": function Unit_Array(unit, parts) {
      return unit.splitUnit(parts);
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
var name31 = "unaryMinus";
var dependencies32 = ["typed"];
var createUnaryMinus = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name31, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x) => x.neg(),
    bigint: (x) => -x,
    Unit: typed2.referToSelf((self2) => (x) => {
      var res = x.clone();
      res.value = typed2.find(self2, res.valueType())(x.value);
      return res;
    }),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2, true))
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
var name32 = "unaryPlus";
var dependencies33 = ["typed", "config", "numeric"];
var createUnaryPlus = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    numeric
  } = _ref;
  return typed2(name32, {
    number: unaryPlusNumber,
    Complex: function Complex(x) {
      return x;
    },
    BigNumber: function BigNumber(x) {
      return x;
    },
    bigint: function bigint(x) {
      return x;
    },
    Fraction: function Fraction(x) {
      return x;
    },
    Unit: function Unit(x) {
      return x.clone();
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2, true)),
    boolean: function boolean(x) {
      return numeric(x ? 1 : 0, config4.number);
    },
    string: function string(x) {
      return numeric(x, safeNumberType(x, config4));
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/abs.js
var name33 = "abs";
var dependencies34 = ["typed"];
var createAbs = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name33, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
    bigint: (x) => x < 0n ? -x : x,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2, true))
  });
});
// node_modules/mathjs/lib/esm/function/matrix/mapSlices.js
var name34 = "mapSlices";
var dependencies35 = ["typed", "isInteger"];
var createMapSlices = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name34, {
    "Array | Matrix, number | BigNumber, function": function Array__Matrix_number__BigNumber_function(mat, dim, callback) {
      if (!isInteger2(dim)) {
        throw new TypeError("Integer number expected for dimension");
      }
      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
      if (dim < 0 || dim >= size.length) {
        throw new IndexError(dim, size.length);
      }
      if (isMatrix(mat)) {
        return mat.create(_mapSlices(mat.valueOf(), dim, callback), mat.datatype());
      } else {
        return _mapSlices(mat, dim, callback);
      }
    }
  });
}, {
  formerly: "apply"
});
function _mapSlices(mat, dim, callback) {
  var i, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch2(mat);
      ret = [];
      for (i = 0;i < tran.length; i++) {
        ret[i] = _mapSlices(tran[i], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i = 0;i < mat.length; i++) {
      ret[i] = _mapSlices(mat[i], dim - 1, callback);
    }
    return ret;
  }
}
function _switch2(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for (j = 0;j < J; j++) {
    var tmp = [];
    for (i = 0;i < I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}
// node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
var name35 = "addScalar";
var dependencies36 = ["typed"];
var createAddScalar = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name35, {
    "number, number": addNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.plus(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x + y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === undefined) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === undefined) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js
var name36 = "subtractScalar";
var dependencies37 = ["typed"];
var createSubtractScalar = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name36, {
    "number, number": subtractNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.sub(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.minus(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x - y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.sub(y);
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === undefined) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === undefined) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
var name37 = "cbrt";
var dependencies38 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
  var {
    config: config4,
    typed: typed2,
    isNegative,
    unaryMinus,
    matrix,
    Complex: Complex2,
    BigNumber,
    Fraction: Fraction2
  } = _ref;
  return typed2(name37, {
    number: cbrtNumber,
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber(x) {
      return x.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x, allRoots) {
    var arg3 = x.arg() / 3;
    var abs2 = x.abs();
    var principal = new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3).exp());
    if (allRoots) {
      var all = [principal, new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 + Math.PI * 2 / 3).exp()), new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 - Math.PI * 2 / 3).exp())];
      return config4.matrix === "Array" ? all : matrix(all);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x) {
    if (x.value && isComplex(x.value)) {
      var result = x.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x.value);
      return result;
    } else {
      var negate = isNegative(x.value);
      if (negate) {
        x.value = unaryMinus(x.value);
      }
      var third;
      if (isBigNumber(x.value)) {
        third = new BigNumber(1).div(3);
      } else if (isFraction(x.value)) {
        third = new Fraction2(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x.pow(third);
      if (negate) {
        _result.value = unaryMinus(_result.value);
      }
      return _result;
    }
  }
});
// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
var name38 = "matAlgo11xS0s";
var dependencies39 = ["typed", "equalScalar"];
var createMatAlgo11xS0s = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return function matAlgo11xS0s(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        var i = aindex[k];
        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        if (!eq(v, zero)) {
          cindex.push(i);
          cvalues.push(v);
        }
      }
    }
    cptr[columns] = cindex.length;
    return s.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js
var name39 = "matAlgo12xSfs";
var dependencies40 = ["typed", "DenseMatrix"];
var createMatAlgo12xSfs = /* @__PURE__ */ factory(name39, dependencies40, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix
  } = _ref;
  return function matAlgo12xSfs(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i = 0;i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        } else {
          cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
var name40 = "matAlgo14xDs";
var dependencies41 = ["typed"];
var createMatAlgo14xDs = /* @__PURE__ */ factory(name40, dependencies41, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo14xDs(a, b, callback, inverse) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: clone(asize),
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv, inverse) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i = 0;i < n; i++) {
        cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
      }
    } else {
      for (var j = 0;j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
var name41 = "ceil";
var dependencies42 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var bigTen = new decimal_default(10);
var createCeilNumber = /* @__PURE__ */ factory(name41, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed2,
    config: config4,
    round: round2
  } = _ref;
  function _ceilNumber(x) {
    var c = Math.ceil(x);
    var r = round2(x);
    if (c === r)
      return c;
    if (nearlyEqual(x, r, config4.relTol, config4.absTol) && !nearlyEqual(x, c, config4.relTol, config4.absTol)) {
      return r;
    }
    return c;
  }
  return typed2(name41, {
    number: _ceilNumber,
    "number, number": function number_number(x, n) {
      if (!isInteger(n)) {
        throw new RangeError("number of decimals in function ceil must be an integer");
      }
      if (n < 0 || n > 15) {
        throw new RangeError("number of decimals in ceil number must be in range 0-15");
      }
      var shift = 10 ** n;
      return _ceilNumber(x * shift) / shift;
    }
  });
});
var createCeil = /* @__PURE__ */ factory(name41, dependencies42, (_ref2) => {
  var {
    typed: typed2,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var ceilNumber = createCeilNumber({
    typed: typed2,
    config: config4,
    round: round2
  });
  function _bigCeil(x) {
    var bne = (a, b) => nearlyEqual2(a, b, config4.relTol, config4.absTol);
    var c = x.ceil();
    var r = round2(x);
    if (c.eq(r))
      return c;
    if (bne(x, r) && !bne(x, c))
      return r;
    return c;
  }
  return typed2("ceil", {
    number: ceilNumber.signatures.number,
    "number,number": ceilNumber.signatures["number,number"],
    Complex: function Complex(x) {
      return x.ceil();
    },
    "Complex, number": function Complex_number(x, n) {
      return x.ceil(n);
    },
    "Complex, BigNumber": function Complex_BigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    BigNumber: _bigCeil,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, n) {
      var shift = bigTen.pow(n);
      return _bigCeil(x.mul(shift)).div(shift);
    },
    bigint: (b) => b,
    "bigint, number": (b, _dummy) => b,
    "bigint, BigNumber": (b, _dummy) => b,
    Fraction: function Fraction(x) {
      return x.ceil();
    },
    "Fraction, number": function Fraction_number(x, n) {
      return x.ceil(n);
    },
    "Fraction, BigNumber": function Fraction_BigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    "Unit, number, Unit": typed2.referToSelf((self2) => function(x, n, unit) {
      var valueless = x.toNumeric(unit);
      return unit.multiply(self2(valueless, n));
    }),
    "Unit, BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => self2(x, n.toNumber(), unit)),
    "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => {
      return deepMap(x, (value) => self2(value, n, unit), true);
    }),
    "Array | Matrix | Unit, Unit": typed2.referToSelf((self2) => (x, unit) => self2(x, 0, unit)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i) => self2(i, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/cube.js
var name42 = "cube";
var dependencies43 = ["typed"];
var createCube = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name42, {
    number: cubeNumber,
    Complex: function Complex(x) {
      return x.mul(x).mul(x);
    },
    BigNumber: function BigNumber(x) {
      return x.times(x).times(x);
    },
    bigint: function bigint(x) {
      return x * x * x;
    },
    Fraction: function Fraction(x) {
      return x.pow(3);
    },
    Unit: function Unit(x) {
      return x.pow(3);
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/exp.js
var name43 = "exp";
var dependencies44 = ["typed"];
var createExp = /* @__PURE__ */ factory(name43, dependencies44, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name43, {
    number: expNumber,
    Complex: function Complex(x) {
      return x.exp();
    },
    BigNumber: function BigNumber(x) {
      return x.exp();
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
var name44 = "expm1";
var dependencies45 = ["typed", "Complex"];
var createExpm1 = /* @__PURE__ */ factory(name44, dependencies45, (_ref) => {
  var {
    typed: typed2,
    Complex: _Complex
  } = _ref;
  return typed2(name44, {
    number: expm1Number,
    Complex: function Complex(x) {
      var r = Math.exp(x.re);
      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
    },
    BigNumber: function BigNumber(x) {
      return x.exp().minus(1);
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/fix.js
var name45 = "fix";
var dependencies46 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
var createFixNumber = /* @__PURE__ */ factory(name45, ["typed", "ceil", "floor"], (_ref) => {
  var {
    typed: typed2,
    ceil: ceil2,
    floor: floor2
  } = _ref;
  return typed2(name45, {
    number: function number(x) {
      return x > 0 ? floor2(x) : ceil2(x);
    },
    "number, number": function number_number(x, n) {
      return x > 0 ? floor2(x, n) : ceil2(x, n);
    }
  });
});
var createFix = /* @__PURE__ */ factory(name45, dependencies46, (_ref2) => {
  var {
    typed: typed2,
    Complex: _Complex,
    matrix,
    ceil: ceil2,
    floor: floor2,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  } = _ref2;
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var fixNumber = createFixNumber({
    typed: typed2,
    ceil: ceil2,
    floor: floor2
  });
  return typed2("fix", {
    number: fixNumber.signatures.number,
    "number, number | BigNumber": fixNumber.signatures["number,number"],
    Complex: function Complex(x) {
      return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
    },
    "Complex, number": function Complex_number(x, n) {
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    "Complex, BigNumber": function Complex_BigNumber(x, bn) {
      var n = bn.toNumber();
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    BigNumber: function BigNumber(x) {
      return x.isNegative() ? ceil2(x) : floor2(x);
    },
    "BigNumber, number | BigNumber": function BigNumber_number__BigNumber(x, n) {
      return x.isNegative() ? ceil2(x, n) : floor2(x, n);
    },
    bigint: (b) => b,
    "bigint, number": (b, _dummy) => b,
    "bigint, BigNumber": (b, _dummy) => b,
    Fraction: function Fraction(x) {
      return x.s < 0n ? x.ceil() : x.floor();
    },
    "Fraction, number | BigNumber": function Fraction_number__BigNumber(x, n) {
      return x.s < 0n ? ceil2(x, n) : floor2(x, n);
    },
    "Unit, number, Unit": typed2.referToSelf((self2) => function(x, n, unit) {
      var valueless = x.toNumeric(unit);
      return unit.multiply(self2(valueless, n));
    }),
    "Unit, BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => self2(x, n.toNumber(), unit)),
    "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => {
      return deepMap(x, (value) => self2(value, n, unit), true);
    }),
    "Array | Matrix | Unit, Unit": typed2.referToSelf((self2) => (x, unit) => self2(x, 0, unit)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array | Matrix, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i) => self2(i, n), true);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/floor.js
var name46 = "floor";
var dependencies47 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var bigTen2 = new decimal_default(10);
var createFloorNumber = /* @__PURE__ */ factory(name46, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed2,
    config: config4,
    round: round2
  } = _ref;
  function _floorNumber(x) {
    var f = Math.floor(x);
    var r = round2(x);
    if (f === r)
      return f;
    if (nearlyEqual(x, r, config4.relTol, config4.absTol) && !nearlyEqual(x, f, config4.relTol, config4.absTol)) {
      return r;
    }
    return f;
  }
  return typed2(name46, {
    number: _floorNumber,
    "number, number": function number_number(x, n) {
      if (!isInteger(n)) {
        throw new RangeError("number of decimals in function floor must be an integer");
      }
      if (n < 0 || n > 15) {
        throw new RangeError("number of decimals in floor number must be in range 0 - 15");
      }
      var shift = 10 ** n;
      return _floorNumber(x * shift) / shift;
    }
  });
});
var createFloor = /* @__PURE__ */ factory(name46, dependencies47, (_ref2) => {
  var {
    typed: typed2,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var floorNumber = createFloorNumber({
    typed: typed2,
    config: config4,
    round: round2
  });
  function _bigFloor(x) {
    var bne = (a, b) => nearlyEqual2(a, b, config4.relTol, config4.absTol);
    var f = x.floor();
    var r = round2(x);
    if (f.eq(r))
      return f;
    if (bne(x, r) && !bne(x, f))
      return r;
    return f;
  }
  return typed2("floor", {
    number: floorNumber.signatures.number,
    "number,number": floorNumber.signatures["number,number"],
    Complex: function Complex(x) {
      return x.floor();
    },
    "Complex, number": function Complex_number(x, n) {
      return x.floor(n);
    },
    "Complex, BigNumber": function Complex_BigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    BigNumber: _bigFloor,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, n) {
      var shift = bigTen2.pow(n);
      return _bigFloor(x.mul(shift)).div(shift);
    },
    bigint: (b) => b,
    "bigint, number": (b, _dummy) => b,
    "bigint, BigNumber": (b, _dummy) => b,
    Fraction: function Fraction(x) {
      return x.floor();
    },
    "Fraction, number": function Fraction_number(x, n) {
      return x.floor(n);
    },
    "Fraction, BigNumber": function Fraction_BigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    "Unit, number, Unit": typed2.referToSelf((self2) => function(x, n, unit) {
      var valueless = x.toNumeric(unit);
      return unit.multiply(self2(valueless, n));
    }),
    "Unit, BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => self2(x, n.toNumber(), unit)),
    "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => {
      return deepMap(x, (value) => self2(value, n, unit), true);
    }),
    "Array | Matrix | Unit, Unit": typed2.referToSelf((self2) => (x, unit) => self2(x, 0, unit)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i) => self2(i, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
var name47 = "matAlgo02xDS0";
var dependencies48 = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === undefined ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        var i = bindex[k];
        var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        if (!eq(cij, zero)) {
          cindex.push(i);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js
var name48 = "matAlgo03xDSf";
var dependencies49 = ["typed"];
var createMatAlgo03xDSf = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === undefined ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    for (var z = 0;z < rows; z++) {
      cdata[z] = [];
    }
    var x = [];
    var w = [];
    for (var j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        var i = bindex[k];
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      for (var y = 0;y < rows; y++) {
        if (w[y] === mark) {
          cdata[y][j] = x[y];
        } else {
          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js
var name49 = "matAlgo05xSfSf";
var dependencies50 = ["typed", "equalScalar"];
var createMatAlgo05xSfSf = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return function matAlgo05xSfSf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var xa = cvalues ? [] : undefined;
    var xb = cvalues ? [] : undefined;
    var wa = [];
    var wb = [];
    var i, j, k, k1;
    for (j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k = aptr[j], k1 = aptr[j + 1];k < k1; k++) {
        i = aindex[k];
        cindex.push(i);
        wa[i] = mark;
        if (xa) {
          xa[i] = avalues[k];
        }
      }
      for (k = bptr[j], k1 = bptr[j + 1];k < k1; k++) {
        i = bindex[k];
        if (wa[i] !== mark) {
          cindex.push(i);
        }
        wb[i] = mark;
        if (xb) {
          xb[i] = bvalues[k];
        }
      }
      if (cvalues) {
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          var wai = wa[i];
          var wbi = wb[i];
          if (wai === mark || wbi === mark) {
            var va = wai === mark ? xa[i] : zero;
            var vb = wbi === mark ? xb[i] : zero;
            var vc = cf(va, vb);
            if (!eq(vc, zero)) {
              cvalues.push(vc);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js
var name50 = "matAlgo13xDD";
var dependencies51 = ["typed"];
var createMatAlgo13xDD = /* @__PURE__ */ factory(name50, dependencies51, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo13xDD(a, b, callback) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var csize = [];
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    for (var s = 0;s < asize.length; s++) {
      if (asize[s] !== bsize[s]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      csize[s] = asize[s];
    }
    var dt;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i = 0;i < n; i++) {
        cv[i] = f(av[i], bv[i]);
      }
    } else {
      for (var j = 0;j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js
function broadcast(A, B) {
  if (deepStrictEqual(A.size(), B.size())) {
    return [A, B];
  }
  var newSize = broadcastSizes(A.size(), B.size());
  return [A, B].map((M) => _broadcastTo(M, newSize));
}
function _broadcastTo(M, size) {
  if (deepStrictEqual(M.size(), size)) {
    return M;
  }
  return M.create(broadcastTo(M.valueOf(), size), M.datatype());
}

// node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js
var name51 = "matrixAlgorithmSuite";
var dependencies52 = ["typed", "matrix"];
var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name51, dependencies52, (_ref) => {
  var {
    typed: typed2,
    matrix
  } = _ref;
  var matAlgo13xDD = createMatAlgo13xDD({
    typed: typed2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return function matrixAlgorithmSuite(options) {
    var elop = options.elop;
    var SD = options.SD || options.DS;
    var matrixSignatures;
    if (elop) {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": (x, y) => matAlgo13xDD(...broadcast(x, y), elop),
        "Array, Array": (x, y) => matAlgo13xDD(...broadcast(matrix(x), matrix(y)), elop).valueOf(),
        "Array, DenseMatrix": (x, y) => matAlgo13xDD(...broadcast(matrix(x), y), elop),
        "DenseMatrix, Array": (x, y) => matAlgo13xDD(...broadcast(x, matrix(y)), elop)
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y) => options.SS(...broadcast(x, y), elop, false);
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y) => options.DS(...broadcast(x, y), elop, false);
        matrixSignatures["Array, SparseMatrix"] = (x, y) => options.DS(...broadcast(matrix(x), y), elop, false);
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y) => SD(...broadcast(y, x), elop, true);
        matrixSignatures["SparseMatrix, Array"] = (x, y) => SD(...broadcast(matrix(y), x), elop, true);
      }
    } else {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(x, y), self2);
        }),
        "Array, Array": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(matrix(x), matrix(y)), self2).valueOf();
        }),
        "Array, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(matrix(x), y), self2);
        }),
        "DenseMatrix, Array": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(x, matrix(y)), self2);
        })
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.SS(...broadcast(x, y), self2, false);
        });
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.DS(...broadcast(x, y), self2, false);
        });
        matrixSignatures["Array, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.DS(...broadcast(matrix(x), y), self2, false);
        });
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return SD(...broadcast(y, x), self2, true);
        });
        matrixSignatures["SparseMatrix, Array"] = typed2.referToSelf((self2) => (x, y) => {
          return SD(...broadcast(matrix(y), x), self2, true);
        });
      }
    }
    var scalar = options.scalar || "any";
    var Ds = options.Ds || options.Ss;
    if (Ds) {
      if (elop) {
        matrixSignatures["DenseMatrix," + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);
        matrixSignatures[scalar + ", DenseMatrix"] = (x, y) => matAlgo14xDs(y, x, elop, true);
        matrixSignatures["Array," + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();
        matrixSignatures[scalar + ", Array"] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();
      } else {
        matrixSignatures["DenseMatrix," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(x, y, self2, false);
        });
        matrixSignatures[scalar + ", DenseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(y, x, self2, true);
        });
        matrixSignatures["Array," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix(x), y, self2, false).valueOf();
        });
        matrixSignatures[scalar + ", Array"] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
        });
      }
    }
    var sS = options.sS !== undefined ? options.sS : options.Ss;
    if (elop) {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = (x, y) => options.Ss(x, y, elop, false);
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = (x, y) => sS(y, x, elop, true);
      }
    } else {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return options.Ss(x, y, self2, false);
        });
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return sS(y, x, self2, true);
        });
      }
    }
    if (elop && elop.signatures) {
      extend(matrixSignatures, elop.signatures);
    }
    return matrixSignatures;
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/mod.js
var name52 = "mod";
var dependencies53 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createMod = /* @__PURE__ */ factory(name52, dependencies53, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var floor2 = createFloor({
    typed: typed2,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name52, {
    "number, number": _modNumber,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return y.isZero() ? x : x.sub(y.mul(floor2(x.div(y))));
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      if (y === 0n) {
        return x;
      }
      if (x < 0) {
        var m = x % y;
        return m === 0n ? m : m + y;
      }
      return x % y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return y.equals(0) ? x : x.sub(y.mul(floor2(x.div(y))));
    }
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
  function _modNumber(x, y) {
    return y === 0 ? x : x - y * floor2(x / y);
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
var name53 = "matAlgo01xDSid";
var dependencies54 = ["typed"];
var createMatAlgo01xDSid = /* @__PURE__ */ factory(name53, dependencies54, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === undefined ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt !== "mixed" && adt === bdt ? adt : undefined;
    var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
    var i, j;
    var cdata = [];
    for (i = 0;i < rows; i++) {
      cdata[i] = [];
    }
    var x = [];
    var w = [];
    for (j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        i = bindex[k];
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      for (i = 0;i < rows; i++) {
        if (w[i] === mark) {
          cdata[i][j] = x[i];
        } else {
          cdata[i][j] = adata[i][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
var name54 = "matAlgo04xSidSid";
var dependencies55 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = /* @__PURE__ */ factory(name54, dependencies55, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return function matAlgo04xSidSid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : undefined;
    var xb = avalues && bvalues ? [] : undefined;
    var wa = [];
    var wb = [];
    var i, j, k, k0, k1;
    for (j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        i = aindex[k];
        cindex.push(i);
        wa[i] = mark;
        if (xa) {
          xa[i] = avalues[k];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        i = bindex[k];
        if (wa[i] === mark) {
          if (xa) {
            var v = cf(xa[i], bvalues[k]);
            if (!eq(v, zero)) {
              xa[i] = v;
            } else {
              wa[i] = null;
            }
          }
        } else {
          cindex.push(i);
          wb[i] = mark;
          if (xb) {
            xb[i] = bvalues[k];
          }
        }
      }
      if (xa && xb) {
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          if (wa[i] === mark) {
            cvalues[k] = xa[i];
            k++;
          } else if (wb[i] === mark) {
            cvalues[k] = xb[i];
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
var name55 = "matAlgo10xSids";
var dependencies56 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = /* @__PURE__ */ factory(name55, dependencies56, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix
  } = _ref;
  return function matAlgo10xSids(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0;j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i = 0;i < rows; i++) {
        if (j === 0) {
          cdata[i] = [];
        }
        if (w[i] === mark) {
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        } else {
          cdata[i][j] = b;
        }
      }
    }
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/error/ArgumentsError.js
function ArgumentsError(fn, count, min2, max2) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.fn = fn;
  this.count = count;
  this.min = min2;
  this.max = max2;
  this.message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min2 + (max2 !== undefined && max2 !== null ? "-" + max2 : "") + " expected)";
  this.stack = new Error().stack;
}
ArgumentsError.prototype = new Error;
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = "ArgumentsError";
ArgumentsError.prototype.isArgumentsError = true;

// node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
var name56 = "gcd";
var dependencies57 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"];
var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
function is1d(array) {
  return !array.some((element) => Array.isArray(element));
}
var createGcd = /* @__PURE__ */ factory(name56, dependencies57, (_ref) => {
  var {
    typed: typed2,
    matrix,
    config: config4,
    round: round2,
    equalScalar,
    zeros: zeros2,
    BigNumber,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var mod2 = createMod({
    typed: typed2,
    config: config4,
    round: round2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat: concat2
  });
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name56, {
    "number, number": _gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x, y) => x.gcd(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }), {
    [gcdManyTypesSignature]: typed2.referToSelf((self2) => (a, b, args) => {
      var res = self2(a, b);
      for (var i = 0;i < args.length; i++) {
        res = self2(res, args[i]);
      }
      return res;
    }),
    Array: typed2.referToSelf((self2) => (array) => {
      if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
        return self2(...array[0]);
      }
      if (is1d(array)) {
        return self2(...array);
      }
      throw new ArgumentsError("gcd() supports only 1d matrices!");
    }),
    Matrix: typed2.referToSelf((self2) => (matrix2) => {
      return self2(matrix2.toArray());
    })
  });
  function _gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = mod2(a, b);
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero = new BigNumber(0);
    while (!b.isZero()) {
      var r = mod2(a, b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
});
// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
var name57 = "matAlgo06xS0S0";
var dependencies58 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name57, dependencies58, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return function matAlgo06xS0S0(a, b, callback) {
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : undefined;
    var w = [];
    var u = [];
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a, j, w, x, u, mark, cindex, cf);
      scatter(b, j, w, x, u, mark, cindex, cf);
      if (x) {
        var k = cptr[j];
        while (k < cindex.length) {
          var i = cindex[k];
          if (u[i] === mark) {
            var v = x[i];
            if (!eq(v, zero)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          } else {
            cindex.splice(k, 1);
          }
        }
      } else {
        var p = cptr[j];
        while (p < cindex.length) {
          var r = cindex[p];
          if (u[r] !== mark) {
            cindex.splice(p, 1);
          } else {
            p++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
var name58 = "lcm";
var dependencies59 = ["typed", "matrix", "equalScalar", "concat"];
var createLcm = /* @__PURE__ */ factory(name58, dependencies59, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed2.referToSelf((self2) => (a, b, args) => {
    var res = self2(a, b);
    for (var i = 0;i < args.length; i++) {
      res = self2(res, args[i]);
    }
    return res;
  });
  return typed2(name58, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x, y) => x.lcm(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }), lcmManySignature);
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a.isZero()) {
      return a;
    }
    if (b.isZero()) {
      return b;
    }
    var prod = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod.div(a).abs();
  }
});
// node_modules/mathjs/lib/esm/utils/bigint.js
function promoteLogarithm(log16, numberLog, config4, cplx) {
  return function(b) {
    if (b > 0 || config4.predictable) {
      if (b <= 0)
        return NaN;
      var s = b.toString(16);
      var s15 = s.substring(0, 15);
      return log16 * (s.length - s15.length) + numberLog(Number("0x" + s15));
    }
    return cplx(b.toNumber());
  };
}

// node_modules/mathjs/lib/esm/function/arithmetic/log10.js
var name59 = "log10";
var dependencies60 = ["typed", "config", "Complex"];
var log16 = log10Number(16);
var createLog10 = /* @__PURE__ */ factory(name59, dependencies60, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2
  } = _ref;
  function complexLog(c) {
    return c.log().div(Math.LN10);
  }
  function complexLogNumber(x) {
    return complexLog(new Complex2(x, 0));
  }
  return typed2(name59, {
    number: function number(x) {
      if (x >= 0 || config4.predictable) {
        return log10Number(x);
      } else {
        return complexLogNumber(x);
      }
    },
    bigint: promoteLogarithm(log16, log10Number, config4, complexLogNumber),
    Complex: complexLog,
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config4.predictable) {
        return x.log();
      } else {
        return complexLogNumber(x.toNumber());
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/log2.js
var name60 = "log2";
var dependencies61 = ["typed", "config", "Complex"];
var createLog2 = /* @__PURE__ */ factory(name60, dependencies61, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2
  } = _ref;
  function complexLog2Number(x) {
    return _log2Complex(new Complex2(x, 0));
  }
  return typed2(name60, {
    number: function number(x) {
      if (x >= 0 || config4.predictable) {
        return log2Number(x);
      } else {
        return complexLog2Number(x);
      }
    },
    bigint: promoteLogarithm(4, log2Number, config4, complexLog2Number),
    Complex: _log2Complex,
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config4.predictable) {
        return x.log(2);
      } else {
        return complexLog2Number(x.toNumber());
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  function _log2Complex(x) {
    var newX = Math.sqrt(x.re * x.re + x.im * x.im);
    return new Complex2(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
  }
});
// node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
var name61 = "multiplyScalar";
var dependencies62 = ["typed"];
var createMultiplyScalar = /* @__PURE__ */ factory(name61, dependencies62, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.times(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x * y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
var name62 = "multiply";
var dependencies63 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = /* @__PURE__ */ factory(name62, dependencies63, (_ref) => {
  var {
    typed: typed2,
    matrix,
    addScalar,
    multiplyScalar,
    equalScalar,
    dot
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar, [dt, dt]);
      mf = typed2.find(multiplyScalar, [dt, dt]);
    }
    var c = [];
    for (var j = 0;j < bcolumns; j++) {
      var sum2 = mf(adata[0], bdata[0][j]);
      for (var i = 1;i < alength; i++) {
        sum2 = af(sum2, mf(adata[i], bdata[i][j]));
      }
      c[j] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  }
  var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar, [dt, dt]);
      mf = typed2.find(multiplyScalar, [dt, dt]);
    }
    var c = [];
    for (var i = 0;i < arows; i++) {
      var row = adata[i];
      var sum2 = mf(row[0], bdata[0]);
      for (var j = 1;j < acolumns; j++) {
        sum2 = af(sum2, mf(row[j], bdata[j]));
      }
      c[i] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar, [dt, dt]);
      mf = typed2.find(multiplyScalar, [dt, dt]);
    }
    var c = [];
    for (var i = 0;i < arows; i++) {
      var row = adata[i];
      c[i] = [];
      for (var j = 0;j < bcolumns; j++) {
        var sum2 = mf(row[0], bdata[0][j]);
        for (var x = 1;x < acolumns; x++) {
          sum2 = af(sum2, mf(row[x], bdata[x][j]));
        }
        c[i][j] = sum2;
      }
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar, [dt, dt]);
      mf = typed2.find(multiplyScalar, [dt, dt]);
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
    for (var jb = 0;jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i = 0;i < arows; i++) {
          var mark = i + 1;
          var cij = undefined;
          for (var kb = kb0;kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero)) {
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar, [dt, dt]);
      mf = typed2.find(multiplyScalar, [dt, dt]);
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0;ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0;p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    var eq = equalScalar;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar, [dt, dt]);
      mf = typed2.find(multiplyScalar, [dt, dt]);
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
    var x = [];
    var w = [];
    for (var jb = 0;jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0;ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0;p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values = avalues && bvalues;
    var dt;
    var af = addScalar;
    var mf = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar, [dt, dt]);
      mf = typed2.find(multiplyScalar, [dt, dt]);
    }
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
    var x = values ? [] : undefined;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0;jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0;kb < kb1; kb++) {
        ib = bindex[kb];
        if (values) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0;ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0;p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  return typed2(name62, multiplyScalar, {
    "Array, Array": typed2.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = selfMM(matrix(x), matrix(y));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function Matrix_Matrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": typed2.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix(y))),
    "Array, Matrix": typed2.referToSelf((self2) => (x, y) => {
      return self2(matrix(x, y.storage()), y);
    }),
    "SparseMatrix, any": function SparseMatrix_any(x, y) {
      return matAlgo11xS0s(x, y, multiplyScalar, false);
    },
    "DenseMatrix, any": function DenseMatrix_any(x, y) {
      return matAlgo14xDs(x, y, multiplyScalar, false);
    },
    "any, SparseMatrix": function any_SparseMatrix(x, y) {
      return matAlgo11xS0s(y, x, multiplyScalar, true);
    },
    "any, DenseMatrix": function any_DenseMatrix(x, y) {
      return matAlgo14xDs(y, x, multiplyScalar, true);
    },
    "Array, any": function Array_any(x, y) {
      return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();
    },
    "any, Array": function any_Array(x, y) {
      return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();
    },
    "any, any": multiplyScalar,
    "any, any, ...any": typed2.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i = 0;i < rest.length; i++) {
        result = self2(result, rest[i]);
      }
      return result;
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
var name63 = "nthRoot";
var dependencies64 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
var createNthRoot = /* @__PURE__ */ factory(name63, dependencies64, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    BigNumber: _BigNumber,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed2(name63, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix(x), 2).valueOf()),
    DenseMatrix: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
    SparseMatrix: typed2.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
    "SparseMatrix, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo06xS0S0(x, y, self2);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo01xDSid(x, y, self2, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed2.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix(x), y)),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo11xS0s(y, x, self2, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: false
  }));
  function _bigNthRoot(a, root) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero = new _BigNumber(0);
    var one = new Big(1);
    var inv = root.isNegative();
    if (inv) {
      root = root.neg();
    }
    if (root.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a.isZero()) {
      return inv ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv ? zero : a;
    }
    var x = a.abs().pow(one.div(root));
    x = a.isNeg() ? x.neg() : x;
    return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
  }
});
// node_modules/mathjs/lib/esm/function/arithmetic/sign.js
var name64 = "sign";
var dependencies65 = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = /* @__PURE__ */ factory(name64, dependencies65, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber,
    complex,
    Fraction: _Fraction
  } = _ref;
  return typed2(name64, {
    number: signNumber,
    Complex: function Complex(x) {
      return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(x.cmp(0));
    },
    bigint: function bigint(x) {
      return x > 0n ? 1n : x < 0n ? -1n : 0n;
    },
    Fraction: function Fraction(x) {
      return new _Fraction(x.s);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2, true)),
    Unit: typed2.referToSelf((self2) => (x) => {
      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed2.find(self2, x.valueType())(x.value);
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
var name65 = "sqrt";
var dependencies66 = ["config", "typed", "Complex"];
var createSqrt = /* @__PURE__ */ factory(name65, dependencies66, (_ref) => {
  var {
    config: config4,
    typed: typed2,
    Complex: Complex2
  } = _ref;
  return typed2("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex(x) {
      return x.sqrt();
    },
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config4.predictable) {
        return x.sqrt();
      } else {
        return _sqrtNumber(x.toNumber());
      }
    },
    Unit: function Unit(x) {
      return x.pow(0.5);
    }
  });
  function _sqrtNumber(x) {
    if (isNaN(x)) {
      return NaN;
    } else if (x >= 0 || config4.predictable) {
      return Math.sqrt(x);
    } else {
      return new Complex2(x, 0).sqrt();
    }
  }
});
// node_modules/mathjs/lib/esm/function/arithmetic/square.js
var name66 = "square";
var dependencies67 = ["typed"];
var createSquare = /* @__PURE__ */ factory(name66, dependencies67, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name66, {
    number: squareNumber,
    Complex: function Complex(x) {
      return x.mul(x);
    },
    BigNumber: function BigNumber(x) {
      return x.times(x);
    },
    bigint: function bigint(x) {
      return x * x;
    },
    Fraction: function Fraction(x) {
      return x.mul(x);
    },
    Unit: function Unit(x) {
      return x.pow(2);
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
var name67 = "subtract";
var dependencies68 = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"];
var createSubtract = /* @__PURE__ */ factory(name67, dependencies68, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    subtractScalar,
    unaryMinus,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name67, {
    "any, any": subtractScalar
  }, matrixAlgorithmSuite({
    elop: subtractScalar,
    SS: matAlgo05xSfSf,
    DS: matAlgo01xDSid,
    SD: matAlgo03xDSf,
    Ss: matAlgo12xSfs,
    sS: matAlgo10xSids
  }));
});
// node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
var name68 = "xgcd";
var dependencies69 = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = /* @__PURE__ */ factory(name68, dependencies69, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    BigNumber
  } = _ref;
  return typed2(name68, {
    "number, number": function number_number(a, b) {
      var res = xgcdNumber(a, b);
      return config4.matrix === "Array" ? res : matrix(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
  });
  function _xgcdBigNumber(a, b) {
    var t;
    var q;
    var r;
    var zero = new BigNumber(0);
    var one = new BigNumber(1);
    var x = zero;
    var lastx = one;
    var y = one;
    var lasty = zero;
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);
      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;
      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return config4.matrix === "Array" ? res : matrix(res);
  }
});
// node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
var name69 = "invmod";
var dependencies70 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = /* @__PURE__ */ factory(name69, dependencies70, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    BigNumber,
    xgcd,
    equal,
    smaller,
    mod: mod2,
    add: add2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name69, {
    "number, number": invmod,
    "BigNumber, BigNumber": invmod
  });
  function invmod(a, b) {
    if (!isInteger2(a) || !isInteger2(b))
      throw new Error("Parameters in function invmod must be integer numbers");
    a = mod2(a, b);
    if (equal(b, 0))
      throw new Error("Divisor must be non zero");
    var res = xgcd(a, b);
    res = res.valueOf();
    var [gcd2, inv] = res;
    if (!equal(gcd2, BigNumber(1)))
      return NaN;
    inv = mod2(inv, b);
    if (smaller(inv, BigNumber(0)))
      inv = add2(inv, b);
    return inv;
  }
});
// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
var name70 = "matAlgo09xS0Sf";
var dependencies71 = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name70, dependencies71, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return function matAlgo09xS0Sf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : undefined;
    var w = [];
    var i, j, k, k0, k1;
    for (j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
          i = bindex[k];
          w[i] = mark;
          x[i] = bvalues[k];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        i = aindex[k];
        if (x) {
          var vb = w[i] === mark ? x[i] : zero;
          var vc = cf(avalues[k], vb);
          if (!eq(vc, zero)) {
            cindex.push(i);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
var name71 = "dotMultiply";
var dependencies72 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
var createDotMultiply = /* @__PURE__ */ factory(name71, dependencies72, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    multiplyScalar,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name71, matrixAlgorithmSuite({
    elop: multiplyScalar,
    SS: matAlgo09xS0Sf,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});
// node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber = x.constructor;
  var prevPrec = BigNumber.precision;
  BigNumber.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber(1));
  result.s = -result.s || null;
  BigNumber.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  var negOne = new BigNumber(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i = 0;i < xBits.length; ++i) {
      xBits[i] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0;_i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber(expFuncVal ^ 1);
  var twoPower = new BigNumber(1);
  var two = new BigNumber(2);
  var prevPrec = BigNumber.precision;
  BigNumber.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i = 1;i < a.length; ++i) {
    var s = a[i] + "";
    for (var z = 7 - s.length;z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0;_i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0;_j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === undefined) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber(0);
  }
  var negOne = new BigNumber(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber(NaN);
    }
    return new BigNumber(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber(2).pow(y)).floor();
}

// node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
var name72 = "bitAnd";
var dependencies73 = ["typed", "matrix", "equalScalar", "concat"];
var createBitAnd = /* @__PURE__ */ factory(name72, dependencies73, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name72, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber,
    "bigint, bigint": (x, y) => x & y
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});
// node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
var name73 = "bitNot";
var dependencies74 = ["typed"];
var createBitNot = /* @__PURE__ */ factory(name73, dependencies74, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name73, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    bigint: (x) => ~x,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
var name74 = "bitOr";
var dependencies75 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOr = /* @__PURE__ */ factory(name74, dependencies75, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name74, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber,
    "bigint, bigint": (x, y) => x | y
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }));
});
// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js
var name75 = "matAlgo07xSSf";
var dependencies76 = ["typed", "SparseMatrix"];
var createMatAlgo07xSSf = /* @__PURE__ */ factory(name75, dependencies76, (_ref) => {
  var {
    typed: typed2,
    SparseMatrix
  } = _ref;
  return function matAlgo07xSSf(a, b, callback) {
    var asize = a._size;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    var bsize = b._size;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = new Array(columns + 1).fill(0);
    var xa = [];
    var xb = [];
    var wa = [];
    var wb = [];
    for (var j = 0;j < columns; j++) {
      var mark = j + 1;
      var nonZeroCount = 0;
      _scatter(a, j, wa, xa, mark);
      _scatter(b, j, wb, xb, mark);
      for (var i = 0;i < rows; i++) {
        var va = wa[i] === mark ? xa[i] : zero;
        var vb = wb[i] === mark ? xb[i] : zero;
        var cij = cf(va, vb);
        if (cij !== 0 && cij !== false) {
          cindex.push(i);
          cvalues.push(cij);
          nonZeroCount++;
        }
      }
      cptr[j + 1] = cptr[j] + nonZeroCount;
    }
    return new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  };
  function _scatter(m, j, w, x, mark) {
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var k = ptr[j], k1 = ptr[j + 1];k < k1; k++) {
      var i = index[k];
      w[i] = mark;
      x[i] = values[k];
    }
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
var name76 = "bitXor";
var dependencies77 = ["typed", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createBitXor = /* @__PURE__ */ factory(name76, dependencies77, (_ref) => {
  var {
    typed: typed2,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name76, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor,
    "bigint, bigint": (x, y) => x ^ y
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
// node_modules/mathjs/lib/esm/function/complex/arg.js
var name77 = "arg";
var dependencies78 = ["typed"];
var createArg = /* @__PURE__ */ factory(name77, dependencies78, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name77, {
    number: function number(x) {
      return Math.atan2(0, x);
    },
    BigNumber: function BigNumber(x) {
      return x.constructor.atan2(0, x);
    },
    Complex: function Complex(x) {
      return x.arg();
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/complex/conj.js
var name78 = "conj";
var dependencies79 = ["typed"];
var createConj = /* @__PURE__ */ factory(name78, dependencies79, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name78, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.conjugate(),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/complex/im.js
var name79 = "im";
var dependencies80 = ["typed"];
var createIm = /* @__PURE__ */ factory(name79, dependencies80, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name79, {
    number: () => 0,
    "BigNumber | Fraction": (x) => x.mul(0),
    Complex: (x) => x.im,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/complex/re.js
var name80 = "re";
var dependencies81 = ["typed"];
var createRe = /* @__PURE__ */ factory(name80, dependencies81, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name80, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.re,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/logical/not.js
var name81 = "not";
var dependencies82 = ["typed"];
var createNot = /* @__PURE__ */ factory(name81, dependencies82, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name81, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex(x) {
      return x.re === 0 && x.im === 0;
    },
    BigNumber: function BigNumber(x) {
      return x.isZero() || x.isNaN();
    },
    bigint: (x) => !x,
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/logical/or.js
var name82 = "or";
var dependencies83 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOr = /* @__PURE__ */ factory(name82, dependencies83, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name82, {
    "number, number": orNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
    },
    "bigint, bigint": orNumber,
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
// node_modules/mathjs/lib/esm/function/logical/xor.js
var name83 = "xor";
var dependencies84 = ["typed", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createXor = /* @__PURE__ */ factory(name83, dependencies84, (_ref) => {
  var {
    typed: typed2,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name83, {
    "number, number": xorNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
    },
    "bigint, bigint": xorNumber,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
// node_modules/mathjs/lib/esm/function/matrix/concat.js
var name84 = "concat";
var dependencies85 = ["typed", "matrix", "isInteger"];
var createConcat = /* @__PURE__ */ factory(name84, dependencies85, (_ref) => {
  var {
    typed: typed2,
    matrix,
    isInteger: isInteger2
  } = _ref;
  return typed2(name84, {
    "...Array | Matrix | number | BigNumber": function Array__Matrix__number__BigNumber(args) {
      var i;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i = 0;i < len; i++) {
        var arg = args[i];
        if (isMatrix(arg)) {
          asMatrix = true;
        }
        if (isNumber(arg) || isBigNumber(arg)) {
          if (i !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg.valueOf();
          if (!isInteger2(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone(arg).valueOf();
          var size = arraySize(m);
          matrices[i] = m;
          prevDim = dim;
          dim = size.length - 1;
          if (i > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = concat(res, matrices.shift(), dim);
      }
      return asMatrix ? matrix(res) : res;
    },
    "...string": function string(args) {
      return args.join("");
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/column.js
var name85 = "column";
var dependencies86 = ["typed", "Index", "matrix", "range"];
var createColumn = /* @__PURE__ */ factory(name85, dependencies86, (_ref) => {
  var {
    typed: typed2,
    Index,
    matrix,
    range
  } = _ref;
  return typed2(name85, {
    "Matrix, number": _column,
    "Array, number": function Array_number(value, column) {
      return _column(matrix(clone(value)), column).valueOf();
    }
  });
  function _column(value, column) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column, value.size()[1]);
    var rowRange = range(0, value.size()[0]);
    var index = new Index(rowRange, column);
    var result = value.subset(index);
    return isMatrix(result) ? result : matrix([[result]]);
  }
});
// node_modules/mathjs/lib/esm/function/matrix/count.js
var name86 = "count";
var dependencies87 = ["typed", "size", "prod"];
var createCount = /* @__PURE__ */ factory(name86, dependencies87, (_ref) => {
  var {
    typed: typed2,
    size,
    prod
  } = _ref;
  return typed2(name86, {
    string: function string(x) {
      return x.length;
    },
    "Matrix | Array": function Matrix__Array(x) {
      return prod(size(x));
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/cross.js
var name87 = "cross";
var dependencies88 = ["typed", "matrix", "subtract", "multiply"];
var createCross = /* @__PURE__ */ factory(name87, dependencies88, (_ref) => {
  var {
    typed: typed2,
    matrix,
    subtract,
    multiply
  } = _ref;
  return typed2(name87, {
    "Matrix, Matrix": function Matrix_Matrix(x, y) {
      return matrix(_cross(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function Matrix_Array(x, y) {
      return matrix(_cross(x.toArray(), y));
    },
    "Array, Matrix": function Array_Matrix(x, y) {
      return matrix(_cross(x, y.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x, y) {
    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
    x = squeeze(x);
    y = squeeze(y);
    var xSize = arraySize(x);
    var ySize = arraySize(y);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected " + "(Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product3 = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];
    if (highestDimension > 1) {
      return [product3];
    } else {
      return product3;
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/diag.js
var name88 = "diag";
var dependencies89 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = /* @__PURE__ */ factory(name88, dependencies89, (_ref) => {
  var {
    typed: typed2,
    matrix,
    DenseMatrix,
    SparseMatrix
  } = _ref;
  return typed2(name88, {
    Array: function Array(x) {
      return _diag(x, 0, arraySize(x), null);
    },
    "Array, number": function Array_number(x, k) {
      return _diag(x, k, arraySize(x), null);
    },
    "Array, BigNumber": function Array_BigNumber(x, k) {
      return _diag(x, k.toNumber(), arraySize(x), null);
    },
    "Array, string": function Array_string(x, format4) {
      return _diag(x, 0, arraySize(x), format4);
    },
    "Array, number, string": function Array_number_string(x, k, format4) {
      return _diag(x, k, arraySize(x), format4);
    },
    "Array, BigNumber, string": function Array_BigNumber_string(x, k, format4) {
      return _diag(x, k.toNumber(), arraySize(x), format4);
    },
    Matrix: function Matrix(x) {
      return _diag(x, 0, x.size(), x.storage());
    },
    "Matrix, number": function Matrix_number(x, k) {
      return _diag(x, k, x.size(), x.storage());
    },
    "Matrix, BigNumber": function Matrix_BigNumber(x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },
    "Matrix, string": function Matrix_string(x, format4) {
      return _diag(x, 0, x.size(), format4);
    },
    "Matrix, number, string": function Matrix_number_string(x, k, format4) {
      return _diag(x, k, x.size(), format4);
    },
    "Matrix, BigNumber, string": function Matrix_BigNumber_string(x, k, format4) {
      return _diag(x, k.toNumber(), x.size(), format4);
    }
  });
  function _diag(x, k, size, format4) {
    if (!isInteger(k)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    switch (size.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format4, size[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format4, size, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format4 && format4 !== "sparse" && format4 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format4, '"'));
    }
    var m = format4 === "sparse" ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);
    return format4 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x, k, format4, s, kSub, kSuper) {
    if (isMatrix(x)) {
      var dm = x.diagonal(k);
      if (format4 !== null) {
        if (format4 !== dm.storage()) {
          return matrix(dm, format4);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    var vector = [];
    for (var i = 0;i < n; i++) {
      vector[i] = x[i + kSub][i + kSuper];
    }
    return format4 !== null ? matrix(vector) : vector;
  }
});
// node_modules/mathjs/lib/esm/function/matrix/filter.js
var name89 = "filter";
var dependencies90 = ["typed"];
var createFilter = /* @__PURE__ */ factory(name89, dependencies90, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("filter", {
    "Array, function": _filterCallback,
    "Matrix, function": function Matrix_function(x, test) {
      return x.create(_filterCallback(x.valueOf(), test), x.datatype());
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function Matrix_RegExp(x, test) {
      return x.create(filterRegExp(x.valueOf(), test), x.datatype());
    }
  });
});
function _filterCallback(x, callback) {
  var fastCallback = optimizeCallback(callback, x, "filter");
  return filter(x, function(value, index, array) {
    return fastCallback(value, [index], array);
  });
}
// node_modules/mathjs/lib/esm/function/matrix/flatten.js
var name90 = "flatten";
var dependencies91 = ["typed"];
var createFlatten = /* @__PURE__ */ factory(name90, dependencies91, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name90, {
    Array: function Array(x) {
      return flatten(x);
    },
    Matrix: function Matrix(x) {
      return x.create(flatten(x.toArray()), x.datatype());
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/forEach.js
var name91 = "forEach";
var dependencies92 = ["typed"];
var createForEach = /* @__PURE__ */ factory(name91, dependencies92, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name91, {
    "Array, function": _forEach,
    "Matrix, function": function Matrix_function(x, callback) {
      x.forEach(callback);
    }
  });
});
function _forEach(array, callback) {
  recurse(array, [], array, optimizeCallback(callback, array, name91));
}
// node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
var name92 = "getMatrixDataType";
var dependencies93 = ["typed"];
var createGetMatrixDataType = /* @__PURE__ */ factory(name92, dependencies93, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name92, {
    Array: function Array(x) {
      return getArrayDataType(x, typeOf);
    },
    Matrix: function Matrix(x) {
      return x.getDataType();
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/identity.js
var name93 = "identity";
var dependencies94 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = /* @__PURE__ */ factory(name93, dependencies94, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    BigNumber,
    DenseMatrix,
    SparseMatrix
  } = _ref;
  return typed2(name93, {
    "": function _() {
      return config4.matrix === "Matrix" ? matrix([]) : [];
    },
    string: function string(format4) {
      return matrix(format4);
    },
    "number | BigNumber": function number__BigNumber(rows) {
      return _identity(rows, rows, config4.matrix === "Matrix" ? "dense" : undefined);
    },
    "number | BigNumber, string": function number__BigNumber_string(rows, format4) {
      return _identity(rows, rows, format4);
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(rows, cols) {
      return _identity(rows, cols, config4.matrix === "Matrix" ? "dense" : undefined);
    },
    "number | BigNumber, number | BigNumber, string": function number__BigNumber_number__BigNumber_string(rows, cols, format4) {
      return _identity(rows, cols, format4);
    },
    Array: function Array(size) {
      return _identityVector(size);
    },
    "Array, string": function Array_string(size, format4) {
      return _identityVector(size, format4);
    },
    Matrix: function Matrix(size) {
      return _identityVector(size.valueOf(), size.storage());
    },
    "Matrix, string": function Matrix_string(size, format4) {
      return _identityVector(size.valueOf(), format4);
    }
  });
  function _identityVector(size, format4) {
    switch (size.length) {
      case 0:
        return format4 ? matrix(format4) : [];
      case 1:
        return _identity(size[0], size[0], format4);
      case 2:
        return _identity(size[0], size[1], format4);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format4) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one = Big ? new BigNumber(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size = [rows, cols];
    if (format4) {
      if (format4 === "sparse") {
        return SparseMatrix.diagonal(size, one, 0, defaultValue);
      }
      if (format4 === "dense") {
        return DenseMatrix.diagonal(size, one, 0, defaultValue);
      }
      throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
    }
    var res = resize([], size, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0;d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
});
// node_modules/mathjs/lib/esm/function/matrix/kron.js
var name94 = "kron";
var dependencies95 = ["typed", "matrix", "multiplyScalar"];
var createKron = /* @__PURE__ */ factory(name94, dependencies95, (_ref) => {
  var {
    typed: typed2,
    matrix,
    multiplyScalar
  } = _ref;
  return typed2(name94, {
    "Matrix, Matrix": function Matrix_Matrix(x, y) {
      return matrix(_kron(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function Matrix_Array(x, y) {
      return matrix(_kron(x.toArray(), y));
    },
    "Array, Matrix": function Array_Matrix(x, y) {
      return matrix(_kron(x, y.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a, b) {
    if (arraySize(a).length === 1) {
      a = [a];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected " + "(Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a.map(function(a2) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a2.map(function(y) {
          return b2.map(function(x) {
            return r.push(multiplyScalar(y, x));
          });
        });
      });
    }) && t;
  }
});
// node_modules/mathjs/lib/esm/function/matrix/map.js
var name95 = "map";
var dependencies96 = ["typed"];
var createMap2 = /* @__PURE__ */ factory(name95, dependencies96, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name95, {
    "Array, function": _mapArray,
    "Matrix, function": function Matrix_function(x, callback) {
      return x.map(callback);
    },
    "Array|Matrix, Array|Matrix, ...Array|Matrix|function": (A, B, rest) => _mapMultiple([A, B, ...rest.slice(0, rest.length - 1)], rest[rest.length - 1])
  });
  function _mapMultiple(Arrays, multiCallback) {
    if (typeof multiCallback !== "function") {
      throw new Error("Last argument must be a callback function");
    }
    var firstArrayIsMatrix = Arrays[0].isMatrix;
    var newSize = broadcastSizes(...Arrays.map((M) => M.isMatrix ? M.size() : arraySize(M)));
    var _get = firstArrayIsMatrix ? (matrix, idx) => matrix.get(idx) : get;
    var broadcastedArrays = firstArrayIsMatrix ? Arrays.map((M) => M.isMatrix ? M.create(broadcastTo(M.toArray(), newSize), M.datatype()) : Arrays[0].create(broadcastTo(M.valueOf(), newSize))) : Arrays.map((M) => M.isMatrix ? broadcastTo(M.toArray(), newSize) : broadcastTo(M, newSize));
    var callback;
    if (typed2.isTypedFunction(multiCallback)) {
      var firstIndex = newSize.map(() => 0);
      var firstValues = broadcastedArrays.map((array) => _get(array, firstIndex));
      var callbackCase = _getTypedCallbackCase(multiCallback, firstValues, firstIndex, broadcastedArrays);
      callback = _getLimitedCallback(callbackCase);
    } else {
      var numberOfArrays = Arrays.length;
      var _callbackCase = _getCallbackCase(multiCallback, numberOfArrays);
      callback = _getLimitedCallback(_callbackCase);
    }
    var broadcastedArraysCallback = (x, idx) => callback([x, ...broadcastedArrays.slice(1).map((Array2) => _get(Array2, idx))], idx);
    if (firstArrayIsMatrix) {
      return broadcastedArrays[0].map(broadcastedArraysCallback);
    } else {
      return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);
    }
    function _getLimitedCallback(callbackCase2) {
      switch (callbackCase2) {
        case 0:
          return (x) => multiCallback(...x);
        case 1:
          return (x, idx) => multiCallback(...x, idx);
        case 2:
          return (x, idx) => multiCallback(...x, idx, ...broadcastedArrays);
      }
    }
    function _getCallbackCase(callback2, numberOfArrays2) {
      if (callback2.length > numberOfArrays2 + 1) {
        return 2;
      }
      if (callback2.length === numberOfArrays2 + 1) {
        return 1;
      }
      return 0;
    }
    function _getTypedCallbackCase(callback2, values, idx, arrays) {
      if (typed2.resolve(callback2, [...values, idx, ...arrays]) !== null) {
        return 2;
      }
      if (typed2.resolve(callback2, [...values, idx]) !== null) {
        return 1;
      }
      if (typed2.resolve(callback2, values) !== null) {
        return 0;
      }
      return 0;
    }
  }
  function _mapArray(array, callback) {
    return recurse(array, [], array, optimizeCallback(callback, array, name95));
  }
});
// node_modules/mathjs/lib/esm/function/matrix/diff.js
var name96 = "diff";
var dependencies97 = ["typed", "matrix", "subtract", "number"];
var createDiff = /* @__PURE__ */ factory(name96, dependencies97, (_ref) => {
  var {
    typed: typed2,
    matrix,
    subtract,
    number
  } = _ref;
  return typed2(name96, {
    "Array | Matrix": function Array__Matrix(arr) {
      if (isMatrix(arr)) {
        return matrix(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function Array__Matrix_number(arr, dim) {
      if (!isInteger(dim))
        throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed2.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number(dim))),
    "Matrix, BigNumber": typed2.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element) => {
        result.push(_recursive(element, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size = arr.length;
    for (var i = 1;i < size; i++) {
      result.push(_ElementDiff(arr[i - 1], arr[i]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1))
      obj1 = obj1.toArray();
    if (isMatrix(obj2))
      obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size = arr1.length;
    for (var i = 0;i < size; i++) {
      result.push(_ElementDiff(arr1[i], arr2[i]));
    }
    return result;
  }
});
// node_modules/mathjs/lib/esm/function/matrix/ones.js
var name97 = "ones";
var dependencies98 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = /* @__PURE__ */ factory(name97, dependencies98, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    BigNumber
  } = _ref;
  return typed2("ones", {
    "": function _() {
      return config4.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    "...number | BigNumber | string": function number__BigNumber__string(size) {
      var last = size[size.length - 1];
      if (typeof last === "string") {
        var format4 = size.pop();
        return _ones(size, format4);
      } else if (config4.matrix === "Array") {
        return _ones(size);
      } else {
        return _ones(size, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix(size) {
      var format4 = size.storage();
      return _ones(size.valueOf(), format4);
    },
    "Array | Matrix, string": function Array__Matrix_string(size, format4) {
      return _ones(size.valueOf(), format4);
    }
  });
  function _ones(size, format4) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;
    _validate2(size);
    if (format4) {
      var m = matrix(format4);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function(value, index, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size) {
    size.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});
// node_modules/mathjs/lib/esm/utils/noop.js
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}

// node_modules/mathjs/lib/esm/function/matrix/range.js
var name98 = "range";
var dependencies99 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRange = /* @__PURE__ */ factory(name98, dependencies99, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add: add2,
    isPositive
  } = _ref;
  return typed2(name98, {
    string: _strRange,
    "string, boolean": _strRange,
    number: function number(oops) {
      throw new TypeError("Too few arguments to function range(): ".concat(oops));
    },
    boolean: function boolean(oops) {
      throw new TypeError("Unexpected type of argument 1 to function range(): ".concat(oops, ", number|bigint|BigNumber|Fraction"));
    },
    "number, number": function number_number(start, end) {
      return _out(_range(start, end, 1, false));
    },
    "number, number, number": function number_number_number(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "number, number, boolean": function number_number_boolean(start, end, includeEnd) {
      return _out(_range(start, end, 1, includeEnd));
    },
    "number, number, number, boolean": function number_number_number_boolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    },
    "bigint, bigint|number": function bigint_bigintNumber(start, end) {
      return _out(_range(start, end, 1n, false));
    },
    "number, bigint": function number_bigint(start, end) {
      return _out(_range(BigInt(start), end, 1n, false));
    },
    "bigint, bigint|number, bigint|number": function bigint_bigintNumber_bigintNumber(start, end, step) {
      return _out(_range(start, end, BigInt(step), false));
    },
    "number, bigint, bigint|number": function number_bigint_bigintNumber(start, end, step) {
      return _out(_range(BigInt(start), end, BigInt(step), false));
    },
    "bigint, bigint|number, boolean": function bigint_bigintNumber_boolean(start, end, includeEnd) {
      return _out(_range(start, end, 1n, includeEnd));
    },
    "number, bigint, boolean": function number_bigint_boolean(start, end, includeEnd) {
      return _out(_range(BigInt(start), end, 1n, includeEnd));
    },
    "bigint, bigint|number, bigint|number, boolean": function bigint_bigintNumber_bigintNumber_boolean(start, end, step, includeEnd) {
      return _out(_range(start, end, BigInt(step), includeEnd));
    },
    "number, bigint, bigint|number, boolean": function number_bigint_bigintNumber_boolean(start, end, step, includeEnd) {
      return _out(_range(BigInt(start), end, BigInt(step), includeEnd));
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(start, end) {
      var BigNumber = start.constructor;
      return _out(_range(start, end, new BigNumber(1), false));
    },
    "BigNumber, BigNumber, BigNumber": function BigNumber_BigNumber_BigNumber(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "BigNumber, BigNumber, boolean": function BigNumber_BigNumber_boolean(start, end, includeEnd) {
      var BigNumber = start.constructor;
      return _out(_range(start, end, new BigNumber(1), includeEnd));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function BigNumber_BigNumber_BigNumber_boolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    },
    "Fraction, Fraction": function Fraction_Fraction(start, end) {
      return _out(_range(start, end, 1, false));
    },
    "Fraction, Fraction, Fraction": function Fraction_Fraction_Fraction(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "Fraction, Fraction, boolean": function Fraction_Fraction_boolean(start, end, includeEnd) {
      return _out(_range(start, end, 1, includeEnd));
    },
    "Fraction, Fraction, Fraction, boolean": function Fraction_Fraction_Fraction_boolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    },
    "Unit, Unit, Unit": function Unit_Unit_Unit(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "Unit, Unit, Unit, boolean": function Unit_Unit_Unit_boolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    }
  });
  function _out(arr) {
    if (config4.matrix === "Matrix") {
      return matrix ? matrix(arr) : noMatrix();
    }
    return arr;
  }
  function _strRange(str, includeEnd) {
    var r = _parse(str);
    if (!r) {
      throw new SyntaxError('String "' + str + '" is no valid range');
    }
    if (config4.number === "BigNumber") {
      if (bignumber === undefined) {
        noBignumber();
      }
      return _out(_range(bignumber(r.start), bignumber(r.end), bignumber(r.step)), includeEnd);
    } else {
      return _out(_range(r.start, r.end, r.step, includeEnd));
    }
  }
  function _range(start, end, step, includeEnd) {
    var array = [];
    var ongoing = isPositive(step) ? includeEnd ? smallerEq : smaller : includeEnd ? largerEq : larger;
    var x = start;
    while (ongoing(x, end)) {
      array.push(x);
      x = add2(x, step);
    }
    return array;
  }
  function _parse(str) {
    var args = str.split(":");
    var nums = args.map(function(arg) {
      return Number(arg);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };
      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };
      default:
        return null;
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/reshape.js
var name99 = "reshape";
var dependencies100 = ["typed", "isInteger", "matrix"];
var createReshape = /* @__PURE__ */ factory(name99, dependencies100, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name99, {
    "Matrix, Array": function Matrix_Array(x, sizes) {
      return x.reshape(sizes, true);
    },
    "Array, Array": function Array_Array(x, sizes) {
      sizes.forEach(function(size) {
        if (!isInteger2(size)) {
          throw new TypeError("Invalid size for dimension: " + size);
        }
      });
      return reshape(x, sizes);
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/resize.js
var name100 = "resize";
var dependencies101 = ["config", "matrix"];
var createResize = /* @__PURE__ */ factory(name100, dependencies101, (_ref) => {
  var {
    config: config4,
    matrix
  } = _ref;
  return function resize(x, size, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size)) {
      size = size.valueOf();
    }
    if (isBigNumber(size[0])) {
      size = size.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x)) {
      return x.resize(size, defaultValue, true);
    }
    if (typeof x === "string") {
      return _resizeString(x, size, defaultValue);
    }
    var asMatrix = Array.isArray(x) ? false : config4.matrix !== "Array";
    if (size.length === 0) {
      while (Array.isArray(x)) {
        x = x[0];
      }
      return clone(x);
    } else {
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone(x);
      var res = resize(x, size, defaultValue);
      return asMatrix ? matrix(res) : res;
    }
  };
  function _resizeString(str, size, defaultChar) {
    if (defaultChar !== undefined) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size.length !== 1) {
      throw new DimensionError(size.length, 1);
    }
    var len = size[0];
    if (typeof len !== "number" || !isInteger(len)) {
      throw new TypeError("Invalid size, must contain positive integers " + "(size: " + format3(size) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i = 0, ii = len - str.length;i < ii; i++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/rotate.js
var name101 = "rotate";
var dependencies102 = ["typed", "multiply", "rotationMatrix"];
var createRotate = /* @__PURE__ */ factory(name101, dependencies102, (_ref) => {
  var {
    typed: typed2,
    multiply,
    rotationMatrix
  } = _ref;
  return typed2(name101, {
    "Array , number | BigNumber | Complex | Unit": function Array__number__BigNumber__Complex__Unit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply(rotationMatrix(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function Matrix__number__BigNumber__Complex__Unit(w, theta) {
      _validateSize(w, 2);
      return multiply(rotationMatrix(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function Array_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply(rotationMatrix(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function Matrix_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply(rotationMatrix(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
var name102 = "rotationMatrix";
var dependencies103 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = /* @__PURE__ */ factory(name102, dependencies103, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    multiplyScalar,
    addScalar,
    unaryMinus,
    norm,
    BigNumber,
    matrix,
    DenseMatrix,
    SparseMatrix,
    cos: cos2,
    sin: sin2
  } = _ref;
  return typed2(name102, {
    "": function _() {
      return config4.matrix === "Matrix" ? matrix([]) : [];
    },
    string: function string(format4) {
      return matrix(format4);
    },
    "number | BigNumber | Complex | Unit": function number__BigNumber__Complex__Unit(theta) {
      return _rotationMatrix2x2(theta, config4.matrix === "Matrix" ? "dense" : undefined);
    },
    "number | BigNumber | Complex | Unit, string": function number__BigNumber__Complex__Unit_string(theta, format4) {
      return _rotationMatrix2x2(theta, format4);
    },
    "number | BigNumber | Complex | Unit, Array": function number__BigNumber__Complex__Unit_Array(theta, v) {
      var matrixV = matrix(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, undefined);
    },
    "number | BigNumber | Complex | Unit, Matrix": function number__BigNumber__Complex__Unit_Matrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config4.matrix === "Matrix" ? "dense" : undefined);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function number__BigNumber__Complex__Unit_Array_string(theta, v, format4) {
      var matrixV = matrix(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format4);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function number__BigNumber__Complex__Unit_Matrix_string(theta, v, format4) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format4);
    }
  });
  function _rotationMatrix2x2(theta, format4) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber(-1) : -1;
    var cosTheta = cos2(theta);
    var sinTheta = sin2(theta);
    var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format4);
  }
  function _validateVector(v) {
    var size = v.size();
    if (size.length < 1 || size[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array) {
    return array.reduce((p, curr) => multiplyScalar(p, curr));
  }
  function _convertToFormat(data, format4) {
    if (format4) {
      if (format4 === "sparse") {
        return new SparseMatrix(data);
      }
      if (format4 === "dense") {
        return new DenseMatrix(data);
      }
      throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format4) {
    var normV = norm(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber : null;
    var one = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c = cos2(theta);
    var oneMinusC = addScalar(one, unaryMinus(c));
    var s = sin2(theta);
    var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
    var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
    var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
    var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
    var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
    var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
    var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format4);
  }
});
// node_modules/mathjs/lib/esm/function/matrix/row.js
var name103 = "row";
var dependencies104 = ["typed", "Index", "matrix", "range"];
var createRow = /* @__PURE__ */ factory(name103, dependencies104, (_ref) => {
  var {
    typed: typed2,
    Index,
    matrix,
    range
  } = _ref;
  return typed2(name103, {
    "Matrix, number": _row,
    "Array, number": function Array_number(value, row) {
      return _row(matrix(clone(value)), row).valueOf();
    }
  });
  function _row(value, row) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row, value.size()[0]);
    var columnRange = range(0, value.size()[1]);
    var index = new Index(row, columnRange);
    var result = value.subset(index);
    return isMatrix(result) ? result : matrix([[result]]);
  }
});
// node_modules/mathjs/lib/esm/function/matrix/size.js
var name104 = "size";
var dependencies105 = ["typed", "config", "?matrix"];
var createSize = /* @__PURE__ */ factory(name104, dependencies105, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix
  } = _ref;
  return typed2(name104, {
    Matrix: function Matrix(x) {
      return x.create(x.size(), "number");
    },
    Array: arraySize,
    string: function string(x) {
      return config4.matrix === "Array" ? [x.length] : matrix([x.length], "dense", "number");
    },
    "number | Complex | BigNumber | Unit | boolean | null": function number__Complex__BigNumber__Unit__boolean__null(x) {
      return config4.matrix === "Array" ? [] : matrix ? matrix([], "dense", "number") : noMatrix();
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/squeeze.js
var name105 = "squeeze";
var dependencies106 = ["typed"];
var createSqueeze = /* @__PURE__ */ factory(name105, dependencies106, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name105, {
    Array: function Array(x) {
      return squeeze(clone(x));
    },
    Matrix: function Matrix(x) {
      var res = squeeze(x.toArray());
      return Array.isArray(res) ? x.create(res, x.datatype()) : res;
    },
    any: function any(x) {
      return clone(x);
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/subset.js
var name106 = "subset";
var dependencies107 = ["typed", "matrix", "zeros", "add"];
var createSubset = /* @__PURE__ */ factory(name106, dependencies107, (_ref) => {
  var {
    typed: typed2,
    matrix,
    zeros: zeros2,
    add: add2
  } = _ref;
  return typed2(name106, {
    "Matrix, Index": function Matrix_Index(value, index) {
      if (isEmptyIndex(index)) {
        return matrix();
      }
      validateIndexSourceSize(value, index);
      return value.subset(index);
    },
    "Array, Index": typed2.referTo("Matrix, Index", function(subsetRef) {
      return function(value, index) {
        var subsetResult = subsetRef(matrix(value), index);
        return index.isScalar() ? subsetResult : subsetResult.valueOf();
      };
    }),
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    "Matrix, Index, any, any": function Matrix_Index_any_any(value, index, replacement, defaultValue) {
      if (isEmptyIndex(index)) {
        return value;
      }
      validateIndexSourceSize(value, index);
      return value.clone().subset(index, _broadcastReplacement(replacement, index), defaultValue);
    },
    "Array, Index, any, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index, replacement, defaultValue) {
        var subsetResult = subsetRef(matrix(value), index, replacement, defaultValue);
        return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
      };
    }),
    "Array, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index, replacement) {
        return subsetRef(matrix(value), index, replacement, undefined).valueOf();
      };
    }),
    "Matrix, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index, replacement) {
        return subsetRef(value, index, replacement, undefined);
      };
    }),
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
  function _broadcastReplacement(replacement, index) {
    if (typeof replacement === "string") {
      throw new Error("can't boradcast a string");
    }
    if (index._isScalar) {
      return replacement;
    }
    var indexSize = index.size();
    if (indexSize.every((d) => d > 0)) {
      try {
        return add2(replacement, zeros2(indexSize));
      } catch (error) {
        return replacement;
      }
    } else {
      return replacement;
    }
  }
});
function _getSubstring(str, index) {
  if (!isIndex(index)) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index)) {
    return "";
  }
  validateIndexSourceSize(Array.from(str), index);
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index.min()[0], strLen);
  validateIndex(index.max()[0], strLen);
  var range = index.dimension(0);
  var substr = "";
  range.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index, replacement, defaultValue) {
  if (!index || index.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index)) {
    return str;
  }
  validateIndexSourceSize(Array.from(str), index);
  if (index.size().length !== 1) {
    throw new DimensionError(index.size().length, 1);
  }
  if (defaultValue !== undefined) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range = index.dimension(0);
  var len = range.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index.min()[0]);
  validateIndex(index.max()[0]);
  var chars = [];
  for (var i = 0;i < strLen; i++) {
    chars[i] = str.charAt(i);
  }
  range.forEach(function(v, i2) {
    chars[v] = replacement.charAt(i2[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length;_i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index) {
  if (isEmptyIndex(index)) {
    return;
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  var key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index, replacement) {
  if (isEmptyIndex(index)) {
    return object;
  }
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }
  var key = index.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}
// node_modules/mathjs/lib/esm/function/matrix/transpose.js
var name107 = "transpose";
var dependencies108 = ["typed", "matrix"];
var createTranspose = /* @__PURE__ */ factory(name107, dependencies108, (_ref) => {
  var {
    typed: typed2,
    matrix
  } = _ref;
  return typed2(name107, {
    Array: (x) => transposeMatrix(matrix(x)).valueOf(),
    Matrix: transposeMatrix,
    any: clone
  });
  function transposeMatrix(x) {
    var size = x.size();
    var c;
    switch (size.length) {
      case 1:
        c = x.clone();
        break;
      case 2:
        {
          var rows = size[0];
          var columns = size[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size) + ")");
          }
          switch (x.storage()) {
            case "dense":
              c = _denseTranspose(x, rows, columns);
              break;
            case "sparse":
              c = _sparseTranspose(x, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(size) + ")");
    }
    return c;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0;j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i = 0;i < rows; i++) {
        transposedRow[i] = clone(data[i][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x = 0;x < rows; x++) {
      w[x] = 0;
    }
    var p, l, j;
    for (p = 0, l = index.length;p < l; p++) {
      w[index[p]]++;
    }
    var sum2 = 0;
    for (var i = 0;i < rows; i++) {
      cptr.push(sum2);
      sum2 += w[i];
      w[i] = cptr[i];
    }
    cptr.push(sum2);
    for (j = 0;j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0;k < k1; k++) {
        var q = w[index[k]]++;
        cindex[q] = j;
        if (values) {
          cvalues[q] = clone(values[k]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});
// node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
var name108 = "ctranspose";
var dependencies109 = ["typed", "transpose", "conj"];
var createCtranspose = /* @__PURE__ */ factory(name108, dependencies109, (_ref) => {
  var {
    typed: typed2,
    transpose,
    conj
  } = _ref;
  return typed2(name108, {
    any: function any(x) {
      return conj(transpose(x));
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/zeros.js
var name109 = "zeros";
var dependencies110 = ["typed", "config", "matrix", "BigNumber"];
var createZeros = /* @__PURE__ */ factory(name109, dependencies110, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    BigNumber
  } = _ref;
  return typed2(name109, {
    "": function _() {
      return config4.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    "...number | BigNumber | string": function number__BigNumber__string(size) {
      var last = size[size.length - 1];
      if (typeof last === "string") {
        var format4 = size.pop();
        return _zeros(size, format4);
      } else if (config4.matrix === "Array") {
        return _zeros(size);
      } else {
        return _zeros(size, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix(size) {
      var format4 = size.storage();
      return _zeros(size.valueOf(), format4);
    },
    "Array | Matrix, string": function Array__Matrix_string(size, format4) {
      return _zeros(size.valueOf(), format4);
    }
  });
  function _zeros(size, format4) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
    _validate2(size);
    if (format4) {
      var m = matrix(format4);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function(value, index, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size) {
    size.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});
// node_modules/mathjs/lib/esm/function/matrix/fft.js
var name110 = "fft";
var dependencies111 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
var createFft = /* @__PURE__ */ factory(name110, dependencies111, (_ref) => {
  var {
    typed: typed2,
    matrix,
    addScalar,
    multiplyScalar,
    divideScalar,
    exp: exp2,
    tau: tau2,
    i: I,
    dotDivide,
    conj,
    pow: pow2,
    ceil: ceil2,
    log2: log24
  } = _ref;
  return typed2(name110, {
    Array: _ndFft,
    Matrix: function Matrix(matrix2) {
      return matrix2.create(_ndFft(matrix2.valueOf()), matrix2.datatype());
    }
  });
  function _ndFft(arr) {
    var size = arraySize(arr);
    if (size.length === 1)
      return _fft(arr, size[0]);
    return _1dFft(arr.map((slice) => _ndFft(slice, size.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size = arraySize(arr);
    if (dim !== 0)
      return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));
    if (size.length === 1)
      return _fft(arr);
    function _transpose(arr2) {
      var size2 = arraySize(arr2);
      return new Array(size2[1]).fill(0).map((_, j) => new Array(size2[0]).fill(0).map((_2, i) => arr2[i][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _czt(arr) {
    var n = arr.length;
    var w = exp2(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau2)), n));
    var chirp = [];
    for (var i = 1 - n;i < n; i++) {
      chirp.push(pow2(w, divideScalar(pow2(i, 2), 2)));
    }
    var N2 = pow2(2, ceil2(log24(n + n - 1)));
    var xp = [...new Array(n).fill(0).map((_, i2) => multiplyScalar(arr[i2], chirp[n - 1 + i2])), ...new Array(N2 - n).fill(0)];
    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i2) => divideScalar(1, chirp[i2])), ...new Array(N2 - (n + n - 1)).fill(0)];
    var fftXp = _fft(xp);
    var fftIchirp = _fft(ichirp);
    var fftProduct = new Array(N2).fill(0).map((_, i2) => multiplyScalar(fftXp[i2], fftIchirp[i2]));
    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);
    var ret = [];
    for (var _i = n - 1;_i < n + n - 1; _i++) {
      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));
    }
    return ret;
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1)
      return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];
      for (var k = 0;k < len / 2; k++) {
        var p = ret[k];
        var q = multiplyScalar(ret[k + len / 2], exp2(multiplyScalar(multiplyScalar(tau2, I), divideScalar(-k, len))));
        ret[k] = addScalar(p, q);
        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));
      }
      return ret;
    } else {
      return _czt(arr);
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/ifft.js
var name111 = "ifft";
var dependencies112 = ["typed", "fft", "dotDivide", "conj"];
var createIfft = /* @__PURE__ */ factory(name111, dependencies112, (_ref) => {
  var {
    typed: typed2,
    fft,
    dotDivide,
    conj
  } = _ref;
  return typed2(name111, {
    "Array | Matrix": function Array__Matrix(arr) {
      var size = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide(conj(fft(conj(arr))), size.reduce((acc, curr) => acc * curr, 1));
    }
  });
});
// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if (_typeof(t) != "object" || !t)
    return t;
  var e2 = t[Symbol.toPrimitive];
  if (e2 !== undefined) {
    var i = e2.call(t, r || "default");
    if (_typeof(i) != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return _typeof(i) == "symbol" ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e2, r, t) {
  return (r = toPropertyKey(r)) in e2 ? Object.defineProperty(e2, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r] = t, e2;
}

// node_modules/mathjs/lib/esm/function/numeric/solveODE.js
function ownKeys(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e2) {
  for (var r = 1;r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name112 = "solveODE";
var dependencies113 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
var createSolveODE = /* @__PURE__ */ factory(name112, dependencies113, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    max: max2,
    map: map2,
    abs: abs2,
    isPositive,
    isNegative,
    larger,
    smaller,
    matrix,
    bignumber,
    unaryMinus
  } = _ref;
  function _rk(butcherTableau) {
    return function(f, tspan, y0, options) {
      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
      if (wrongTSpan) {
        throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
      }
      var t0 = tspan[0];
      var tf = tspan[1];
      var isForwards = larger(tf, t0);
      var firstStep = options.firstStep;
      if (firstStep !== undefined && !isPositive(firstStep)) {
        throw new Error('"firstStep" must be positive');
      }
      var maxStep = options.maxStep;
      if (maxStep !== undefined && !isPositive(maxStep)) {
        throw new Error('"maxStep" must be positive');
      }
      var minStep = options.minStep;
      if (minStep && isNegative(minStep)) {
        throw new Error('"minStep" must be positive or zero');
      }
      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter((x) => x !== undefined);
      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
        throw new Error('Inconsistent type of "t" dependant variables');
      }
      var steps = 1;
      var tol = options.tol ? options.tol : 0.0001;
      var minDelta = options.minDelta ? options.minDelta : 0.2;
      var maxDelta = options.maxDelta ? options.maxDelta : 5;
      var maxIter = options.maxIter ? options.maxIter : 1e4;
      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);
      var [a, c, b, bp] = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
      var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide2(subtract(tf, t0), steps);
      var t = [t0];
      var y = [y0];
      var deltaB = subtract(b, bp);
      var n = 0;
      var iter = 0;
      var ongoing = _createOngoing(isForwards);
      var trimStep = _createTrimStep(isForwards);
      while (ongoing(t[n], tf)) {
        var k = [];
        h = trimStep(t[n], tf, h);
        k.push(f(t[n], y[n]));
        for (var i = 1;i < c.length; ++i) {
          k.push(f(add2(t[n], multiply(c[i], h)), add2(y[n], multiply(h, a[i], k))));
        }
        var TE = max2(abs2(map2(multiply(deltaB, k), (X) => isUnit(X) ? X.value : X)));
        if (TE < tol && tol / TE > 1 / 4) {
          t.push(add2(t[n], h));
          y.push(add2(y[n], multiply(h, b, k)));
          n++;
        }
        var delta = 0.84 * (tol / TE) ** (1 / 5);
        if (smaller(delta, minDelta)) {
          delta = minDelta;
        } else if (larger(delta, maxDelta)) {
          delta = maxDelta;
        }
        delta = hasBigNumbers ? bignumber(delta) : delta;
        h = multiply(h, delta);
        if (maxStep && larger(abs2(h), maxStep)) {
          h = isForwards ? maxStep : unaryMinus(maxStep);
        } else if (minStep && smaller(abs2(h), minStep)) {
          h = isForwards ? minStep : unaryMinus(minStep);
        }
        iter++;
        if (iter > maxIter) {
          throw new Error("Maximum number of iterations reached, try changing options");
        }
      }
      return {
        t,
        y
      };
    };
  }
  function _rk23(f, tspan, y0, options) {
    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
    var c = [null, 1 / 2, 3 / 4, 1];
    var b = [2 / 9, 1 / 3, 4 / 9, 0];
    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _rk45(f, tspan, y0, options) {
    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _solveODE(f, tspan, y0, opt) {
    var method = opt.method ? opt.method : "RK45";
    var methods = {
      RK23: _rk23,
      RK45: _rk45
    };
    if (method.toUpperCase() in methods) {
      var methodOptions = _objectSpread({}, opt);
      delete methodOptions.method;
      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
    } else {
      var methodsWithQuotes = Object.keys(methods).map((x) => '"'.concat(x, '"'));
      var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
      throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
    }
  }
  function _createOngoing(isForwards) {
    return isForwards ? smaller : larger;
  }
  function _createTrimStep(isForwards) {
    var outOfBounds = isForwards ? larger : smaller;
    return function(t, tf, h) {
      var next = add2(t, h);
      return outOfBounds(next, tf) ? subtract(tf, t) : h;
    };
  }
  function isNumOrBig(x) {
    return isBigNumber(x) || isNumber(x);
  }
  function _matrixSolveODE(f, T, y0, options) {
    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
    return {
      t: matrix(sol.t),
      y: matrix(sol.y)
    };
  }
  return typed2("solveODE", {
    "function, Array, Array, Object": _solveODE,
    "function, Matrix, Matrix, Object": _matrixSolveODE,
    "function, Array, Array": (f, T, y0) => _solveODE(f, T, y0, {}),
    "function, Matrix, Matrix": (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
    "function, Array, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T, [y0], {});
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T.toArray(), [y0], {});
      return {
        t: matrix(sol.t),
        y: matrix(sol.y.map((Y) => Y[0]))
      };
    },
    "function, Array, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T, [y0], options);
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T.toArray(), [y0], options);
      return {
        t: matrix(sol.t),
        y: matrix(sol.y.map((Y) => Y[0]))
      };
    }
  });
});
// node_modules/mathjs/lib/esm/function/special/erf.js
var name113 = "erf";
var dependencies114 = ["typed"];
var createErf = /* @__PURE__ */ factory(name113, dependencies114, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("name", {
    number: function number(x) {
      var y = Math.abs(x);
      if (y >= MAX_NUM) {
        return sign(x);
      }
      if (y <= THRESH) {
        return sign(x) * erf1(y);
      }
      if (y <= 4) {
        return sign(x) * (1 - erfc2(y));
      }
      return sign(x) * (1 - erfc3(y));
    },
    "Array | Matrix": typed2.referToSelf((self2) => (n) => deepMap(n, self2))
  });
  function erf1(y) {
    var ysq = y * y;
    var xnum = P4[0][4] * ysq;
    var xden = ysq;
    var i;
    for (i = 0;i < 3; i += 1) {
      xnum = (xnum + P4[0][i]) * ysq;
      xden = (xden + Q[0][i]) * ysq;
    }
    return y * (xnum + P4[0][3]) / (xden + Q[0][3]);
  }
  function erfc2(y) {
    var xnum = P4[1][8] * y;
    var xden = y;
    var i;
    for (i = 0;i < 7; i += 1) {
      xnum = (xnum + P4[1][i]) * y;
      xden = (xden + Q[1][i]) * y;
    }
    var result = (xnum + P4[1][7]) / (xden + Q[1][7]);
    var ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
  function erfc3(y) {
    var ysq = 1 / (y * y);
    var xnum = P4[2][5] * ysq;
    var xden = ysq;
    var i;
    for (i = 0;i < 4; i += 1) {
      xnum = (xnum + P4[2][i]) * ysq;
      xden = (xden + Q[2][i]) * ysq;
    }
    var result = ysq * (xnum + P4[2][4]) / (xden + Q[2][4]);
    result = (SQRPI - result) / y;
    ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
});
var THRESH = 0.46875;
var SQRPI = 0.5641895835477563;
var P4 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 0.000000021531153547440383], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 0.0006587491615298378, 0.016315387137302097]];
var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
var MAX_NUM = Math.pow(2, 53);
// node_modules/mathjs/lib/esm/function/special/zeta.js
var name114 = "zeta";
var dependencies115 = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"];
var createZeta = /* @__PURE__ */ factory(name114, dependencies115, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    multiply,
    pow: pow2,
    divide: divide2,
    factorial,
    equal,
    smallerEq,
    isNegative,
    gamma,
    sin: sin2,
    subtract,
    add: add2,
    Complex: Complex2,
    BigNumber: _BigNumber,
    pi: pi2
  } = _ref;
  return typed2(name114, {
    number: (s) => zetaNumeric(s, (value) => value, () => 20),
    BigNumber: (s) => zetaNumeric(s, (value) => new _BigNumber(value), () => {
      return Math.abs(Math.log10(config4.relTol));
    }),
    Complex: zetaComplex
  });
  function zetaNumeric(s, createValue, determineDigits) {
    if (equal(s, 0)) {
      return createValue(-0.5);
    }
    if (equal(s, 1)) {
      return createValue(NaN);
    }
    if (!isFinite(s)) {
      return isNegative(s) ? createValue(NaN) : createValue(1);
    }
    return zeta(s, createValue, determineDigits, (s2) => s2);
  }
  function zetaComplex(s) {
    if (s.re === 0 && s.im === 0) {
      return new Complex2(-0.5);
    }
    if (s.re === 1) {
      return new Complex2(NaN, NaN);
    }
    if (s.re === Infinity && s.im === 0) {
      return new Complex2(1);
    }
    if (s.im === Infinity || s.re === -Infinity) {
      return new Complex2(NaN, NaN);
    }
    return zeta(s, (value) => value, (s2) => Math.round(1.3 * 15 + 0.9 * Math.abs(s2.im)), (s2) => s2.re);
  }
  function zeta(s, createValue, determineDigits, getRe) {
    var n = determineDigits(s);
    if (getRe(s) > -(n - 1) / 2) {
      return f(s, createValue(n), createValue);
    } else {
      var c = multiply(pow2(2, s), pow2(createValue(pi2), subtract(s, 1)));
      c = multiply(c, sin2(multiply(divide2(createValue(pi2), 2), s)));
      c = multiply(c, gamma(subtract(1, s)));
      return multiply(c, zeta(subtract(1, s), createValue, determineDigits, getRe));
    }
  }
  function d(k, n) {
    var S = k;
    for (var j = k;smallerEq(j, n); j = add2(j, 1)) {
      var factor = divide2(multiply(factorial(add2(n, subtract(j, 1))), pow2(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));
      S = add2(S, factor);
    }
    return multiply(n, S);
  }
  function f(s, n, createValue) {
    var c = divide2(1, multiply(d(createValue(0), n), subtract(1, pow2(2, subtract(1, s)))));
    var S = createValue(0);
    for (var k = createValue(1);smallerEq(k, n); k = add2(k, 1)) {
      S = add2(S, divide2(multiply((-1) ** (k - 1), d(k, n)), pow2(k, s)));
    }
    return multiply(c, S);
  }
});
// node_modules/mathjs/lib/esm/function/statistics/mode.js
var name115 = "mode";
var dependencies116 = ["typed", "isNaN", "isNumeric"];
var createMode = /* @__PURE__ */ factory(name115, dependencies116, (_ref) => {
  var {
    typed: typed2,
    isNaN: isNaN2,
    isNumeric
  } = _ref;
  return typed2(name115, {
    "Array | Matrix": _mode,
    "...": function _(args) {
      return _mode(args);
    }
  });
  function _mode(values) {
    values = flatten(values.valueOf());
    var num = values.length;
    if (num === 0) {
      throw new Error("Cannot calculate mode of an empty array");
    }
    var count = {};
    var mode = [];
    var max2 = 0;
    for (var i = 0;i < values.length; i++) {
      var value = values[i];
      if (isNumeric(value) && isNaN2(value)) {
        throw new Error("Cannot calculate mode of an array containing NaN values");
      }
      if (!(value in count)) {
        count[value] = 0;
      }
      count[value]++;
      if (count[value] === max2) {
        mode.push(value);
      } else if (count[value] > max2) {
        max2 = count[value];
        mode = [value];
      }
    }
    return mode;
  }
});
// node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
function improveErrorMessage(err, fnName, value) {
  var details;
  if (String(err).includes("Unexpected type")) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
    return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
  }
  if (String(err).includes("complex numbers")) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
  }
  return err;
}

// node_modules/mathjs/lib/esm/function/statistics/prod.js
var name116 = "prod";
var dependencies117 = ["typed", "config", "multiplyScalar", "numeric"];
var createProd = /* @__PURE__ */ factory(name116, dependencies117, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    multiplyScalar,
    numeric
  } = _ref;
  return typed2(name116, {
    "Array | Matrix": _prod,
    "Array | Matrix, number | BigNumber": function Array__Matrix_number__BigNumber(array, dim) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    "...": function _(args) {
      return _prod(args);
    }
  });
  function _prod(array) {
    var prod;
    deepForEach(array, function(value) {
      try {
        prod = prod === undefined ? value : multiplyScalar(prod, value);
      } catch (err) {
        throw improveErrorMessage(err, "prod", value);
      }
    });
    if (typeof prod === "string") {
      prod = numeric(prod, safeNumberType(prod, config4));
    }
    if (prod === undefined) {
      throw new Error("Cannot calculate prod of an empty array");
    }
    return prod;
  }
});
// node_modules/mathjs/lib/esm/function/string/format.js
var name117 = "format";
var dependencies118 = ["typed"];
var createFormat = /* @__PURE__ */ factory(name117, dependencies118, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name117, {
    any: format3,
    "any, Object | function | number | BigNumber": format3
  });
});
// node_modules/mathjs/lib/esm/function/string/bin.js
var name118 = "bin";
var dependencies119 = ["typed", "format"];
var createBin = factory(name118, dependencies119, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name118, {
    "number | BigNumber": function number__BigNumber(n) {
      return format4(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, wordSize) {
      return format4(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});
// node_modules/mathjs/lib/esm/function/string/oct.js
var name119 = "oct";
var dependencies120 = ["typed", "format"];
var createOct = factory(name119, dependencies120, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name119, {
    "number | BigNumber": function number__BigNumber(n) {
      return format4(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, wordSize) {
      return format4(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});
// node_modules/mathjs/lib/esm/function/string/hex.js
var name120 = "hex";
var dependencies121 = ["typed", "format"];
var createHex = factory(name120, dependencies121, (_ref) => {
  var {
    typed: typed2,
    format: format4
  } = _ref;
  return typed2(name120, {
    "number | BigNumber": function number__BigNumber(n) {
      return format4(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, wordSize) {
      return format4(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});
// node_modules/mathjs/lib/esm/utils/print.js
var printTemplate = /\$([\w.]+)/g;

// node_modules/mathjs/lib/esm/function/string/print.js
var name121 = "print";
var dependencies122 = ["typed"];
var createPrint = /* @__PURE__ */ factory(name121, dependencies122, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name121, {
    "string, Object | Array": _print,
    "string, Object | Array, number | Object": _print
  });
});
function _print(template, values, options) {
  return template.replace(printTemplate, function(original, key) {
    var keys = key.split(".");
    var value = values[keys.shift()];
    if (value !== undefined && value.isMatrix) {
      value = value.toArray();
    }
    while (keys.length && value !== undefined) {
      var k = keys.shift();
      value = k ? value[k] : value + ".";
    }
    if (value !== undefined) {
      if (!isString(value)) {
        return format3(value, options);
      } else {
        return value;
      }
    }
    return original;
  });
}
// node_modules/mathjs/lib/esm/function/unit/to.js
var name122 = "to";
var dependencies123 = ["typed", "matrix", "concat"];
var createTo = /* @__PURE__ */ factory(name122, dependencies123, (_ref) => {
  var {
    typed: typed2,
    matrix,
    concat: concat2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name122, {
    "Unit, Unit | string": (x, unit) => x.to(unit)
  }, matrixAlgorithmSuite({
    Ds: true
  }));
});
// node_modules/mathjs/lib/esm/function/utils/isPrime.js
var name123 = "isPrime";
var dependencies124 = ["typed"];
var createIsPrime = /* @__PURE__ */ factory(name123, dependencies124, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name123, {
    number: function number(x) {
      if (x <= 3) {
        return x > 1;
      }
      if (x % 2 === 0 || x % 3 === 0) {
        return false;
      }
      for (var i = 5;i * i <= x; i += 6) {
        if (x % i === 0 || x % (i + 2) === 0) {
          return false;
        }
      }
      return true;
    },
    bigint: function bigint(x) {
      if (x <= 3n) {
        return x > 1n;
      }
      if (x % 2n === 0n || x % 3n === 0n) {
        return false;
      }
      for (var i = 5n;i * i <= x; i += 6n) {
        if (x % i === 0n || x % (i + 2n) === 0n) {
          return false;
        }
      }
      return true;
    },
    BigNumber: function BigNumber(n) {
      if (n.lte(3))
        return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0))
        return false;
      if (n.lt(Math.pow(2, 32))) {
        var x = n.toNumber();
        for (var i = 5;i * i <= x; i += 6) {
          if (x % i === 0 || x % (i + 2) === 0) {
            return false;
          }
        }
        return true;
      }
      function modPow(base, exponent, modulus) {
        var accumulator = 1;
        while (!exponent.eq(0)) {
          if (exponent.mod(2).eq(0)) {
            exponent = exponent.div(2);
            base = base.mul(base).mod(modulus);
          } else {
            exponent = exponent.sub(1);
            accumulator = base.mul(accumulator).mod(modulus);
          }
        }
        return accumulator;
      }
      var Decimal2 = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new Decimal2(n);
      var r = 0;
      var d = n.sub(1);
      while (d.mod(2).eq(0)) {
        d = d.div(2);
        r += 1;
      }
      var bases = null;
      if (n.lt("3317044064679887385961981")) {
        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
      } else {
        var max2 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        bases = [];
        for (var _i = 2;_i <= max2; _i += 1) {
          bases.push(max2);
        }
      }
      for (var _i2 = 0;_i2 < bases.length; _i2 += 1) {
        var a = bases[_i2];
        var adn = modPow(n.sub(n).add(a), d, n);
        if (!adn.eq(1)) {
          for (var _i3 = 0, _x = adn;!_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
            if (_i3 === r - 1) {
              return false;
            }
          }
        }
      }
      return true;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/function/utils/numeric.js
var name124 = "numeric";
var dependencies125 = ["number", "?bignumber", "?fraction"];
var createNumeric = /* @__PURE__ */ factory(name124, dependencies125, (_ref) => {
  var {
    number: _number,
    bignumber,
    fraction
  } = _ref;
  var validInputTypes = {
    string: true,
    number: true,
    BigNumber: true,
    Fraction: true
  };
  var validOutputTypes = {
    number: (x) => _number(x),
    BigNumber: bignumber ? (x) => bignumber(x) : noBignumber,
    bigint: (x) => BigInt(x),
    Fraction: fraction ? (x) => fraction(x) : noFraction
  };
  return function numeric(value) {
    var outputType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "number";
    var check = arguments.length > 2 ? arguments[2] : undefined;
    if (check !== undefined) {
      throw new SyntaxError("numeric() takes one or two arguments");
    }
    var inputType = typeOf(value);
    if (!(inputType in validInputTypes)) {
      throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
    }
    if (!(outputType in validOutputTypes)) {
      throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
    }
    if (outputType === inputType) {
      return value;
    } else {
      return validOutputTypes[outputType](value);
    }
  };
});
// node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
var name125 = "divideScalar";
var dependencies126 = ["typed", "numeric"];
var createDivideScalar = /* @__PURE__ */ factory(name125, dependencies126, (_ref) => {
  var {
    typed: typed2,
    numeric
  } = _ref;
  return typed2(name125, {
    "number, number": function number_number(x, y) {
      return x / y;
    },
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.div(y);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x / y;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
    "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/pow.js
var name126 = "pow";
var dependencies127 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = /* @__PURE__ */ factory(name126, dependencies127, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    identity,
    multiply,
    matrix,
    inv,
    number,
    fraction,
    Complex: Complex2
  } = _ref;
  return typed2(name126, {
    "number, number": _pow,
    "Complex, Complex": function Complex_Complex(x, y) {
      return x.pow(y);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      if (y.isInteger() || x >= 0 || config4.predictable) {
        return x.pow(y);
      } else {
        return new Complex2(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },
    "bigint, bigint": (x, y) => x ** y,
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      var result = x.pow(y);
      if (result != null) {
        return result;
      }
      if (config4.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x.valueOf(), y.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function Array_BigNumber(x, y) {
      return _powArray(x, y.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function Matrix_BigNumber(x, y) {
      return _powMatrix(x, y.toNumber());
    },
    "Unit, number | BigNumber": function Unit_number__BigNumber(x, y) {
      return x.pow(y);
    }
  });
  function _pow(x, y) {
    if (config4.predictable && !isInteger(y) && x < 0) {
      try {
        var yFrac = fraction(y);
        var yNum = number(yFrac);
        if (y === yNum || Math.abs((y - yNum) / y) < 0.00000000000001) {
          if (yFrac.d % 2n === 1n) {
            return (yFrac.n % 2n === 0n ? 1 : -1) * Math.pow(-x, y);
          }
        }
      } catch (ex) {
      }
    }
    if (config4.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
      return NaN;
    }
    if (isInteger(y) || x >= 0 || config4.predictable) {
      return powNumber(x, y);
    } else {
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return new Complex2(x, 0).pow(y, 0);
    }
  }
  function _powArray(x, y) {
    if (!isInteger(y)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
    }
    var s = arraySize(x);
    if (s.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
    }
    if (s[0] !== s[1]) {
      throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
    }
    if (y < 0) {
      try {
        return _powArray(inv(x), -y);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
        }
        throw error;
      }
    }
    var res = identity(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) === 1) {
        res = multiply(px, res);
      }
      y >>= 1;
      px = multiply(px, px);
    }
    return res;
  }
  function _powMatrix(x, y) {
    return matrix(_powArray(x.valueOf(), y));
  }
});
// node_modules/mathjs/lib/esm/function/arithmetic/round.js
var NO_INT = "Number of decimals in function round must be an integer";
var name127 = "round";
var dependencies128 = ["typed", "config", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = /* @__PURE__ */ factory(name127, dependencies128, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    equalScalar,
    zeros: zeros2,
    BigNumber: _BigNumber,
    DenseMatrix
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function toExponent(epsilon) {
    return Math.abs(splitNumber(epsilon).exponent);
  }
  return typed2(name127, {
    number: function number(x) {
      var xEpsilon = roundNumber(x, toExponent(config4.relTol));
      var xSelected = nearlyEqual(x, xEpsilon, config4.relTol, config4.absTol) ? xEpsilon : x;
      return roundNumber(xSelected);
    },
    "number, number": function number_number(x, n) {
      var epsilonExponent = toExponent(config4.relTol);
      if (n >= epsilonExponent) {
        return roundNumber(x, n);
      }
      var xEpsilon = roundNumber(x, epsilonExponent);
      var xSelected = nearlyEqual(x, xEpsilon, config4.relTol, config4.absTol) ? xEpsilon : x;
      return roundNumber(xSelected, n);
    },
    "number, BigNumber": function number_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new _BigNumber(x).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex(x) {
      return x.round();
    },
    "Complex, number": function Complex_number(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Complex, BigNumber": function Complex_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x.round(_n);
    },
    BigNumber: function BigNumber(x) {
      var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config4.relTol));
      var xSelected = nearlyEqual2(x, xEpsilon, config4.relTol, config4.absTol) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var epsilonExponent = toExponent(config4.relTol);
      if (n >= epsilonExponent) {
        return x.toDecimalPlaces(n.toNumber());
      }
      var xEpsilon = x.toDecimalPlaces(epsilonExponent);
      var xSelected = nearlyEqual2(x, xEpsilon, config4.relTol, config4.absTol) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(n.toNumber());
    },
    bigint: (b) => b,
    "bigint, number": (b, _dummy) => b,
    "bigint, BigNumber": (b, _dummy) => b,
    Fraction: function Fraction(x) {
      return x.round();
    },
    "Fraction, number": function Fraction_number(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Fraction, BigNumber": function Fraction_BigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.round(n.toNumber());
    },
    "Unit, number, Unit": typed2.referToSelf((self2) => function(x, n, unit) {
      var valueless = x.toNumeric(unit);
      return unit.multiply(self2(valueless, n));
    }),
    "Unit, BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => self2(x, n.toNumber(), unit)),
    "Array | Matrix, number | BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit) => {
      return deepMap(x, (value) => self2(value, n, unit), true);
    }),
    "Array | Matrix | Unit, Unit": typed2.referToSelf((self2) => (x, unit) => self2(x, 0, unit)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo11xS0s(x, n, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(x, n, self2, false);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(matrix(x), n, self2, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed2.referToSelf((self2) => (x, n) => {
      if (equalScalar(x, 0)) {
        return zeros2(n.size(), n.storage());
      }
      return matAlgo12xSfs(n, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed2.referToSelf((self2) => (x, n) => {
      if (equalScalar(x, 0)) {
        return zeros2(n.size(), n.storage());
      }
      return matAlgo14xDs(n, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(matrix(n), x, self2, true).valueOf();
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/log.js
var name128 = "log";
var dependencies129 = ["config", "typed", "typeOf", "divideScalar", "Complex"];
var nlg16 = Math.log(16);
var createLog = /* @__PURE__ */ factory(name128, dependencies129, (_ref) => {
  var {
    typed: typed2,
    typeOf: typeOf2,
    config: config4,
    divideScalar,
    Complex: Complex2
  } = _ref;
  function complexLog(c) {
    return c.log();
  }
  function complexLogNumber(x) {
    return complexLog(new Complex2(x, 0));
  }
  return typed2(name128, {
    number: function number(x) {
      if (x >= 0 || config4.predictable) {
        return logNumber(x);
      } else {
        return complexLogNumber(x);
      }
    },
    bigint: promoteLogarithm(nlg16, logNumber, config4, complexLogNumber),
    Complex: complexLog,
    BigNumber: function BigNumber(x) {
      if (!x.isNegative() || config4.predictable) {
        return x.ln();
      } else {
        return complexLogNumber(x.toNumber());
      }
    },
    "any, any": typed2.referToSelf((self2) => (x, base) => {
      if (typeOf2(x) === "Fraction" && typeOf2(base) === "Fraction") {
        var result = x.log(base);
        if (result !== null) {
          return result;
        }
      }
      return divideScalar(self2(x), self2(base));
    })
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
var name129 = "log1p";
var dependencies130 = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = /* @__PURE__ */ factory(name129, dependencies130, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    divideScalar,
    log: log3,
    Complex: Complex2
  } = _ref;
  return typed2(name129, {
    number: function number(x) {
      if (x >= -1 || config4.predictable) {
        return log1p(x);
      } else {
        return _log1pComplex(new Complex2(x, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber(x) {
      var y = x.plus(1);
      if (!y.isNegative() || config4.predictable) {
        return y.ln();
      } else {
        return _log1pComplex(new Complex2(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    "any, any": typed2.referToSelf((self2) => (x, base) => {
      return divideScalar(self2(x), log3(base));
    })
  });
  function _log1pComplex(x) {
    var xRe1p = x.re + 1;
    return new Complex2(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
  }
});
// node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
var name130 = "nthRoots";
var dependencies131 = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = /* @__PURE__ */ factory(name130, dependencies131, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    divideScalar,
    Complex: Complex2
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex2(val, 0);
  }, function imagPos(val) {
    return new Complex2(0, val);
  }, function realNeg(val) {
    return new Complex2(-val, 0);
  }, function imagNeg(val) {
    return new Complex2(0, -val);
  }];
  function _nthComplexRoots(a, root) {
    if (root < 0)
      throw new Error("Root must be greater than zero");
    if (root === 0)
      throw new Error("Root must be non-zero");
    if (root % 1 !== 0)
      throw new Error("Root must be an integer");
    if (a === 0 || a.abs() === 0)
      return [new Complex2(0, 0)];
    var aIsNumeric = typeof a === "number";
    var offset;
    if (aIsNumeric || a.re === 0 || a.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a < 0);
      } else if (a.im === 0) {
        offset = 2 * +(a.re < 0);
      } else {
        offset = 2 * +(a.im < 0) + 1;
      }
    }
    var arg = a.arg();
    var abs2 = a.abs();
    var roots = [];
    var r = Math.pow(abs2, 1 / root);
    for (var k = 0;k < root; k++) {
      var halfPiFactor = (offset + 4 * k) / root;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex2({
        r,
        phi: (arg + 2 * Math.PI * k) / root
      }));
    }
    return roots;
  }
  return typed2(name130, {
    Complex: function Complex(x) {
      return _nthComplexRoots(x, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
var name131 = "dotPow";
var dependencies132 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat", "SparseMatrix"];
var createDotPow = /* @__PURE__ */ factory(name131, dependencies132, (_ref) => {
  var {
    typed: typed2,
    equalScalar,
    matrix,
    pow: pow2,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var powScalarSignatures = {};
  for (var signature in pow2.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow2.signatures[signature];
      }
    }
  }
  var powScalar = typed2(powScalarSignatures);
  return typed2(name131, matrixAlgorithmSuite({
    elop: powScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
// node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
var name132 = "dotDivide";
var dependencies133 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat", "SparseMatrix"];
var createDotDivide = /* @__PURE__ */ factory(name132, dependencies133, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    divideScalar,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name132, matrixAlgorithmSuite({
    elop: divideScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
// node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
function createSolveValidation(_ref) {
  var {
    DenseMatrix
  } = _ref;
  return function solveValidation(m, b, copy) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i = 0;i < rows; i++) {
          data[i] = [bdata[i]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (var _i = 0;_i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0;_i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values = b._values;
          var index = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0];k < k1; k++) {
            var _i3 = index[k];
            data[_i3][0] = values[k];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0;_i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0;_i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
var name133 = "lsolve";
var dependencies134 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolve = /* @__PURE__ */ factory(name133, dependencies134, (_ref) => {
  var {
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix
  });
  return typed2(name133, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix(a);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = 0;j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = undefined;
      if (!equalScalar(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar(bj, vjj);
        for (var i = j + 1;i < rows; i++) {
          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = 0;j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = firstIndex;k < lastIndex; k++) {
          var i = index[k];
          if (i === j) {
            vjj = values[k];
          } else if (i > j) {
            jValues.push(values[k]);
            jIndices.push(i);
          }
        }
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar(bj, vjj);
        for (var _k = 0, l = jIndices.length;_k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
});
// node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
var name134 = "usolve";
var dependencies135 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolve = /* @__PURE__ */ factory(name134, dependencies135, (_ref) => {
  var {
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix
  });
  return typed2(name134, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix(a);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = columns - 1;j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = undefined;
      if (!equalScalar(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar(bj, vjj);
        for (var i = j - 1;i >= 0; i--) {
          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = columns - 1;j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = lastIndex - 1;k >= firstIndex; k--) {
          var i = index[k];
          if (i === j) {
            vjj = values[k];
          } else if (i < j) {
            jValues.push(values[k]);
            jIndices.push(i);
          }
        }
        if (equalScalar(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length;_k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix({
      data: x,
      size: [rows, 1]
    });
  }
});
// node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
var name135 = "lsolveAll";
var dependencies136 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolveAll = /* @__PURE__ */ factory(name135, dependencies136, (_ref) => {
  var {
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix
  });
  return typed2(name135, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix(a);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i = 0;i < columns; i++) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        if (!equalScalar(M[i][i], 0)) {
          b[i] = divideScalar(b[i], M[i][i]);
          for (var j = i + 1;j < columns; j++) {
            b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j = i + 1;_j < columns; _j++) {
            bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var i = 0;i < columns; i++) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i];
        var lastIndex = ptr[i + 1];
        var Mii = 0;
        for (var j = firstIndex;j < lastIndex; j++) {
          var J = index[j];
          if (J === i) {
            Mii = values[j];
          } else if (J > i) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar(Mii, 0)) {
          b[i] = divideScalar(b[i], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length;_j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length;_j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
// node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
var name136 = "usolveAll";
var dependencies137 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolveAll = /* @__PURE__ */ factory(name136, dependencies137, (_ref) => {
  var {
    typed: typed2,
    matrix,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    equalScalar,
    DenseMatrix
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix
  });
  return typed2(name136, {
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      var m = matrix(a);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i = columns - 1;i >= 0; i--) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        if (!equalScalar(M[i][i], 0)) {
          b[i] = divideScalar(b[i], M[i][i]);
          for (var j = i - 1;j >= 0; j--) {
            b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j = i - 1;_j >= 0; _j--) {
            bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    for (var i = columns - 1;i >= 0; i--) {
      var L = B.length;
      for (var k = 0;k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i];
        var lastIndex = ptr[i + 1];
        var Mii = 0;
        for (var j = lastIndex - 1;j >= firstIndex; j--) {
          var J = index[j];
          if (J === i) {
            Mii = values[j];
          } else if (J < i) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar(Mii, 0)) {
          b[i] = divideScalar(b[i], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length;_j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
          }
        } else if (!equalScalar(b[i], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length;_j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
var name137 = "matAlgo08xS0Sid";
var dependencies138 = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name137, dependencies138, (_ref) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref;
  return function matAlgo08xS0Sid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x = [];
    var w = [];
    var k, k0, k1, i;
    for (var j = 0;j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0;k < k1; k++) {
        i = aindex[k];
        w[i] = mark;
        x[i] = avalues[k];
        cindex.push(i);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0;k < k1; k++) {
        i = bindex[k];
        if (w[i] === mark) {
          x[i] = cf(x[i], bvalues[k]);
        }
      }
      k = cptr[j];
      while (k < cindex.length) {
        i = cindex[k];
        var v = x[i];
        if (!eq(v, zero)) {
          cvalues.push(v);
          k++;
        } else {
          cindex.splice(k, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined
    });
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
var createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed: typed2,
    matrix
  } = _ref;
  return {
    "Array, number": typed2.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix(x), y).valueOf()),
    "Array, BigNumber": typed2.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix(x), y).valueOf()),
    "number, Array": typed2.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix(y)).valueOf()),
    "BigNumber, Array": typed2.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix(y)).valueOf())
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
var name138 = "leftShift";
var dependencies139 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createLeftShift = /* @__PURE__ */ factory(name138, dependencies139, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix
  });
  return typed2(name138, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "bigint, bigint": (x, y) => x << y,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
// node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
var name139 = "rightArithShift";
var dependencies140 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightArithShift = /* @__PURE__ */ factory(name139, dependencies140, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix
  });
  return typed2(name139, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "bigint, bigint": (x, y) => x >> y,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
// node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
var name140 = "rightLogShift";
var dependencies141 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightLogShift = /* @__PURE__ */ factory(name140, dependencies141, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix
  });
  return typed2(name140, {
    "number, number": rightLogShiftNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
// node_modules/mathjs/lib/esm/function/logical/and.js
var name141 = "and";
var dependencies142 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
var createAnd = /* @__PURE__ */ factory(name141, dependencies142, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    not,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name141, {
    "number, number": andNumber,
    "Complex, Complex": function Complex_Complex(x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },
    "bigint, bigint": andNumber,
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0)),
    "SparseMatrix, any": typed2.referToSelf((self2) => (x, y) => {
      if (not(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, any": typed2.referToSelf((self2) => (x, y) => {
      if (not(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "any, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (not(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(y, x, self2, true);
    }),
    "any, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (not(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    }),
    "Array, any": typed2.referToSelf((self2) => (x, y) => {
      return self2(matrix(x), y).valueOf();
    }),
    "any, Array": typed2.referToSelf((self2) => (x, y) => {
      return self2(x, matrix(y)).valueOf();
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0
  }));
});
// node_modules/mathjs/lib/esm/function/relational/compare.js
var name142 = "compare";
var dependencies143 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
var createCompare = /* @__PURE__ */ factory(name142, dependencies143, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    equalScalar,
    matrix,
    BigNumber,
    Fraction: Fraction2,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name142, createCompareNumber({
    typed: typed2,
    config: config4
  }), {
    "boolean, boolean": function boolean_boolean(x, y) {
      return x === y ? 0 : x > y ? 1 : -1;
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return nearlyEqual2(x, y, config4.relTol, config4.absTol) ? new BigNumber(0) : new BigNumber(x.cmp(y));
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x === y ? 0n : x > y ? 1n : -1n;
    },
    "Fraction, Fraction": function Fraction_Fraction(x, y) {
      return new Fraction2(x.compare(y));
    },
    "Complex, Complex": function Complex_Complex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createCompareNumber = /* @__PURE__ */ factory(name142, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config4
  } = _ref2;
  return typed2(name142, {
    "number, number": function number_number(x, y) {
      return nearlyEqual(x, y, config4.relTol, config4.absTol) ? 0 : x > y ? 1 : -1;
    }
  });
});
// node_modules/mathjs/lib/esm/function/relational/compareNatural.js
var import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
var name143 = "compareNatural";
var dependencies144 = ["typed", "compare"];
var createCompareNatural = /* @__PURE__ */ factory(name143, dependencies144, (_ref) => {
  var {
    typed: typed2,
    compare
  } = _ref;
  var compareBooleans = compare.signatures["boolean,boolean"];
  return typed2(name143, {
    "any, any": _compareNatural
  });
  function _compareNatural(x, y) {
    var typeX = typeOf(x);
    var typeY = typeOf(y);
    var c;
    if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
      c = compare(x, y);
      if (c.toString() !== "0") {
        return c > 0 ? 1 : -1;
      } else {
        return import_javascript_natural_sort.default(typeX, typeY);
      }
    }
    var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
      c = compareMatricesAndArrays(_compareNatural, x, y);
      if (c !== 0) {
        return c;
      } else {
        return import_javascript_natural_sort.default(typeX, typeY);
      }
    }
    if (typeX !== typeY) {
      return import_javascript_natural_sort.default(typeX, typeY);
    }
    if (typeX === "Complex") {
      return compareComplexNumbers(x, y);
    }
    if (typeX === "Unit") {
      if (x.equalBase(y)) {
        return _compareNatural(x.value, y.value);
      }
      return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
    }
    if (typeX === "boolean") {
      return compareBooleans(x, y);
    }
    if (typeX === "string") {
      return import_javascript_natural_sort.default(x, y);
    }
    if (typeX === "Object") {
      return compareObjects(_compareNatural, x, y);
    }
    if (typeX === "null") {
      return 0;
    }
    if (typeX === "undefined") {
      return 0;
    }
    throw new TypeError('Unsupported type of value "' + typeX + '"');
  }
  function compareMatricesAndArrays(compareNatural, x, y) {
    if (isSparseMatrix(x) && isSparseMatrix(y)) {
      return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
    }
    if (isSparseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural, x.toArray(), y);
    }
    if (isSparseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural, x, y.toArray());
    }
    if (isDenseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
    }
    if (isDenseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
    }
    if (!Array.isArray(x)) {
      return compareMatricesAndArrays(compareNatural, [x], y);
    }
    if (!Array.isArray(y)) {
      return compareMatricesAndArrays(compareNatural, x, [y]);
    }
    return compareArrays(compareNatural, x, y);
  }
  function compareArrays(compareNatural, x, y) {
    for (var i = 0, ii = Math.min(x.length, y.length);i < ii; i++) {
      var v = compareNatural(x[i], y[i]);
      if (v !== 0) {
        return v;
      }
    }
    if (x.length > y.length) {
      return 1;
    }
    if (x.length < y.length) {
      return -1;
    }
    return 0;
  }
  function compareObjects(compareNatural, x, y) {
    var keysX = Object.keys(x);
    var keysY = Object.keys(y);
    keysX.sort(import_javascript_natural_sort.default);
    keysY.sort(import_javascript_natural_sort.default);
    var c = compareArrays(compareNatural, keysX, keysY);
    if (c !== 0) {
      return c;
    }
    for (var i = 0;i < keysX.length; i++) {
      var v = compareNatural(x[keysX[i]], y[keysY[i]]);
      if (v !== 0) {
        return v;
      }
    }
    return 0;
  }
});
function compareComplexNumbers(x, y) {
  if (x.re > y.re) {
    return 1;
  }
  if (x.re < y.re) {
    return -1;
  }
  if (x.im > y.im) {
    return 1;
  }
  if (x.im < y.im) {
    return -1;
  }
  return 0;
}
// node_modules/mathjs/lib/esm/function/relational/compareText.js
var name144 = "compareText";
var dependencies145 = ["typed", "matrix", "concat"];
compareText.signature = "any, any";
var createCompareText = /* @__PURE__ */ factory(name144, dependencies145, (_ref) => {
  var {
    typed: typed2,
    matrix,
    concat: concat2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name144, compareText, matrixAlgorithmSuite({
    elop: compareText,
    Ds: true
  }));
});
// node_modules/mathjs/lib/esm/function/relational/equal.js
var name145 = "equal";
var dependencies146 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat", "SparseMatrix"];
var createEqual = /* @__PURE__ */ factory(name145, dependencies146, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name145, createEqualNumber({
    typed: typed2,
    equalScalar
  }), matrixAlgorithmSuite({
    elop: equalScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createEqualNumber = factory(name145, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref2;
  return typed2(name145, {
    "any, any": function any_any(x, y) {
      if (x === null) {
        return y === null;
      }
      if (y === null) {
        return x === null;
      }
      if (x === undefined) {
        return y === undefined;
      }
      if (y === undefined) {
        return x === undefined;
      }
      return equalScalar(x, y);
    }
  });
});
// node_modules/mathjs/lib/esm/function/relational/equalText.js
var name146 = "equalText";
var dependencies147 = ["typed", "compareText", "isZero"];
var createEqualText = /* @__PURE__ */ factory(name146, dependencies147, (_ref) => {
  var {
    typed: typed2,
    compareText: compareText2,
    isZero
  } = _ref;
  return typed2(name146, {
    "any, any": function any_any(x, y) {
      return isZero(compareText2(x, y));
    }
  });
});
// node_modules/mathjs/lib/esm/function/relational/smaller.js
var name147 = "smaller";
var dependencies148 = ["typed", "config", "bignumber", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createSmaller = /* @__PURE__ */ factory(name147, dependencies148, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    bignumber,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  function bignumSmaller(x, y) {
    return x.lt(y) && !nearlyEqual2(x, y, config4.relTol, config4.absTol);
  }
  return typed2(name147, createSmallerNumber({
    typed: typed2,
    config: config4
  }), {
    "boolean, boolean": (x, y) => x < y,
    "BigNumber, BigNumber": bignumSmaller,
    "bigint, bigint": (x, y) => x < y,
    "Fraction, Fraction": (x, y) => x.compare(y) === -1,
    "Fraction, BigNumber": function Fraction_BigNumber(x, y) {
      return bignumSmaller(bignumber(x), y);
    },
    "BigNumber, Fraction": function BigNumber_Fraction(x, y) {
      return bignumSmaller(x, bignumber(y));
    },
    "Complex, Complex": function Complex_Complex(x, y) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerNumber = /* @__PURE__ */ factory(name147, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config4
  } = _ref2;
  return typed2(name147, {
    "number, number": function number_number(x, y) {
      return x < y && !nearlyEqual(x, y, config4.relTol, config4.absTol);
    }
  });
});
// node_modules/mathjs/lib/esm/function/relational/smallerEq.js
var name148 = "smallerEq";
var dependencies149 = ["typed", "config", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createSmallerEq = /* @__PURE__ */ factory(name148, dependencies149, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name148, createSmallerEqNumber({
    typed: typed2,
    config: config4
  }), {
    "boolean, boolean": (x, y) => x <= y,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.lte(y) || nearlyEqual2(x, y, config4.relTol, config4.absTol);
    },
    "bigint, bigint": (x, y) => x <= y,
    "Fraction, Fraction": (x, y) => x.compare(y) !== 1,
    "Complex, Complex": function Complex_Complex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerEqNumber = /* @__PURE__ */ factory(name148, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config4
  } = _ref2;
  return typed2(name148, {
    "number, number": function number_number(x, y) {
      return x <= y || nearlyEqual(x, y, config4.relTol, config4.absTol);
    }
  });
});
// node_modules/mathjs/lib/esm/function/relational/larger.js
var name149 = "larger";
var dependencies150 = ["typed", "config", "bignumber", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createLarger = /* @__PURE__ */ factory(name149, dependencies150, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    bignumber,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  function bignumLarger(x, y) {
    return x.gt(y) && !nearlyEqual2(x, y, config4.relTol, config4.absTol);
  }
  return typed2(name149, createLargerNumber({
    typed: typed2,
    config: config4
  }), {
    "boolean, boolean": (x, y) => x > y,
    "BigNumber, BigNumber": bignumLarger,
    "bigint, bigint": (x, y) => x > y,
    "Fraction, Fraction": (x, y) => x.compare(y) === 1,
    "Fraction, BigNumber": function Fraction_BigNumber(x, y) {
      return bignumLarger(bignumber(x), y);
    },
    "BigNumber, Fraction": function BigNumber_Fraction(x, y) {
      return bignumLarger(x, bignumber(y));
    },
    "Complex, Complex": function Complex_Complex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerNumber = /* @__PURE__ */ factory(name149, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config4
  } = _ref2;
  return typed2(name149, {
    "number, number": function number_number(x, y) {
      return x > y && !nearlyEqual(x, y, config4.relTol, config4.absTol);
    }
  });
});
// node_modules/mathjs/lib/esm/function/relational/largerEq.js
var name150 = "largerEq";
var dependencies151 = ["typed", "config", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createLargerEq = /* @__PURE__ */ factory(name150, dependencies151, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name150, createLargerEqNumber({
    typed: typed2,
    config: config4
  }), {
    "boolean, boolean": (x, y) => x >= y,
    "BigNumber, BigNumber": function BigNumber_BigNumber(x, y) {
      return x.gte(y) || nearlyEqual2(x, y, config4.relTol, config4.absTol);
    },
    "bigint, bigint": function bigint_bigint(x, y) {
      return x >= y;
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== -1,
    "Complex, Complex": function Complex_Complex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerEqNumber = /* @__PURE__ */ factory(name150, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config4
  } = _ref2;
  return typed2(name150, {
    "number, number": function number_number(x, y) {
      return x >= y || nearlyEqual(x, y, config4.relTol, config4.absTol);
    }
  });
});
// node_modules/mathjs/lib/esm/function/relational/deepEqual.js
var name151 = "deepEqual";
var dependencies152 = ["typed", "equal"];
var createDeepEqual = /* @__PURE__ */ factory(name151, dependencies152, (_ref) => {
  var {
    typed: typed2,
    equal
  } = _ref;
  return typed2(name151, {
    "any, any": function any_any(x, y) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }
  });
  function _deepEqual(x, y) {
    if (Array.isArray(x)) {
      if (Array.isArray(y)) {
        var len = x.length;
        if (len !== y.length) {
          return false;
        }
        for (var i = 0;i < len; i++) {
          if (!_deepEqual(x[i], y[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      if (Array.isArray(y)) {
        return false;
      } else {
        return equal(x, y);
      }
    }
  }
});
// node_modules/mathjs/lib/esm/function/relational/unequal.js
var name152 = "unequal";
var dependencies153 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat", "SparseMatrix"];
var createUnequal = /* @__PURE__ */ factory(name152, dependencies153, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    equalScalar,
    matrix,
    DenseMatrix,
    concat: concat2,
    SparseMatrix
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    SparseMatrix
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name152, createUnequalNumber({
    typed: typed2,
    equalScalar
  }), matrixAlgorithmSuite({
    elop: _unequal,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
  function _unequal(x, y) {
    return !equalScalar(x, y);
  }
});
var createUnequalNumber = factory(name152, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed2,
    equalScalar
  } = _ref2;
  return typed2(name152, {
    "any, any": function any_any(x, y) {
      if (x === null) {
        return y !== null;
      }
      if (y === null) {
        return x !== null;
      }
      if (x === undefined) {
        return y !== undefined;
      }
      if (y === undefined) {
        return x !== undefined;
      }
      return !equalScalar(x, y);
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
var name153 = "partitionSelect";
var dependencies154 = ["typed", "isNumeric", "isNaN", "compare"];
var createPartitionSelect = /* @__PURE__ */ factory(name153, dependencies154, (_ref) => {
  var {
    typed: typed2,
    isNumeric,
    isNaN: isNaN2,
    compare
  } = _ref;
  var asc = compare;
  var desc = (a, b) => -compare(a, b);
  return typed2(name153, {
    "Array | Matrix, number": function Array__Matrix_number(x, k) {
      return _partitionSelect(x, k, asc);
    },
    "Array | Matrix, number, string": function Array__Matrix_number_string(x, k, compare2) {
      if (compare2 === "asc") {
        return _partitionSelect(x, k, asc);
      } else if (compare2 === "desc") {
        return _partitionSelect(x, k, desc);
      } else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },
    "Array | Matrix, number, function": _partitionSelect
  });
  function _partitionSelect(x, k, compare2) {
    if (!isInteger(k) || k < 0) {
      throw new Error("k must be a non-negative integer");
    }
    if (isMatrix(x)) {
      var size = x.size();
      if (size.length > 1) {
        throw new Error("Only one dimensional matrices supported");
      }
      return quickSelect(x.valueOf(), k, compare2);
    }
    if (Array.isArray(x)) {
      return quickSelect(x, k, compare2);
    }
  }
  function quickSelect(arr, k, compare2) {
    if (k >= arr.length) {
      throw new Error("k out of bounds");
    }
    for (var i = 0;i < arr.length; i++) {
      if (isNumeric(arr[i]) && isNaN2(arr[i])) {
        return arr[i];
      }
    }
    var from = 0;
    var to = arr.length - 1;
    while (from < to) {
      var r = from;
      var w = to;
      var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
      while (r < w) {
        if (compare2(arr[r], pivot) >= 0) {
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else {
          ++r;
        }
      }
      if (compare2(arr[r], pivot) > 0) {
        --r;
      }
      if (k <= r) {
        to = r;
      } else {
        from = r + 1;
      }
    }
    return arr[k];
  }
});
// node_modules/mathjs/lib/esm/function/matrix/sort.js
var name154 = "sort";
var dependencies155 = ["typed", "matrix", "compare", "compareNatural"];
var createSort = /* @__PURE__ */ factory(name154, dependencies155, (_ref) => {
  var {
    typed: typed2,
    matrix,
    compare,
    compareNatural
  } = _ref;
  var compareAsc = compare;
  var compareDesc = (a, b) => -compare(a, b);
  return typed2(name154, {
    Array: function Array(x) {
      _arrayIsVector(x);
      return x.sort(compareAsc);
    },
    Matrix: function Matrix(x) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(compareAsc), x.storage());
    },
    "Array, function": function Array_function(x, _comparator2) {
      _arrayIsVector(x);
      return x.sort(_comparator2);
    },
    "Matrix, function": function Matrix_function(x, _comparator2) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator2), x.storage());
    },
    "Array, string": function Array_string(x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },
    "Matrix, string": function Matrix_string(x, order) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator(order)), x.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array) {
    if (arraySize(array).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix2) {
    if (matrix2.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});
// node_modules/mathjs/lib/esm/function/statistics/max.js
var name155 = "max";
var dependencies156 = ["typed", "config", "numeric", "larger"];
var createMax = /* @__PURE__ */ factory(name155, dependencies156, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    numeric,
    larger
  } = _ref;
  return typed2(name155, {
    "Array | Matrix": _max,
    "Array | Matrix, number | BigNumber": function Array__Matrix_number__BigNumber(array, dim) {
      return reduce(array, dim.valueOf(), _largest);
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function max");
      }
      return _max(args);
    }
  });
  function _largest(x, y) {
    try {
      return larger(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "max", y);
    }
  }
  function _max(array) {
    var res;
    deepForEach(array, function(value) {
      try {
        if (typeof value === "number" && isNaN(value)) {
          res = NaN;
        } else if (res === undefined || larger(value, res)) {
          res = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "max", value);
      }
    });
    if (res === undefined) {
      throw new Error("Cannot calculate max of an empty array");
    }
    if (typeof res === "string") {
      res = numeric(res, safeNumberType(res, config4));
    }
    return res;
  }
});
// node_modules/mathjs/lib/esm/function/statistics/min.js
var name156 = "min";
var dependencies157 = ["typed", "config", "numeric", "smaller"];
var createMin = /* @__PURE__ */ factory(name156, dependencies157, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    numeric,
    smaller
  } = _ref;
  return typed2(name156, {
    "Array | Matrix": _min,
    "Array | Matrix, number | BigNumber": function Array__Matrix_number__BigNumber(array, dim) {
      return reduce(array, dim.valueOf(), _smallest);
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function min");
      }
      return _min(args);
    }
  });
  function _smallest(x, y) {
    try {
      return smaller(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "min", y);
    }
  }
  function _min(array) {
    var min2;
    deepForEach(array, function(value) {
      try {
        if (typeof value === "number" && isNaN(value)) {
          min2 = NaN;
        } else if (min2 === undefined || smaller(value, min2)) {
          min2 = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "min", value);
      }
    });
    if (min2 === undefined) {
      throw new Error("Cannot calculate min of an empty array");
    }
    if (typeof min2 === "string") {
      min2 = numeric(min2, safeNumberType(min2, config4));
    }
    return min2;
  }
});
// node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
var name157 = "ImmutableDenseMatrix";
var dependencies158 = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name157, dependencies158, (_ref) => {
  var {
    smaller,
    DenseMatrix
  } = _ref;
  function ImmutableDenseMatrix(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray(data)) {
      var matrix = new DenseMatrix(data, datatype);
      this._data = matrix._data;
      this._size = matrix._size;
      this._datatype = matrix._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix.prototype = new DenseMatrix;
  ImmutableDenseMatrix.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix.prototype.subset = function(index) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix.prototype.subset.call(this, index);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.clone = function() {
    return new ImmutableDenseMatrix({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix.fromJSON = function(json) {
    return new ImmutableDenseMatrix(json);
  };
  ImmutableDenseMatrix.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : undefined;
    }
    return this._min;
  };
  ImmutableDenseMatrix.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : undefined;
    }
    return this._max;
  };
  return ImmutableDenseMatrix;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
var name158 = "Index";
var dependencies159 = ["ImmutableDenseMatrix", "getMatrixDataType"];
var createIndexClass = /* @__PURE__ */ factory(name158, dependencies159, (_ref) => {
  var {
    ImmutableDenseMatrix,
    getMatrixDataType
  } = _ref;
  function Index(ranges) {
    if (!(this instanceof Index)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._sourceSize = [];
    this._isScalar = true;
    for (var i = 0, ii = arguments.length;i < ii; i++) {
      var arg = arguments[i];
      var argIsArray = isArray(arg);
      var argIsMatrix = isMatrix(arg);
      var argType = typeof arg;
      var sourceSize = null;
      if (isRange(arg)) {
        this._dimensions.push(arg);
        this._isScalar = false;
      } else if (argIsArray || argIsMatrix) {
        var m = undefined;
        if (getMatrixDataType(arg) === "boolean") {
          if (argIsArray)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg).valueOf());
          if (argIsMatrix)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg._data).valueOf());
          sourceSize = arg.valueOf().length;
        } else {
          m = _createImmutableMatrix(arg.valueOf());
        }
        this._dimensions.push(m);
        var size = m.size();
        if (size.length !== 1 || size[0] !== 1 || sourceSize !== null) {
          this._isScalar = false;
        }
      } else if (argType === "number") {
        this._dimensions.push(_createImmutableMatrix([arg]));
      } else if (argType === "bigint") {
        this._dimensions.push(_createImmutableMatrix([Number(arg)]));
      } else if (argType === "string") {
        this._dimensions.push(arg);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, bigint, string, or Range");
      }
      this._sourceSize.push(sourceSize);
    }
  }
  Index.prototype.type = "Index";
  Index.prototype.isIndex = true;
  function _createImmutableMatrix(arg) {
    for (var i = 0, l = arg.length;i < l; i++) {
      if (typeof arg[i] !== "number" || !isInteger(arg[i])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix(arg);
  }
  Index.prototype.clone = function() {
    var index = new Index;
    index._dimensions = clone(this._dimensions);
    index._isScalar = this._isScalar;
    index._sourceSize = this._sourceSize;
    return index;
  };
  Index.create = function(ranges) {
    var index = new Index;
    Index.apply(index, ranges);
    return index;
  };
  Index.prototype.size = function() {
    var size = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var d = this._dimensions[i];
      size[i] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size;
  };
  Index.prototype.max = function() {
    var values = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var range = this._dimensions[i];
      values[i] = typeof range === "string" ? range : range.max();
    }
    return values;
  };
  Index.prototype.min = function() {
    var values = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var range = this._dimensions[i];
      values[i] = typeof range === "string" ? range : range.min();
    }
    return values;
  };
  Index.prototype.forEach = function(callback) {
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      callback(this._dimensions[i], i, this);
    }
  };
  Index.prototype.dimension = function(dim) {
    if (typeof dim !== "number") {
      return null;
    }
    return this._dimensions[dim] || null;
  };
  Index.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index.prototype.toArray = function() {
    var array = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var dimension = this._dimensions[i];
      array.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array;
  };
  Index.prototype.valueOf = Index.prototype.toArray;
  Index.prototype.toString = function() {
    var strings = [];
    for (var i = 0, ii = this._dimensions.length;i < ii; i++) {
      var dimension = this._dimensions[i];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index.fromJSON = function(json) {
    return Index.create(json.dimensions);
  };
  return Index;
}, {
  isClass: true
});
function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
  var indexOfNumbers = [];
  booleanArrayIndex.forEach((bool, idx) => {
    if (bool) {
      indexOfNumbers.push(idx);
    }
  });
  return indexOfNumbers;
}
// node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
var name159 = "FibonacciHeap";
var dependencies160 = ["smaller", "larger"];
var createFibonacciHeapClass = /* @__PURE__ */ factory(name159, dependencies160, (_ref) => {
  var {
    smaller,
    larger
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap() {
    if (!(this instanceof FibonacciHeap)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap.prototype.type = "FibonacciHeap";
  FibonacciHeap.prototype.isFibonacciHeap = true;
  FibonacciHeap.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size) {
    var arraySize2 = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
    var array = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array[d];
        if (!y) {
          break;
        }
        if (larger(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        _linkNodes(y, x);
        array[d] = null;
        d++;
      }
      array[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i = 0;i < arraySize2; i++) {
      y = array[i];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/type/matrix/Spa.js
var name160 = "Spa";
var dependencies161 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = /* @__PURE__ */ factory(name160, dependencies161, (_ref) => {
  var {
    addScalar,
    equalScalar,
    FibonacciHeap
  } = _ref;
  function Spa() {
    if (!(this instanceof Spa)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap;
  }
  Spa.prototype.type = "Spa";
  Spa.prototype.isSpa = true;
  Spa.prototype.set = function(i, v) {
    if (!this._values[i]) {
      var node = this._heap.insert(i, v);
      this._values[i] = node;
    } else {
      this._values[i].value = v;
    }
  };
  Spa.prototype.get = function(i) {
    var node = this._values[i];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa.prototype.accumulate = function(i, v) {
    var node = this._values[i];
    if (!node) {
      node = this._heap.insert(i, v);
      this._values[i] = node;
    } else {
      node.value = addScalar(node.value, v);
    }
  };
  Spa.prototype.forEach = function(from, to, callback) {
    var heap = this._heap;
    var values = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to) {
      if (node.key >= from) {
        if (!equalScalar(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i = 0;i < nodes.length; i++) {
      var n = nodes[i];
      node = heap.insert(n.key, n.value);
      values[node.key] = node;
    }
  };
  Spa.prototype.swap = function(i, j) {
    var nodei = this._values[i];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i, nodej.value);
      this._heap.remove(nodej);
      this._values[i] = nodei;
      this._values[j] = undefined;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i] = undefined;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/utils/lruQueue.js
function lruQueue(limit) {
  var size = 0;
  var base = 1;
  var queue = Object.create(null);
  var map2 = Object.create(null);
  var index = 0;
  var del = function del(id) {
    var oldIndex = map2[id];
    if (!oldIndex)
      return;
    delete queue[oldIndex];
    delete map2[id];
    --size;
    if (base !== oldIndex)
      return;
    if (!size) {
      index = 0;
      base = 1;
      return;
    }
    while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
    }
  };
  limit = Math.abs(limit);
  return {
    hit: function hit(id) {
      var oldIndex = map2[id];
      var nuIndex = ++index;
      queue[nuIndex] = id;
      map2[id] = nuIndex;
      if (!oldIndex) {
        ++size;
        if (size <= limit)
          return;
        id = queue[base];
        del(id);
        return id;
      }
      delete queue[oldIndex];
      if (base !== oldIndex)
        return;
      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
      }
      return;
    },
    delete: del,
    clear: function clear() {
      size = index = 0;
      base = 1;
      queue = Object.create(null);
      map2 = Object.create(null);
    }
  };
}

// node_modules/mathjs/lib/esm/utils/function.js
function memoize(fn) {
  var {
    hasher,
    limit
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher = hasher == null ? JSON.stringify : hasher;
  return function memoize() {
    if (typeof memoize.cache !== "object") {
      memoize.cache = {
        values: new Map,
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    var args = [];
    for (var i = 0;i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    var hash = hasher(args);
    if (memoize.cache.values.has(hash)) {
      memoize.cache.lru.hit(hash);
      return memoize.cache.values.get(hash);
    }
    var newVal = fn.apply(fn, args);
    memoize.cache.values.set(hash, newVal);
    memoize.cache.values.delete(memoize.cache.lru.hit(hash));
    return newVal;
  };
}

// node_modules/mathjs/lib/esm/utils/bignumber/constants.js
var createBigNumberE = memoize(function(BigNumber) {
  return new BigNumber(1).exp();
}, {
  hasher
});
var createBigNumberPhi = memoize(function(BigNumber) {
  return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
}, {
  hasher
});
var createBigNumberPi = memoize(function(BigNumber) {
  return BigNumber.acos(-1);
}, {
  hasher
});
var createBigNumberTau = memoize(function(BigNumber) {
  return createBigNumberPi(BigNumber).times(2);
}, {
  hasher
});
function hasher(args) {
  return args[0].precision;
}

// node_modules/mathjs/lib/esm/type/unit/Unit.js
function ownKeys2(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e2) {
  for (var r = 1;r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name161 = "Unit";
var dependencies162 = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = /* @__PURE__ */ factory(name161, dependencies162, (_ref) => {
  var {
    on,
    config: config4,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    pow: pow2,
    abs: abs2,
    fix,
    round: round2,
    equal,
    isNumeric,
    format: format4,
    number: _number,
    Complex: Complex2,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber = _number;
  function Unit(value, valuelessUnit) {
    if (!(this instanceof Unit)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === undefined || isNumeric(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
    if (valuelessUnit === undefined) {
      this.units = [];
      this.dimensions = BASE_DIMENSIONS.map((x) => 0);
    } else if (typeof valuelessUnit === "string") {
      var u = Unit.parse(valuelessUnit);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
      this.fixPrefix = valuelessUnit.fixPrefix;
      this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
      this.dimensions = valuelessUnit.dimensions.slice(0);
      this.units = valuelessUnit.units.map((u2) => _extends({}, u2));
    } else {
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    }
    this.value = this._normalize(value);
  }
  Object.defineProperty(Unit, "name", {
    value: "Unit"
  });
  Unit.prototype.constructor = Unit;
  Unit.prototype.type = "Unit";
  Unit.prototype.isUnit = true;
  var text, index, c;
  function skipWhitespace() {
    while (c === " " || c === "\t") {
      next();
    }
  }
  function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  }
  function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  }
  function next() {
    index++;
    c = text.charAt(index);
  }
  function revert(oldIndex) {
    index = oldIndex;
    c = text.charAt(index);
  }
  function parseNumber() {
    var number = "";
    var oldIndex = index;
    if (c === "+") {
      next();
    } else if (c === "-") {
      number += c;
      next();
    }
    if (!isDigitDot(c)) {
      revert(oldIndex);
      return null;
    }
    if (c === ".") {
      number += c;
      next();
      if (!isDigit(c)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c)) {
        number += c;
        next();
      }
      if (c === ".") {
        number += c;
        next();
      }
    }
    while (isDigit(c)) {
      number += c;
      next();
    }
    if (c === "E" || c === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index;
      tentativeNumber += c;
      next();
      if (c === "+" || c === "-") {
        tentativeNumber += c;
        next();
      }
      if (!isDigit(c)) {
        revert(tentativeIndex);
        return number;
      }
      number = number + tentativeNumber;
      while (isDigit(c)) {
        number += c;
        next();
      }
    }
    return number;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c) || Unit.isValidAlpha(c)) {
      unitName += c;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit.parse = function(str, options) {
    options = options || {};
    text = str;
    index = -1;
    c = "";
    if (typeof text !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit2 = new Unit;
    unit2.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config4.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config4.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = undefined;
      if (c) {
        var oldC = c;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p = parseNumber();
        if (p === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }
      unit2.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
        unit2.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
      }
      skipWhitespace();
      while (c === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }
    if (unit2.units.length === 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit2.value = value !== undefined ? unit2._normalize(value) : null;
    return unit2;
  };
  Unit.prototype.clone = function() {
    var unit2 = new Unit;
    unit2.fixPrefix = this.fixPrefix;
    unit2.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit2.value = clone(this.value);
    unit2.dimensions = this.dimensions.slice(0);
    unit2.units = [];
    for (var i = 0;i < this.units.length; i++) {
      unit2.units[i] = {};
      for (var p in this.units[i]) {
        if (hasOwnProperty(this.units[i], p)) {
          unit2.units[i][p] = this.units[i][p];
        }
      }
    }
    return unit2;
  };
  Unit.prototype.valueType = function() {
    return typeOf(this.value);
  };
  Unit.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 0.000000000000001;
  };
  Unit.prototype._normalize = function(value) {
    if (value === null || value === undefined || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit._getNumberConverter(typeOf(value));
    for (var i = 0;i < this.units.length; i++) {
      var unitValue = convert(this.units[i].unit.value);
      var unitPrefixValue = convert(this.units[i].prefix.value);
      var unitPower = convert(this.units[i].power);
      res = multiplyScalar(res, pow2(multiplyScalar(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === undefined || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit._getNumberConverter(typeOf(value));
    for (var i = 0;i < this.units.length; i++) {
      var unitValue = convert(this.units[i].unit.value);
      var unitPrefixValue = convert(this.units[i].prefix.value);
      var unitPower = convert(this.units[i].power);
      res = divideScalar(res, pow2(multiplyScalar(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty(UNITS, str)) {
      var unit2 = UNITS[str];
      var prefix = unit2.prefixes[""];
      return {
        unit: unit2,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : undefined;
          if (_prefix !== undefined) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit.isValuelessUnit = function(name162) {
    return _findUnit(name162) !== null;
  };
  Unit.prototype.hasBase = function(base) {
    if (typeof base === "string") {
      base = BASE_UNITS[base];
    }
    if (!base) {
      return false;
    }
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 0.000000000001) {
        return false;
      }
    }
    return true;
  };
  Unit.prototype.equalBase = function(other) {
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 0.000000000001) {
        return false;
      }
    }
    return true;
  };
  Unit.prototype.equals = function(other) {
    return this.equalBase(other) && equal(this.value, other.value);
  };
  Unit.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit(_other);
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
    }
    for (var _i = 0;_i < other.units.length; _i++) {
      var inverted = _objectSpread2({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit.prototype.divideInto = function(numerator) {
    return new Unit(numerator).divide(this);
  };
  Unit.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit(_other);
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
    }
    for (var _i2 = 0;_i2 < other.units.length; _i2++) {
      var inverted = _objectSpread2(_objectSpread2({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit.prototype.pow = function(p) {
    var res = this.clone();
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      res.dimensions[i] = (this.dimensions[i] || 0) * p;
    }
    for (var _i3 = 0;_i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p;
    }
    if (res.value !== null) {
      res.value = pow2(res.value, p);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit2) {
    if (unit2.equalBase(BASE_UNITS.NONE) && unit2.value !== null && !config4.predictable) {
      return unit2.value;
    } else {
      return unit2;
    }
  }
  Unit.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units.length === 0 || ret.units[0].unit.offset === 0) {
        ret.value = abs2(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar(unitValue, nominalOffset);
        ret.value = subtractScalar(abs2(addScalar(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i in ret.units) {
      if (ret.units[i].unit.name === "VA" || ret.units[i].unit.name === "VAR") {
        ret.units[i].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units.length === 0 || other.units.length === 0 || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone(value);
    } else {
      var convert = Unit._getNumberConverter(typeOf(value));
      var thisUnitValue = this.units[0].unit.value;
      var thisNominalOffset = this.units[0].unit.offset;
      var thisUnitOffset = multiplyScalar(thisUnitValue, thisNominalOffset);
      var otherUnitValue = other.units[0].unit.value;
      var otherNominalOffset = other.units[0].unit.offset;
      var otherUnitOffset = multiplyScalar(otherUnitValue, otherNominalOffset);
      other.value = addScalar(value, convert(subtractScalar(thisUnitOffset, otherUnitOffset)));
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit.prototype.toNumber = function(valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };
  Unit.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit.prototype.toString = function() {
    return this.format();
  };
  Unit.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.units.length > 0 ? this.formatUnits() : null,
      fixPrefix: this.fixPrefix
    };
  };
  Unit.fromJSON = function(json) {
    var _json$unit;
    var unit2 = new Unit(json.value, (_json$unit = json.unit) !== null && _json$unit !== undefined ? _json$unit : undefined);
    unit2.fixPrefix = json.fixPrefix || false;
    return unit2;
  };
  Unit.prototype.valueOf = Unit.prototype.toString;
  Unit.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
          var baseDim = BASE_DIMENSIONS[i];
          if (Math.abs(ret.dimensions[i] || 0) > 0.000000000001) {
            if (hasOwnProperty(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i = 0;i < BASE_DIMENSIONS.length; i++) {
      var baseDim = BASE_DIMENSIONS[i];
      if (Math.abs(ret.dimensions[i] || 0) > 0.000000000001) {
        if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    if (this.value !== null) {
      ret.value = null;
      return this.to(ret);
    }
    return ret;
  };
  Unit.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i = 0;i < this.units.length; i++) {
      if (this.units[i].power > 0) {
        nNum++;
        strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
        if (Math.abs(this.units[i].power - 1) > 0.000000000000001) {
          strNum += "^" + this.units[i].power;
        }
      } else if (this.units[i].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0;_i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 0.000000000000001) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit.prototype.format = function(options) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 0.00000000000001;
    }
    for (var i in simp.units) {
      if (hasOwnProperty(simp.units, i)) {
        if (simp.units[i].unit) {
          if (simp.units[i].unit.name === "VA" && isImaginary) {
            simp.units[i].unit = UNITS.VAR;
          } else if (simp.units[i].unit.name === "VAR" && !isImaginary) {
            simp.units[i].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 0.00000000000001) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format4(value, options || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 0.00000000000001) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs2(this.value) : 0;
    var absUnitValue = abs2(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001)
      return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (hasOwnProperty(prefixes, p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {
          var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit.prototype.splitUnit = function(parts) {
    var x = this.clone();
    var ret = [];
    for (var i = 0;i < parts.length; i++) {
      x = x.to(parts[i]);
      if (i === parts.length - 1)
        break;
      var xNumeric = x.toNumeric();
      var xRounded = round2(xNumeric);
      var xFixed = undefined;
      var isNearlyEqual = equal(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix(x.toNumeric());
      }
      var y = new Unit(xFixed, parts[i].toString());
      ret.push(y);
      x = subtractScalar(x, y);
    }
    var testSum = 0;
    for (var _i5 = 0;_i5 < ret.length; _i5++) {
      testSum = addScalar(testSum, ret[_i5].value);
    }
    if (equal(testSum, this.value)) {
      x.value = 0;
    }
    ret.push(x);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1000,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000,
        scientific: true
      },
      R: {
        name: "R",
        value: 1000000000000000000000000000,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1000000000000000000000000000000,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 0.001,
        scientific: true
      },
      u: {
        name: "u",
        value: 0.000001,
        scientific: true
      },
      n: {
        name: "n",
        value: 0.000000001,
        scientific: true
      },
      p: {
        name: "p",
        value: 0.000000000001,
        scientific: true
      },
      f: {
        name: "f",
        value: 0.000000000000001,
        scientific: true
      },
      a: {
        name: "a",
        value: 0.000000000000000001,
        scientific: true
      },
      z: {
        name: "z",
        value: 0.000000000000000000001,
        scientific: true
      },
      y: {
        name: "y",
        value: 0.000000000000000000000001,
        scientific: true
      },
      r: {
        name: "r",
        value: 0.000000000000000000000000001,
        scientific: true
      },
      q: {
        name: "q",
        value: 0.000000000000000000000000000001,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1000,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1000000000000,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1000000000000000,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1000000000000000000,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1000000000000000000000,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1000000000000000000000000,
        scientific: true
      },
      ronna: {
        name: "ronna",
        value: 1000000000000000000000000000,
        scientific: true
      },
      quetta: {
        name: "quetta",
        value: 1000000000000000000000000000000,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 0.001,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 0.000001,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 0.000000001,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 0.000000000001,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 0.000000000000001,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 0.000000000000000001,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 0.000000000000000000001,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 0.000000000000000000000001,
        scientific: true
      },
      ronto: {
        name: "ronto",
        value: 0.000000000000000000000000001,
        scientific: true
      },
      quecto: {
        name: "quecto",
        value: 0.000000000000000000000000000001,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1000000000000,
        scientific: true
      },
      G: {
        name: "G",
        value: 1000000000000000000,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000000000000000000000000000,
        scientific: true
      },
      R: {
        name: "R",
        value: 1000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1000000000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.0001,
        scientific: false
      },
      m: {
        name: "m",
        value: 0.000001,
        scientific: true
      },
      u: {
        name: "u",
        value: 0.000000000001,
        scientific: true
      },
      n: {
        name: "n",
        value: 0.000000000000000001,
        scientific: true
      },
      p: {
        name: "p",
        value: 0.000000000000000000000001,
        scientific: true
      },
      f: {
        name: "f",
        value: 0.000000000000000000000000000001,
        scientific: true
      },
      a: {
        name: "a",
        value: 0.000000000000000000000000000000000001,
        scientific: true
      },
      z: {
        name: "z",
        value: 0.000000000000000000000000000000000000000001,
        scientific: true
      },
      y: {
        name: "y",
        value: 0.000000000000000000000000000000000000000000000001,
        scientific: true
      },
      r: {
        name: "r",
        value: 0.000000000000000000000000000000000000000000000000000001,
        scientific: true
      },
      q: {
        name: "q",
        value: 0.000000000000000000000000000000000000000000000000000000000001,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1000,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1000000000000000000,
        scientific: true
      },
      G: {
        name: "G",
        value: 1000000000000000000000000000,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000000000000000000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000000000000000000000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      R: {
        name: "R",
        value: 1000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.001,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.000001,
        scientific: false
      },
      m: {
        name: "m",
        value: 0.000000001,
        scientific: true
      },
      u: {
        name: "u",
        value: 0.000000000000000001,
        scientific: true
      },
      n: {
        name: "n",
        value: 0.000000000000000000000000001,
        scientific: true
      },
      p: {
        name: "p",
        value: 0.000000000000000000000000000000000001,
        scientific: true
      },
      f: {
        name: "f",
        value: 0.000000000000000000000000000000000000000000001,
        scientific: true
      },
      a: {
        name: "a",
        value: 0.000000000000000000000000000000000000000000000000000001,
        scientific: true
      },
      z: {
        name: "z",
        value: 0.000000000000000000000000000000000000000000000000000000000000001,
        scientific: true
      },
      y: {
        name: "y",
        value: 0.000000000000000000000000000000000000000000000000000000000000000000000001,
        scientific: true
      },
      r: {
        name: "r",
        value: 0.000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        scientific: true
      },
      q: {
        name: "q",
        value: 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1000,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1000000000000,
        scientific: true
      },
      P: {
        name: "P",
        value: 1000000000000000,
        scientific: true
      },
      E: {
        name: "E",
        value: 1000000000000000000,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1000000000000000000000,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1000000000000000000000000,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1000,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1000000000000,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1000000000000000,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1000000000000000000,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1000000000000000000000,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1000000000000000000000000,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x) => 0)
  };
  var UNITS = {
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0000000001,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0000254,
      offset: 0
    },
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.00064516,
      offset: 0
    },
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988.110336,
      offset: 0
    },
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.00000000064516,
      offset: 0
    },
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000016387064,
      offset: 0
    },
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000005,
      offset: 0
    },
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000015,
      offset: 0
    },
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00000005,
      offset: 0
    },
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00000005,
      offset: 0
    },
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000000061611519921875,
      offset: 0
    },
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000036966911953125,
      offset: 0
    },
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000295735295625,
      offset: 0
    },
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00011829411825,
      offset: 0
    },
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000001,
      offset: 0
    },
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0002365882365,
      offset: 0
    },
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000473176473,
      offset: 0
    },
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000946352946,
      offset: 0
    },
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785411784,
      offset: 0
    },
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.117347765304,
      offset: 0
    },
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.158987294928,
      offset: 0
    },
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238480942392,
      offset: 0
    },
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1000,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1000,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.00006479891,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.00006479891,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576000,
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3155760000,
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600000,
      offset: 0
    },
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      offset: 0
    },
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      offset: 0
    },
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 0
    },
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 0.00001,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 0.00001,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORTLONG,
      value: 0.0000001,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 0.0000000000000000001602176565,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 0.0000000000000000001602176565,
      offset: 0
    },
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex2.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1,
      offset: 0
    },
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fldr: "fluiddram",
    fluiddrams: "fluiddram",
    floz: "fluidounce",
    fluidounces: "fluidounce",
    gi: "gill",
    gills: "gill",
    cp: "cup",
    cups: "cup",
    pt: "pint",
    pints: "pint",
    qt: "quart",
    quarts: "quart",
    gal: "gallon",
    gallons: "gallon",
    bbl: "beerbarrel",
    beerbarrels: "beerbarrel",
    obl: "oilbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config5) {
    if (config5.number === "BigNumber") {
      var pi2 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi2.div(180);
      UNITS.grad.value = pi2.div(200);
      UNITS.cycle.value = pi2.times(2);
      UNITS.arcsec.value = pi2.div(648000);
      UNITS.arcmin.value = pi2.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648000;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config4);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit.setUnitSystem = function(name162) {
    if (hasOwnProperty(UNIT_SYSTEMS, name162)) {
      currentUnitSystem = UNIT_SYSTEMS[name162];
    } else {
      throw new Error("Unit system " + name162 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit.typeConverters = {
    BigNumber: function BigNumber(x) {
      if (x !== null && x !== undefined && x.isFraction)
        return new _BigNumber(String(x.n)).div(String(x.d)).times(String(x.s));
      return new _BigNumber(x + "");
    },
    Fraction: function Fraction(x) {
      return new _Fraction(x);
    },
    Complex: function Complex(x) {
      return x;
    },
    number: function number(x) {
      if (x !== null && x !== undefined && x.isFraction)
        return _number(x);
      return x;
    }
  };
  Unit.prototype._numberConverter = function() {
    var convert = Unit.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit._getNumberConverter = function(type) {
    if (!Unit.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty(UNITS, _key2)) {
      var unit = UNITS[_key2];
      unit.dimensions = unit.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit.isValidAlpha = function isValidAlpha(c2) {
    return /^[a-zA-Z]$/.test(c2);
  };
  function assertUnitNameIsValid(name162) {
    for (var i = 0;i < name162.length; i++) {
      c = name162.charAt(i);
      if (i === 0 && !Unit.isValidAlpha(c)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name162 + '"');
      }
      if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name162 + '"');
      }
    }
  }
  Unit.createUnit = function(obj, options) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options && options.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty(obj, _key4)) {
          Unit.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i = 0;i < obj[_key4].aliases.length; i++) {
            Unit.deleteUnit(obj[_key4].aliases[i]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty(obj, _key5)) {
        lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit.createUnitSingle = function(name162, obj) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name162 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty(UNITS, name162)) {
      throw new Error('Cannot create unit "' + name162 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name162);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name162 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i = 0;i < aliases.length; i++) {
        if (hasOwnProperty(UNITS, aliases[i])) {
          throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name162 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes && prefixes.toUpperCase) {
      prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name162 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name162 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0;_i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name162,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name162,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0;j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 0.000000000001) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name162 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit.UNITS[name162] = newUnit;
    for (var _i8 = 0;_i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit(null, name162);
  };
  Unit.deleteUnit = function(name162) {
    delete Unit.UNITS[name162];
    delete _findUnit.cache;
  };
  Unit.PREFIXES = PREFIXES;
  Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit.BASE_UNITS = BASE_UNITS;
  Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit.UNITS = UNITS;
  return Unit;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/type/unit/function/unit.js
var name162 = "unit";
var dependencies163 = ["typed", "Unit"];
var createUnitFunction = /* @__PURE__ */ factory(name162, dependencies163, (_ref) => {
  var {
    typed: typed2,
    Unit
  } = _ref;
  return typed2(name162, {
    Unit: function Unit(x) {
      return x.clone();
    },
    string: function string(x) {
      if (Unit.isValuelessUnit(x)) {
        return new Unit(null, x);
      }
      return Unit.parse(x, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function number__BigNumber__Fraction__Complex_string__Unit(value, unit) {
      return new Unit(value, unit);
    },
    "number | BigNumber | Fraction": function number__BigNumber__Fraction(value) {
      return new Unit(value);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
// node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
var name163 = "sparse";
var dependencies164 = ["typed", "SparseMatrix"];
var createSparse = /* @__PURE__ */ factory(name163, dependencies164, (_ref) => {
  var {
    typed: typed2,
    SparseMatrix
  } = _ref;
  return typed2(name163, {
    "": function _() {
      return new SparseMatrix([]);
    },
    string: function string(datatype) {
      return new SparseMatrix([], datatype);
    },
    "Array | Matrix": function Array__Matrix(data) {
      return new SparseMatrix(data);
    },
    "Array | Matrix, string": function Array__Matrix_string(data, datatype) {
      return new SparseMatrix(data, datatype);
    }
  });
});
// node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
var name164 = "createUnit";
var dependencies165 = ["typed", "Unit"];
var createCreateUnit = /* @__PURE__ */ factory(name164, dependencies165, (_ref) => {
  var {
    typed: typed2,
    Unit
  } = _ref;
  return typed2(name164, {
    "Object, Object": function Object_Object(obj, options) {
      return Unit.createUnit(obj, options);
    },
    Object: function Object(obj) {
      return Unit.createUnit(obj, {});
    },
    "string, Unit | string | Object, Object": function string_Unit__string__Object_Object(name165, def, options) {
      var obj = {};
      obj[name165] = def;
      return Unit.createUnit(obj, options);
    },
    "string, Unit | string | Object": function string_Unit__string__Object(name165, def) {
      var obj = {};
      obj[name165] = def;
      return Unit.createUnit(obj, {});
    },
    string: function string(name165) {
      var obj = {};
      obj[name165] = {};
      return Unit.createUnit(obj, {});
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/acos.js
var name165 = "acos";
var dependencies166 = ["typed", "config", "Complex"];
var createAcos = /* @__PURE__ */ factory(name165, dependencies166, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2
  } = _ref;
  return typed2(name165, {
    number: function number(x) {
      if (x >= -1 && x <= 1 || config4.predictable) {
        return Math.acos(x);
      } else {
        return new Complex2(x, 0).acos();
      }
    },
    Complex: function Complex(x) {
      return x.acos();
    },
    BigNumber: function BigNumber(x) {
      return x.acos();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
var name166 = "acosh";
var dependencies167 = ["typed", "config", "Complex"];
var createAcosh = /* @__PURE__ */ factory(name166, dependencies167, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2
  } = _ref;
  return typed2(name166, {
    number: function number(x) {
      if (x >= 1 || config4.predictable) {
        return acoshNumber(x);
      }
      if (x <= -1) {
        return new Complex2(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
      }
      return new Complex2(x, 0).acosh();
    },
    Complex: function Complex(x) {
      return x.acosh();
    },
    BigNumber: function BigNumber(x) {
      return x.acosh();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/acot.js
var name167 = "acot";
var dependencies168 = ["typed", "BigNumber"];
var createAcot = /* @__PURE__ */ factory(name167, dependencies168, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name167, {
    number: acotNumber,
    Complex: function Complex(x) {
      return x.acot();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).atan();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
var name168 = "acoth";
var dependencies169 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = /* @__PURE__ */ factory(name168, dependencies169, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name168, {
    number: function number(x) {
      if (x >= 1 || x <= -1 || config4.predictable) {
        return acothNumber(x);
      }
      return new Complex2(x, 0).acoth();
    },
    Complex: function Complex(x) {
      return x.acoth();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).atanh();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
var name169 = "acsc";
var dependencies170 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = /* @__PURE__ */ factory(name169, dependencies170, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name169, {
    number: function number(x) {
      if (x <= -1 || x >= 1 || config4.predictable) {
        return acscNumber(x);
      }
      return new Complex2(x, 0).acsc();
    },
    Complex: function Complex(x) {
      return x.acsc();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).asin();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
var name170 = "acsch";
var dependencies171 = ["typed", "BigNumber"];
var createAcsch = /* @__PURE__ */ factory(name170, dependencies171, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name170, {
    number: acschNumber,
    Complex: function Complex(x) {
      return x.acsch();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).asinh();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/asec.js
var name171 = "asec";
var dependencies172 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = /* @__PURE__ */ factory(name171, dependencies172, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name171, {
    number: function number(x) {
      if (x <= -1 || x >= 1 || config4.predictable) {
        return asecNumber(x);
      }
      return new Complex2(x, 0).asec();
    },
    Complex: function Complex(x) {
      return x.asec();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).acos();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/asech.js
var name172 = "asech";
var dependencies173 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = /* @__PURE__ */ factory(name172, dependencies173, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name172, {
    number: function number(x) {
      if (x <= 1 && x >= -1 || config4.predictable) {
        var xInv = 1 / x;
        if (xInv > 0 || config4.predictable) {
          return asechNumber(x);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex2(Math.log(ret - xInv), Math.PI);
      }
      return new Complex2(x, 0).asech();
    },
    Complex: function Complex(x) {
      return x.asech();
    },
    BigNumber: function BigNumber(x) {
      return new _BigNumber(1).div(x).acosh();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/asin.js
var name173 = "asin";
var dependencies174 = ["typed", "config", "Complex"];
var createAsin = /* @__PURE__ */ factory(name173, dependencies174, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2
  } = _ref;
  return typed2(name173, {
    number: function number(x) {
      if (x >= -1 && x <= 1 || config4.predictable) {
        return Math.asin(x);
      } else {
        return new Complex2(x, 0).asin();
      }
    },
    Complex: function Complex(x) {
      return x.asin();
    },
    BigNumber: function BigNumber(x) {
      return x.asin();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
var name174 = "asinh";
var dependencies175 = ["typed"];
var createAsinh = /* @__PURE__ */ factory(name174, dependencies175, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("asinh", {
    number: asinhNumber,
    Complex: function Complex(x) {
      return x.asinh();
    },
    BigNumber: function BigNumber(x) {
      return x.asinh();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/atan.js
var name175 = "atan";
var dependencies176 = ["typed"];
var createAtan = /* @__PURE__ */ factory(name175, dependencies176, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("atan", {
    number: function number(x) {
      return Math.atan(x);
    },
    Complex: function Complex(x) {
      return x.atan();
    },
    BigNumber: function BigNumber(x) {
      return x.atan();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
var name176 = "atan2";
var dependencies177 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
var createAtan2 = /* @__PURE__ */ factory(name176, dependencies177, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    BigNumber,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name176, {
    "number, number": Math.atan2,
    "BigNumber, BigNumber": (y, x) => BigNumber.atan2(y, x)
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
// node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
var name177 = "atanh";
var dependencies178 = ["typed", "config", "Complex"];
var createAtanh = /* @__PURE__ */ factory(name177, dependencies178, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    Complex: Complex2
  } = _ref;
  return typed2(name177, {
    number: function number(x) {
      if (x <= 1 && x >= -1 || config4.predictable) {
        return atanhNumber(x);
      }
      return new Complex2(x, 0).atanh();
    },
    Complex: function Complex(x) {
      return x.atanh();
    },
    BigNumber: function BigNumber(x) {
      return x.atanh();
    }
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    Unit: typed2.referToSelf((self2) => (x) => {
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed2.find(self2, x.valueType())(x.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/trigonometry/cos.js
var name178 = "cos";
var dependencies179 = ["typed"];
var createCos = /* @__PURE__ */ factory(name178, dependencies179, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name178, {
    number: Math.cos,
    "Complex | BigNumber": (x) => x.cos()
  }, trigUnit);
});
// node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
var name179 = "cosh";
var dependencies180 = ["typed"];
var createCosh = /* @__PURE__ */ factory(name179, dependencies180, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name179, {
    number: cosh,
    "Complex | BigNumber": (x) => x.cosh()
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/cot.js
var name180 = "cot";
var dependencies181 = ["typed", "BigNumber"];
var createCot = /* @__PURE__ */ factory(name180, dependencies181, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name180, {
    number: cotNumber,
    Complex: (x) => x.cot(),
    BigNumber: (x) => new _BigNumber(1).div(x.tan())
  }, trigUnit);
});
// node_modules/mathjs/lib/esm/function/trigonometry/coth.js
var name181 = "coth";
var dependencies182 = ["typed", "BigNumber"];
var createCoth = /* @__PURE__ */ factory(name181, dependencies182, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name181, {
    number: cothNumber,
    Complex: (x) => x.coth(),
    BigNumber: (x) => new _BigNumber(1).div(x.tanh())
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/csc.js
var name182 = "csc";
var dependencies183 = ["typed", "BigNumber"];
var createCsc = /* @__PURE__ */ factory(name182, dependencies183, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name182, {
    number: cscNumber,
    Complex: (x) => x.csc(),
    BigNumber: (x) => new _BigNumber(1).div(x.sin())
  }, trigUnit);
});
// node_modules/mathjs/lib/esm/function/trigonometry/csch.js
var name183 = "csch";
var dependencies184 = ["typed", "BigNumber"];
var createCsch = /* @__PURE__ */ factory(name183, dependencies184, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name183, {
    number: cschNumber,
    Complex: (x) => x.csch(),
    BigNumber: (x) => new _BigNumber(1).div(x.sinh())
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/sec.js
var name184 = "sec";
var dependencies185 = ["typed", "BigNumber"];
var createSec = /* @__PURE__ */ factory(name184, dependencies185, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name184, {
    number: secNumber,
    Complex: (x) => x.sec(),
    BigNumber: (x) => new _BigNumber(1).div(x.cos())
  }, trigUnit);
});
// node_modules/mathjs/lib/esm/function/trigonometry/sech.js
var name185 = "sech";
var dependencies186 = ["typed", "BigNumber"];
var createSech = /* @__PURE__ */ factory(name185, dependencies186, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name185, {
    number: sechNumber,
    Complex: (x) => x.sech(),
    BigNumber: (x) => new _BigNumber(1).div(x.cosh())
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/sin.js
var name186 = "sin";
var dependencies187 = ["typed"];
var createSin = /* @__PURE__ */ factory(name186, dependencies187, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name186, {
    number: Math.sin,
    "Complex | BigNumber": (x) => x.sin()
  }, trigUnit);
});
// node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
var name187 = "sinh";
var dependencies188 = ["typed"];
var createSinh = /* @__PURE__ */ factory(name187, dependencies188, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name187, {
    number: sinhNumber,
    "Complex | BigNumber": (x) => x.sinh()
  });
});
// node_modules/mathjs/lib/esm/function/trigonometry/tan.js
var name188 = "tan";
var dependencies189 = ["typed"];
var createTan = /* @__PURE__ */ factory(name188, dependencies189, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name188, {
    number: Math.tan,
    "Complex | BigNumber": (x) => x.tan()
  }, trigUnit);
});
// node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
var name189 = "tanh";
var dependencies190 = ["typed"];
var createTanh = /* @__PURE__ */ factory(name189, dependencies190, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("tanh", {
    number: tanh,
    "Complex | BigNumber": (x) => x.tanh()
  });
});
// node_modules/mathjs/lib/esm/function/set/setCartesian.js
var name190 = "setCartesian";
var dependencies191 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = /* @__PURE__ */ factory(name190, dependencies191, (_ref) => {
  var {
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed2(name190, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      var result = [];
      if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
        var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
        var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
        result = [];
        for (var i = 0;i < b1.length; i++) {
          for (var j = 0;j < b2.length; j++) {
            result.push([b1[i], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix(result);
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setDifference.js
var name191 = "setDifference";
var dependencies192 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = /* @__PURE__ */ factory(name191, dependencies192, (_ref) => {
  var {
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed2(name191, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      var result;
      if (subset(size(a1), new Index(0)) === 0) {
        result = [];
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1.toArray());
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        result = [];
        var inb2;
        for (var i = 0;i < b1.length; i++) {
          inb2 = false;
          for (var j = 0;j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix(generalize(result));
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setDistinct.js
var name192 = "setDistinct";
var dependencies193 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = /* @__PURE__ */ factory(name192, dependencies193, (_ref) => {
  var {
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed2(name192, {
    "Array | Matrix": function Array__Matrix(a) {
      var result;
      if (subset(size(a), new Index(0)) === 0) {
        result = [];
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
        result = [];
        result.push(b[0]);
        for (var i = 1;i < b.length; i++) {
          if (compareNatural(b[i], b[i - 1]) !== 0) {
            result.push(b[i]);
          }
        }
      }
      if (Array.isArray(a)) {
        return result;
      }
      return new DenseMatrix(result);
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setIntersect.js
var name193 = "setIntersect";
var dependencies194 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = /* @__PURE__ */ factory(name193, dependencies194, (_ref) => {
  var {
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index,
    DenseMatrix
  } = _ref;
  return typed2(name193, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      var result;
      if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        result = [];
        for (var i = 0;i < b1.length; i++) {
          for (var j = 0;j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              result.push(b1[i]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix(generalize(result));
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setIsSubset.js
var name194 = "setIsSubset";
var dependencies195 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = /* @__PURE__ */ factory(name194, dependencies195, (_ref) => {
  var {
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed2(name194, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return true;
      } else if (subset(size(a2), new Index(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
      var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
      var inb2;
      for (var i = 0;i < b1.length; i++) {
        inb2 = false;
        for (var j = 0;j < b2.length; j++) {
          if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
var name195 = "setMultiplicity";
var dependencies196 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = /* @__PURE__ */ factory(name195, dependencies196, (_ref) => {
  var {
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed2(name195, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function number__BigNumber__Fraction__Complex_Array__Matrix(e2, a) {
      if (subset(size(a), new Index(0)) === 0) {
        return 0;
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray());
      var count = 0;
      for (var i = 0;i < b.length; i++) {
        if (compareNatural(b[i], e2) === 0) {
          count++;
        }
      }
      return count;
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setPowerset.js
var name196 = "setPowerset";
var dependencies197 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = /* @__PURE__ */ factory(name196, dependencies197, (_ref) => {
  var {
    typed: typed2,
    size,
    subset,
    compareNatural,
    Index
  } = _ref;
  return typed2(name196, {
    "Array | Matrix": function Array__Matrix(a) {
      if (subset(size(a), new Index(0)) === 0) {
        return [];
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
      var result = [];
      var number = 0;
      while (number.toString(2).length <= b.length) {
        result.push(_subset(b, number.toString(2).split("").reverse()));
        number++;
      }
      return _sort(result);
    }
  });
  function _subset(array, bitarray) {
    var result = [];
    for (var i = 0;i < bitarray.length; i++) {
      if (bitarray[i] === "1") {
        result.push(array[i]);
      }
    }
    return result;
  }
  function _sort(array) {
    var temp = [];
    for (var i = array.length - 1;i > 0; i--) {
      for (var j = 0;j < i; j++) {
        if (array[j].length > array[j + 1].length) {
          temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
    return array;
  }
});
// node_modules/mathjs/lib/esm/function/set/setSize.js
var name197 = "setSize";
var dependencies198 = ["typed", "compareNatural"];
var createSetSize = /* @__PURE__ */ factory(name197, dependencies198, (_ref) => {
  var {
    typed: typed2,
    compareNatural
  } = _ref;
  return typed2(name197, {
    "Array | Matrix": function Array__Matrix(a) {
      return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
    },
    "Array | Matrix, boolean": function Array__Matrix_boolean(a, unique) {
      if (unique === false || a.length === 0) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
        var count = 1;
        for (var i = 1;i < b.length; i++) {
          if (compareNatural(b[i], b[i - 1]) !== 0) {
            count++;
          }
        }
        return count;
      }
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setSymDifference.js
var name198 = "setSymDifference";
var dependencies199 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = /* @__PURE__ */ factory(name198, dependencies199, (_ref) => {
  var {
    typed: typed2,
    size,
    concat: concat2,
    subset,
    setDifference,
    Index
  } = _ref;
  return typed2(name198, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return flatten(a2);
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat2(setDifference(b1, b2), setDifference(b2, b1));
    }
  });
});
// node_modules/mathjs/lib/esm/function/set/setUnion.js
var name199 = "setUnion";
var dependencies200 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = /* @__PURE__ */ factory(name199, dependencies200, (_ref) => {
  var {
    typed: typed2,
    size,
    concat: concat2,
    subset,
    setIntersect,
    setSymDifference,
    Index
  } = _ref;
  return typed2(name199, {
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(a1, a2) {
      if (subset(size(a1), new Index(0)) === 0) {
        return flatten(a2);
      } else if (subset(size(a2), new Index(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat2(setSymDifference(b1, b2), setIntersect(b1, b2));
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/add.js
var name200 = "add";
var dependencies201 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
var createAdd = /* @__PURE__ */ factory(name200, dependencies201, (_ref) => {
  var {
    typed: typed2,
    matrix,
    addScalar,
    equalScalar,
    DenseMatrix,
    SparseMatrix,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix,
    concat: concat2
  });
  return typed2(name200, {
    "any, any": addScalar,
    "any, any, ...any": typed2.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i = 0;i < rest.length; i++) {
        result = self2(result, rest[i]);
      }
      return result;
    })
  }, matrixAlgorithmSuite({
    elop: addScalar,
    DS: matAlgo01xDSid,
    SS: matAlgo04xSidSid,
    Ss: matAlgo10xSids
  }));
});
// node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
var name201 = "hypot";
var dependencies202 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
var createHypot = /* @__PURE__ */ factory(name201, dependencies202, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    addScalar,
    divideScalar,
    multiplyScalar,
    sqrt: sqrt2,
    smaller,
    isPositive
  } = _ref;
  return typed2(name201, {
    "... number | BigNumber": _hypot,
    Array: _hypot,
    Matrix: (M) => _hypot(flatten(M.toArray()))
  });
  function _hypot(args) {
    var result = 0;
    var largest = 0;
    for (var i = 0;i < args.length; i++) {
      if (isComplex(args[i])) {
        throw new TypeError("Unexpected type of argument to hypot");
      }
      var value = abs2(args[i]);
      if (smaller(largest, value)) {
        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
        result = addScalar(result, 1);
        largest = value;
      } else {
        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
      }
    }
    return multiplyScalar(largest, sqrt2(result));
  }
});
// node_modules/mathjs/lib/esm/function/arithmetic/norm.js
var name202 = "norm";
var dependencies203 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = /* @__PURE__ */ factory(name202, dependencies203, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    pow: pow2,
    conj,
    sqrt: sqrt2,
    multiply,
    equalScalar,
    larger,
    smaller,
    matrix,
    ctranspose,
    eigs
  } = _ref;
  return typed2(name202, {
    number: Math.abs,
    Complex: function Complex(x) {
      return x.abs();
    },
    BigNumber: function BigNumber(x) {
      return x.abs();
    },
    boolean: function boolean(x) {
      return Math.abs(x);
    },
    Array: function Array(x) {
      return _norm(matrix(x), 2);
    },
    Matrix: function Matrix(x) {
      return _norm(x, 2);
    },
    "Array, number | BigNumber | string": function Array_number__BigNumber__string(x, p) {
      return _norm(matrix(x), p);
    },
    "Matrix, number | BigNumber | string": function Matrix_number__BigNumber__string(x, p) {
      return _norm(x, p);
    }
  });
  function _vectorNormPlusInfinity(x) {
    var pinf = 0;
    x.forEach(function(value) {
      var v = abs2(value);
      if (larger(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x) {
    var ninf;
    x.forEach(function(value) {
      var v = abs2(value);
      if (!ninf || smaller(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x, p) {
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _vectorNormPlusInfinity(x);
    }
    if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
      return _vectorNormMinusInfinity(x);
    }
    if (p === "fro") {
      return _norm(x, 2);
    }
    if (typeof p === "number" && !isNaN(p)) {
      if (!equalScalar(p, 0)) {
        var n = 0;
        x.forEach(function(value) {
          n = add2(pow2(abs2(value), p), n);
        }, true);
        return pow2(n, 1 / p);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x) {
    var fro = 0;
    x.forEach(function(value, index) {
      fro = add2(fro, multiply(value, conj(value)));
    });
    return abs2(sqrt2(fro));
  }
  function _matrixNormOne(x) {
    var c = [];
    var maxc = 0;
    x.forEach(function(value, index) {
      var j = index[1];
      var cj = add2(c[j] || 0, abs2(value));
      if (larger(cj, maxc)) {
        maxc = cj;
      }
      c[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x) {
    var sizeX = x.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose(x);
    var squaredX = multiply(tx, x);
    var eigenVals = eigs(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs2(sqrt2(rho));
  }
  function _matrixNormInfinity(x) {
    var r = [];
    var maxr = 0;
    x.forEach(function(value, index) {
      var i = index[0];
      var ri = add2(r[i] || 0, abs2(value));
      if (larger(ri, maxr)) {
        maxr = ri;
      }
      r[i] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x, p) {
    if (p === 1) {
      return _matrixNormOne(x);
    }
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _matrixNormInfinity(x);
    }
    if (p === "fro") {
      return _matrixNormFrobenius(x);
    }
    if (p === 2) {
      return _matrixNormTwo(x);
    }
    throw new Error("Unsupported parameter value " + p);
  }
  function _norm(x, p) {
    var sizeX = x.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x, p);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x, p);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/dot.js
var name203 = "dot";
var dependencies204 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = /* @__PURE__ */ factory(name203, dependencies204, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    multiplyScalar,
    conj,
    size
  } = _ref;
  return typed2(name203, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype || a.getDataType() : undefined;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype || b.getDataType() : undefined;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add2 = addScalar;
    var mul2 = multiplyScalar;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      var dt = adt;
      add2 = typed2.find(addScalar, [dt, dt]);
      mul2 = typed2.find(multiplyScalar, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c = mul2(conj(adata[0]), bdata[0]);
      for (var i = 1;i < N; i++) {
        c = add2(c, mul2(conj(adata[i]), bdata[i]));
      }
      return c;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul2(conj(adata[0]), bdata[0][0]);
      for (var _i = 1;_i < N; _i++) {
        _c = add2(_c, mul2(conj(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul2(conj(adata[0][0]), bdata[0]);
      for (var _i2 = 1;_i2 < N; _i2++) {
        _c2 = add2(_c2, mul2(conj(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul2(conj(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1;_i3 < N; _i3++) {
        _c3 = add2(_c3, mul2(conj(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c = 0;
    var add2 = addScalar;
    var mul2 = multiplyScalar;
    var i = 0;
    var j = 0;
    while (i < xindex.length && j < yindex.length) {
      var I = xindex[i];
      var J = yindex[j];
      if (I < J) {
        i++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c = add2(c, mul2(xvalues[i], yvalues[j]));
        i++;
        j++;
      }
    }
    return c;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size(x);
  }
});
// node_modules/mathjs/lib/esm/function/matrix/trace.js
var name204 = "trace";
var dependencies205 = ["typed", "matrix", "add"];
var createTrace = /* @__PURE__ */ factory(name204, dependencies205, (_ref) => {
  var {
    typed: typed2,
    matrix,
    add: add2
  } = _ref;
  return typed2("trace", {
    Array: function _arrayTrace(x) {
      return _denseTrace(matrix(x));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone
  });
  function _denseTrace(m) {
    var size = m._size;
    var data = m._data;
    switch (size.length) {
      case 1:
        if (size[0] === 1) {
          return clone(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
      case 2: {
        var rows = size[0];
        var cols = size[1];
        if (rows === cols) {
          var sum2 = 0;
          for (var i = 0;i < rows; i++) {
            sum2 = add2(sum2, data[i][i]);
          }
          return sum2;
        } else {
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
    }
  }
  function _sparseTrace(m) {
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var size = m._size;
    var rows = size[0];
    var columns = size[1];
    if (rows === columns) {
      var sum2 = 0;
      if (values.length > 0) {
        for (var j = 0;j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0;k < k1; k++) {
            var i = index[k];
            if (i === j) {
              sum2 = add2(sum2, values[k]);
              break;
            }
            if (i > j) {
              break;
            }
          }
        }
      }
      return sum2;
    }
    throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
  }
});
// node_modules/mathjs/lib/esm/type/matrix/function/index.js
var name205 = "index";
var dependencies206 = ["typed", "Index"];
var createIndex = /* @__PURE__ */ factory(name205, dependencies206, (_ref) => {
  var {
    typed: typed2,
    Index
  } = _ref;
  return typed2(name205, {
    "...number | string | BigNumber | Range | Array | Matrix": function number__string__BigNumber__Range__Array__Matrix(args) {
      var ranges = args.map(function(arg) {
        if (isBigNumber(arg)) {
          return arg.toNumber();
        } else if (isArray(arg) || isMatrix(arg)) {
          return arg.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg;
        }
      });
      var res = new Index;
      Index.apply(res, ranges);
      return res;
    }
  });
});
// node_modules/mathjs/lib/esm/expression/keywords.js
var keywords = new Set(["end"]);

// node_modules/mathjs/lib/esm/expression/node/Node.js
var name206 = "Node";
var dependencies207 = ["mathWithTransform"];
var createNode = /* @__PURE__ */ factory(name206, dependencies207, (_ref) => {
  var {
    mathWithTransform
  } = _ref;
  function _validateScope(scope) {
    for (var symbol of [...keywords]) {
      if (scope.has(symbol)) {
        throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
      }
    }
  }

  class Node {
    get type() {
      return "Node";
    }
    get isNode() {
      return true;
    }
    evaluate(scope) {
      return this.compile().evaluate(scope);
    }
    compile() {
      var expr = this._compile(mathWithTransform, {});
      var args = {};
      var context = null;
      function evaluate(scope) {
        var s = createMap(scope);
        _validateScope(s);
        return expr(s, args, context);
      }
      return {
        evaluate
      };
    }
    _compile(math, argNames) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    forEach(callback) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    map(callback) {
      throw new Error("Cannot run map on a Node interface");
    }
    _ifNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Callback function must return a Node");
      }
      return node;
    }
    traverse(callback) {
      callback(this, null, null);
      function _traverse(node, callback2) {
        node.forEach(function(child, path, parent) {
          callback2(child, path, parent);
          _traverse(child, callback2);
        });
      }
      _traverse(this, callback);
    }
    transform(callback) {
      function _transform(child, path, parent) {
        var replacement = callback(child, path, parent);
        if (replacement !== child) {
          return replacement;
        }
        return child.map(_transform);
      }
      return _transform(this, null, null);
    }
    filter(callback) {
      var nodes = [];
      this.traverse(function(node, path, parent) {
        if (callback(node, path, parent)) {
          nodes.push(node);
        }
      });
      return nodes;
    }
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    cloneDeep() {
      return this.map(function(node) {
        return node.cloneDeep();
      });
    }
    equals(other) {
      return other ? this.type === other.type && deepStrictEqual(this, other) : false;
    }
    toString(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toString(options);
    }
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    toHTML(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toHTML(options);
    }
    _toHTML() {
      throw new Error("_toHTML not implemented for " + this.type);
    }
    toTex(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toTex(options);
    }
    _toTex(options) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    _getCustomString(options) {
      if (options && typeof options === "object") {
        switch (typeof options.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return options.handler(this, options);
          default:
            throw new TypeError("Object or function expected as callback");
        }
      }
    }
    getIdentifier() {
      return this.type;
    }
    getContent() {
      return this;
    }
  }
  return Node;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
function errorTransform(err) {
  if (err && err.isIndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max !== undefined ? err.max + 1 : undefined);
  }
  return err;
}

// node_modules/mathjs/lib/esm/expression/node/utils/access.js
function accessFactory(_ref) {
  var {
    subset
  } = _ref;
  return function access(object, index) {
    try {
      if (Array.isArray(object)) {
        return subset(object, index);
      } else if (object && typeof object.subset === "function") {
        return object.subset(index);
      } else if (typeof object === "string") {
        return subset(object, index);
      } else if (typeof object === "object") {
        if (!index.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object, index.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
var name207 = "AccessorNode";
var dependencies208 = ["subset", "Node"];
var createAccessorNode = /* @__PURE__ */ factory(name207, dependencies208, (_ref) => {
  var {
    subset,
    Node
  } = _ref;
  var access = accessFactory({
    subset
  });
  function needParenthesis(node) {
    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
  }

  class AccessorNode extends Node {
    constructor(object, index) {
      super();
      if (!isNode(object)) {
        throw new TypeError('Node expected for parameter "object"');
      }
      if (!isIndexNode(index)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }
      this.object = object;
      this.index = index;
    }
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name207;
    }
    get isAccessorNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalObject = this.object._compile(math, argNames);
      var evalIndex = this.index._compile(math, argNames);
      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context) {
          return getSafeProperty(evalObject(scope, args, context), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var index = evalIndex(scope, args, object);
          return access(object, index);
        };
      }
    }
    forEach(callback) {
      callback(this.object, "object", this);
      callback(this.index, "index", this);
    }
    map(callback) {
      return new AccessorNode(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
    }
    clone() {
      return new AccessorNode(this.object, this.index);
    }
    _toString(options) {
      var object = this.object.toString(options);
      if (needParenthesis(this.object)) {
        object = "(" + object + ")";
      }
      return object + this.index.toString(options);
    }
    _toHTML(options) {
      var object = this.object.toHTML(options);
      if (needParenthesis(this.object)) {
        object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return object + this.index.toHTML(options);
    }
    _toTex(options) {
      var object = this.object.toTex(options);
      if (needParenthesis(this.object)) {
        object = "\\left(' + object + '\\right)";
      }
      return object + this.index.toTex(options);
    }
    toJSON() {
      return {
        mathjs: name207,
        object: this.object,
        index: this.index
      };
    }
    static fromJSON(json) {
      return new AccessorNode(json.object, json.index);
    }
  }
  _defineProperty(AccessorNode, "name", name207);
  return AccessorNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
var name208 = "ArrayNode";
var dependencies209 = ["Node"];
var createArrayNode = /* @__PURE__ */ factory(name208, dependencies209, (_ref) => {
  var {
    Node
  } = _ref;

  class ArrayNode extends Node {
    constructor(items) {
      super();
      this.items = items || [];
      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError("Array containing Nodes expected");
      }
    }
    get type() {
      return name208;
    }
    get isArrayNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalItems = map(this.items, function(item) {
        return item._compile(math, argNames);
      });
      var asMatrix = math.config.matrix !== "Array";
      if (asMatrix) {
        var matrix = math.matrix;
        return function evalArrayNode(scope, args, context) {
          return matrix(map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context) {
          return map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          });
        };
      }
    }
    forEach(callback) {
      for (var i = 0;i < this.items.length; i++) {
        var node = this.items[i];
        callback(node, "items[" + i + "]", this);
      }
    }
    map(callback) {
      var items = [];
      for (var i = 0;i < this.items.length; i++) {
        items[i] = this._ifNode(callback(this.items[i], "items[" + i + "]", this));
      }
      return new ArrayNode(items);
    }
    clone() {
      return new ArrayNode(this.items.slice(0));
    }
    _toString(options) {
      var items = this.items.map(function(node) {
        return node.toString(options);
      });
      return "[" + items.join(", ") + "]";
    }
    toJSON() {
      return {
        mathjs: name208,
        items: this.items
      };
    }
    static fromJSON(json) {
      return new ArrayNode(json.items);
    }
    _toHTML(options) {
      var items = this.items.map(function(node) {
        return node.toHTML(options);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    _toTex(options) {
      function itemsToTex(items, nested) {
        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
        var itemsFormRow = nested || mixedItems;
        var itemSep = itemsFormRow ? "&" : "\\\\";
        var itemsTex = items.map(function(node) {
          if (node.items) {
            return itemsToTex(node.items, !nested);
          } else {
            return node.toTex(options);
          }
        }).join(itemSep);
        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
      }
      return itemsToTex(this.items, false);
    }
  }
  _defineProperty(ArrayNode, "name", name208);
  return ArrayNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/utils/assign.js
function assignFactory(_ref) {
  var {
    subset,
    matrix
  } = _ref;
  return function assign(object, index, value) {
    try {
      if (Array.isArray(object)) {
        var result = matrix(object).subset(index, value).valueOf();
        result.forEach((item, index2) => {
          object[index2] = item;
        });
        return object;
      } else if (object && typeof object.subset === "function") {
        return object.subset(index, value);
      } else if (typeof object === "string") {
        return subset(object, index, value);
      } else if (typeof object === "object") {
        if (!index.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object, index.getObjectProperty(), value);
        return object;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// node_modules/mathjs/lib/esm/expression/operators.js
var properties = [{
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  ConditionalNode: {
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
  }
}, {
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  RangeNode: {}
}, {
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: false
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];
function unwrapParen(_node, parenthesis) {
  if (!parenthesis || parenthesis !== "auto")
    return _node;
  var node = _node;
  while (isParenthesisNode(node))
    node = node.content;
  return node;
}
function getPrecedence(_node, parenthesis, implicit, parent) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var precedence = null;
  for (var i = 0;i < properties.length; i++) {
    if (identifier in properties[i]) {
      precedence = i;
      break;
    }
  }
  if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
    var leftArg = unwrapParen(node.args[0], parenthesis);
    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
      precedence += 1;
    }
  }
  return precedence;
}
function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index = getPrecedence(node, parenthesis);
  if (index === null) {
    return null;
  }
  var property = properties[index][identifier];
  if (hasOwnProperty(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index = getPrecedence(a, parenthesis);
  if (index === null) {
    return null;
  }
  var property = properties[index][identifierA];
  if (hasOwnProperty(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (var i = 0;i < property.associativeWith.length; i++) {
      if (property.associativeWith[i] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
function getOperator(fn) {
  var identifier = "OperatorNode:" + fn;
  for (var group of properties) {
    if (identifier in group) {
      return group[identifier].op;
    }
  }
  return null;
}

// node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
var name209 = "AssignmentNode";
var dependencies210 = [
  "subset",
  "?matrix",
  "Node"
];
var createAssignmentNode = /* @__PURE__ */ factory(name209, dependencies210, (_ref) => {
  var {
    subset,
    matrix,
    Node
  } = _ref;
  var access = accessFactory({
    subset
  });
  var assign2 = assignFactory({
    subset,
    matrix
  });
  function needParenthesis(node, parenthesis, implicit) {
    if (!parenthesis) {
      parenthesis = "keep";
    }
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }

  class AssignmentNode extends Node {
    constructor(object, index, value) {
      super();
      this.object = object;
      this.index = value ? index : null;
      this.value = value || index;
      if (!isSymbolNode(object) && !isAccessorNode(object)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }
      if (isSymbolNode(object) && object.name === "end") {
        throw new Error('Cannot assign to symbol "end"');
      }
      if (this.index && !isIndexNode(this.index)) {
        throw new TypeError('IndexNode expected as "index"');
      }
      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      }
    }
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name209;
    }
    get isAssignmentNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalObject = this.object._compile(math, argNames);
      var evalIndex = this.index ? this.index._compile(math, argNames) : null;
      var evalValue = this.value._compile(math, argNames);
      var name210 = this.object.name;
      if (!this.index) {
        if (!isSymbolNode(this.object)) {
          throw new TypeError("SymbolNode expected as object");
        }
        return function evalAssignmentNode(scope, args, context) {
          var value = evalValue(scope, args, context);
          scope.set(name210, value);
          return value;
        };
      } else if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          setSafeProperty(object, prop, value);
          return value;
        };
      } else if (isSymbolNode(this.object)) {
        return function evalAssignmentNode(scope, args, context) {
          var childObject = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          var index = evalIndex(scope, args, childObject);
          scope.set(name210, assign2(childObject, index, value));
          return value;
        };
      } else {
        var evalParentObject = this.object.object._compile(math, argNames);
        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var childObject = getSafeProperty(parent, parentProp);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            setSafeProperty(parent, parentProp, assign2(childObject, index, value));
            return value;
          };
        } else {
          var evalParentIndex = this.object.index._compile(math, argNames);
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var parentIndex = evalParentIndex(scope, args, parent);
            var childObject = access(parent, parentIndex);
            var index = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            assign2(parent, parentIndex, assign2(childObject, index, value));
            return value;
          };
        }
      }
    }
    forEach(callback) {
      callback(this.object, "object", this);
      if (this.index) {
        callback(this.index, "index", this);
      }
      callback(this.value, "value", this);
    }
    map(callback) {
      var object = this._ifNode(callback(this.object, "object", this));
      var index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
      var value = this._ifNode(callback(this.value, "value", this));
      return new AssignmentNode(object, index, value);
    }
    clone() {
      return new AssignmentNode(this.object, this.index, this.value);
    }
    _toString(options) {
      var object = this.object.toString(options);
      var index = this.index ? this.index.toString(options) : "";
      var value = this.value.toString(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "(" + value + ")";
      }
      return object + index + " = " + value;
    }
    toJSON() {
      return {
        mathjs: name209,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    static fromJSON(json) {
      return new AssignmentNode(json.object, json.index, json.value);
    }
    _toHTML(options) {
      var object = this.object.toHTML(options);
      var index = this.index ? this.index.toHTML(options) : "";
      var value = this.value.toHTML(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      return object + index + '<span class="math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator">=</span>' + value;
    }
    _toTex(options) {
      var object = this.object.toTex(options);
      var index = this.index ? this.index.toTex(options) : "";
      var value = this.value.toTex(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "\\left(".concat(value, "\\right)");
      }
      return object + index + "=" + value;
    }
  }
  _defineProperty(AssignmentNode, "name", name209);
  return AssignmentNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/BlockNode.js
var name210 = "BlockNode";
var dependencies211 = ["ResultSet", "Node"];
var createBlockNode = /* @__PURE__ */ factory(name210, dependencies211, (_ref) => {
  var {
    ResultSet,
    Node
  } = _ref;

  class BlockNode extends Node {
    constructor(blocks) {
      super();
      if (!Array.isArray(blocks))
        throw new Error("Array expected");
      this.blocks = blocks.map(function(block) {
        var node = block && block.node;
        var visible = block && block.visible !== undefined ? block.visible : true;
        if (!isNode(node))
          throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== "boolean") {
          throw new TypeError('Property "visible" must be a boolean');
        }
        return {
          node,
          visible
        };
      });
    }
    get type() {
      return name210;
    }
    get isBlockNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalBlocks = map(this.blocks, function(block) {
        return {
          evaluate: block.node._compile(math, argNames),
          visible: block.visible
        };
      });
      return function evalBlockNodes(scope, args, context) {
        var results = [];
        forEach(evalBlocks, function evalBlockNode(block) {
          var result = block.evaluate(scope, args, context);
          if (block.visible) {
            results.push(result);
          }
        });
        return new ResultSet(results);
      };
    }
    forEach(callback) {
      for (var i = 0;i < this.blocks.length; i++) {
        callback(this.blocks[i].node, "blocks[" + i + "].node", this);
      }
    }
    map(callback) {
      var blocks = [];
      for (var i = 0;i < this.blocks.length; i++) {
        var block = this.blocks[i];
        var node = this._ifNode(callback(block.node, "blocks[" + i + "].node", this));
        blocks[i] = {
          node,
          visible: block.visible
        };
      }
      return new BlockNode(blocks);
    }
    clone() {
      var blocks = this.blocks.map(function(block) {
        return {
          node: block.node,
          visible: block.visible
        };
      });
      return new BlockNode(blocks);
    }
    _toString(options) {
      return this.blocks.map(function(param) {
        return param.node.toString(options) + (param.visible ? "" : ";");
      }).join(`
`);
    }
    toJSON() {
      return {
        mathjs: name210,
        blocks: this.blocks
      };
    }
    static fromJSON(json) {
      return new BlockNode(json.blocks);
    }
    _toHTML(options) {
      return this.blocks.map(function(param) {
        return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    _toTex(options) {
      return this.blocks.map(function(param) {
        return param.node.toTex(options) + (param.visible ? "" : ";");
      }).join(`\\;\\;
`);
    }
  }
  _defineProperty(BlockNode, "name", name210);
  return BlockNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
var name211 = "ConditionalNode";
var dependencies212 = ["Node"];
var createConditionalNode = /* @__PURE__ */ factory(name211, dependencies212, (_ref) => {
  var {
    Node
  } = _ref;
  function testCondition(condition) {
    if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
      return !!condition;
    }
    if (condition) {
      if (isBigNumber(condition)) {
        return !condition.isZero();
      }
      if (isComplex(condition)) {
        return !!(condition.re || condition.im);
      }
      if (isUnit(condition)) {
        return !!condition.value;
      }
    }
    if (condition === null || condition === undefined) {
      return false;
    }
    throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
  }

  class ConditionalNode extends Node {
    constructor(condition, trueExpr, falseExpr) {
      super();
      if (!isNode(condition)) {
        throw new TypeError("Parameter condition must be a Node");
      }
      if (!isNode(trueExpr)) {
        throw new TypeError("Parameter trueExpr must be a Node");
      }
      if (!isNode(falseExpr)) {
        throw new TypeError("Parameter falseExpr must be a Node");
      }
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }
    get type() {
      return name211;
    }
    get isConditionalNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalCondition = this.condition._compile(math, argNames);
      var evalTrueExpr = this.trueExpr._compile(math, argNames);
      var evalFalseExpr = this.falseExpr._compile(math, argNames);
      return function evalConditionalNode(scope, args, context) {
        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
      };
    }
    forEach(callback) {
      callback(this.condition, "condition", this);
      callback(this.trueExpr, "trueExpr", this);
      callback(this.falseExpr, "falseExpr", this);
    }
    map(callback) {
      return new ConditionalNode(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
    }
    clone() {
      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toString(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = "(" + condition + ")";
      }
      var trueExpr = this.trueExpr.toString(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = "(" + trueExpr + ")";
      }
      var falseExpr = this.falseExpr.toString(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = "(" + falseExpr + ")";
      }
      return condition + " ? " + trueExpr + " : " + falseExpr;
    }
    toJSON() {
      return {
        mathjs: name211,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    static fromJSON(json) {
      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
    }
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toHTML(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var trueExpr = this.trueExpr.toHTML(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var falseExpr = this.falseExpr.toHTML(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    }
    _toTex(options) {
      return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  _defineProperty(ConditionalNode, "name", name211);
  return ConditionalNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/utils/latex.js
var import_escape_latex = __toESM(require_dist(), 1);
var latexSymbols = {
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  i: "i",
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
};
var latexOperators = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  dotMultiply: ".\\cdot",
  dotDivide: ".:",
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
};
var latexFunctions = {
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: undefined
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: undefined
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
  },
  bitAnd: {
    2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
  },
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  and: {
    2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
  },
  not: {
    1: latexOperators.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
  },
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
  },
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  equal: {
    2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
  },
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  to: {
    2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
  },
  numeric: function numeric(node, options) {
    return node.args[0].toTex();
  },
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  bigint: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
};
var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
var latexUnits = {
  deg: "^\\circ"
};
function escapeLatex(string) {
  return import_escape_latex.default(string, {
    preserveFormatting: true
  });
}
function toSymbol(name212, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty(latexUnits, name212)) {
      return latexUnits[name212];
    }
    return "\\mathrm{" + escapeLatex(name212) + "}";
  }
  if (hasOwnProperty(latexSymbols, name212)) {
    return latexSymbols[name212];
  }
  return escapeLatex(name212);
}

// node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
var name212 = "ConstantNode";
var dependencies213 = ["Node"];
var createConstantNode = /* @__PURE__ */ factory(name212, dependencies213, (_ref) => {
  var {
    Node
  } = _ref;

  class ConstantNode extends Node {
    constructor(value) {
      super();
      this.value = value;
    }
    get type() {
      return name212;
    }
    get isConstantNode() {
      return true;
    }
    _compile(math, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    }
    forEach(callback) {
    }
    map(callback) {
      return this.clone();
    }
    clone() {
      return new ConstantNode(this.value);
    }
    _toString(options) {
      return format3(this.value, options);
    }
    _toHTML(options) {
      var value = this._toString(options);
      switch (typeOf(this.value)) {
        case "number":
        case "bigint":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + value + "</span>";
        case "string":
          return '<span class="math-string">' + value + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + value + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + value + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + value + "</span>";
        default:
          return '<span class="math-symbol">' + value + "</span>";
      }
    }
    toJSON() {
      return {
        mathjs: name212,
        value: this.value
      };
    }
    static fromJSON(json) {
      return new ConstantNode(json.value);
    }
    _toTex(options) {
      var value = this._toString(options);
      var type = typeOf(this.value);
      switch (type) {
        case "string":
          return "\\mathtt{" + escapeLatex(value) + "}";
        case "number":
        case "BigNumber": {
          var finite = type === "BigNumber" ? this.value.isFinite() : isFinite(this.value);
          if (!finite) {
            return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
          }
          var index = value.toLowerCase().indexOf("e");
          if (index !== -1) {
            return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
          }
          return value;
        }
        case "bigint": {
          return value.toString();
        }
        case "Fraction":
          return this.value.toLatex();
        default:
          return value;
      }
    }
  }
  _defineProperty(ConstantNode, "name", name212);
  return ConstantNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
var name213 = "FunctionAssignmentNode";
var dependencies214 = ["typed", "Node"];
var createFunctionAssignmentNode = /* @__PURE__ */ factory(name213, dependencies214, (_ref) => {
  var {
    typed: typed2,
    Node
  } = _ref;
  function needParenthesis(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }

  class FunctionAssignmentNode extends Node {
    constructor(name214, params, expr) {
      super();
      if (typeof name214 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      if (!Array.isArray(params)) {
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      }
      if (!isNode(expr)) {
        throw new TypeError('Node expected for parameter "expr"');
      }
      if (keywords.has(name214)) {
        throw new Error('Illegal function name, "' + name214 + '" is a reserved keyword');
      }
      var paramNames = new Set;
      for (var param of params) {
        var _name = typeof param === "string" ? param : param.name;
        if (paramNames.has(_name)) {
          throw new Error('Duplicate parameter name "'.concat(_name, '"'));
        } else {
          paramNames.add(_name);
        }
      }
      this.name = name214;
      this.params = params.map(function(param2) {
        return param2 && param2.name || param2;
      });
      this.types = params.map(function(param2) {
        return param2 && param2.type || "any";
      });
      this.expr = expr;
    }
    get type() {
      return name213;
    }
    get isFunctionAssignmentNode() {
      return true;
    }
    _compile(math, argNames) {
      var childArgNames = Object.create(argNames);
      forEach(this.params, function(param) {
        childArgNames[param] = true;
      });
      var evalExpr = this.expr._compile(math, childArgNames);
      var name214 = this.name;
      var params = this.params;
      var signature = join(this.types, ",");
      var syntax = name214 + "(" + join(this.params, ", ") + ")";
      return function evalFunctionAssignmentNode(scope, args, context) {
        var signatures = {};
        signatures[signature] = function() {
          var childArgs = Object.create(args);
          for (var i = 0;i < params.length; i++) {
            childArgs[params[i]] = arguments[i];
          }
          return evalExpr(scope, childArgs, context);
        };
        var fn = typed2(name214, signatures);
        fn.syntax = syntax;
        scope.set(name214, fn);
        return fn;
      };
    }
    forEach(callback) {
      callback(this.expr, "expr", this);
    }
    map(callback) {
      var expr = this._ifNode(callback(this.expr, "expr", this));
      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
    }
    clone() {
      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toString(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "(" + expr + ")";
      }
      return this.name + "(" + this.params.join(", ") + ") = " + expr;
    }
    toJSON() {
      var types = this.types;
      return {
        mathjs: name213,
        name: this.name,
        params: this.params.map(function(param, index) {
          return {
            name: param,
            type: types[index]
          };
        }),
        expr: this.expr
      };
    }
    static fromJSON(json) {
      return new FunctionAssignmentNode(json.name, json.params, json.expr);
    }
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var params = [];
      for (var i = 0;i < this.params.length; i++) {
        params.push('<span class="math-symbol math-parameter">' + escape(this.params[i]) + "</span>");
      }
      var expr = this.expr.toHTML(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return '<span class="math-function">' + escape(this.name) + "</span>" + '<span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span>' + '<span class="math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toTex(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "\\left(".concat(expr, "\\right)");
      }
      return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right)=" + expr;
    }
  }
  _defineProperty(FunctionAssignmentNode, "name", name213);
  return FunctionAssignmentNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/IndexNode.js
var name214 = "IndexNode";
var dependencies215 = ["Node", "size"];
var createIndexNode = /* @__PURE__ */ factory(name214, dependencies215, (_ref) => {
  var {
    Node,
    size
  } = _ref;

  class IndexNode extends Node {
    constructor(dimensions, dotNotation) {
      super();
      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false;
      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }
      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error("dotNotation only applicable for object properties");
      }
    }
    get type() {
      return name214;
    }
    get isIndexNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalDimensions = map(this.dimensions, function(dimension, i) {
        var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
        if (needsEnd) {
          var childArgNames = Object.create(argNames);
          childArgNames.end = true;
          var _evalDimension = dimension._compile(math, childArgNames);
          return function evalDimension(scope, args, context) {
            if (!isMatrix(context) && !isArray(context) && !isString(context)) {
              throw new TypeError('Cannot resolve "end": ' + "context must be a Matrix, Array, or string but is " + typeOf(context));
            }
            var s = size(context).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s[i];
            return _evalDimension(scope, childArgs, context);
          };
        } else {
          return dimension._compile(math, argNames);
        }
      });
      var index = getSafeProperty(math, "index");
      return function evalIndexNode(scope, args, context) {
        var dimensions = map(evalDimensions, function(evalDimension) {
          return evalDimension(scope, args, context);
        });
        return index(...dimensions);
      };
    }
    forEach(callback) {
      for (var i = 0;i < this.dimensions.length; i++) {
        callback(this.dimensions[i], "dimensions[" + i + "]", this);
      }
    }
    map(callback) {
      var dimensions = [];
      for (var i = 0;i < this.dimensions.length; i++) {
        dimensions[i] = this._ifNode(callback(this.dimensions[i], "dimensions[" + i + "]", this));
      }
      return new IndexNode(dimensions, this.dotNotation);
    }
    clone() {
      return new IndexNode(this.dimensions.slice(0), this.dotNotation);
    }
    isObjectProperty() {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
    }
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    _toString(options) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    toJSON() {
      return {
        mathjs: name214,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    static fromJSON(json) {
      return new IndexNode(json.dimensions, json.dotNotation);
    }
    _toHTML(options) {
      var dimensions = [];
      for (var i = 0;i < this.dimensions.length; i++) {
        dimensions[i] = this.dimensions[i].toHTML();
      }
      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span>' + '<span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    }
    _toTex(options) {
      var dimensions = this.dimensions.map(function(range) {
        return range.toTex(options);
      });
      return this.dotNotation ? "." + this.getObjectProperty() + "" : "_{" + dimensions.join(",") + "}";
    }
  }
  _defineProperty(IndexNode, "name", name214);
  return IndexNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
var name215 = "ObjectNode";
var dependencies216 = ["Node"];
var createObjectNode = /* @__PURE__ */ factory(name215, dependencies216, (_ref) => {
  var {
    Node
  } = _ref;

  class ObjectNode extends Node {
    constructor(properties2) {
      super();
      this.properties = properties2 || {};
      if (properties2) {
        if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
          return isNode(properties2[key]);
        })) {
          throw new TypeError("Object containing Nodes expected");
        }
      }
    }
    get type() {
      return name215;
    }
    get isObjectNode() {
      return true;
    }
    _compile(math, argNames) {
      var evalEntries = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);
          var prop = getSafeProperty(this.properties, key);
          evalEntries[parsedKey] = prop._compile(math, argNames);
        }
      }
      return function evalObjectNode(scope, args, context) {
        var obj = {};
        for (var _key in evalEntries) {
          if (hasOwnProperty(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context);
          }
        }
        return obj;
      };
    }
    forEach(callback) {
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          callback(this.properties[key], "properties[" + stringify(key) + "]", this);
        }
      }
    }
    map(callback) {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
        }
      }
      return new ObjectNode(properties2);
    }
    clone() {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this.properties[key];
        }
      }
      return new ObjectNode(properties2);
    }
    _toString(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push(stringify(key) + ": " + this.properties[key].toString(options));
        }
      }
      return "{" + entries.join(", ") + "}";
    }
    toJSON() {
      return {
        mathjs: name215,
        properties: this.properties
      };
    }
    static fromJSON(json) {
      return new ObjectNode(json.properties);
    }
    _toHTML(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push('<span class="math-symbol math-property">' + escape(key) + "</span>" + '<span class="math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator">' + ":</span>" + this.properties[key].toHTML(options));
        }
      }
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    _toTex(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
        }
      }
      var tex = "\\left\\{\\begin{array}{ll}" + entries.join(`
`) + "\\end{array}\\right\\}";
      return tex;
    }
  }
  _defineProperty(ObjectNode, "name", name215);
  return ObjectNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/utils/scope.js
function createSubScope(parentScope, args) {
  return new PartitionedMap(parentScope, new ObjectWrappingMap(args), new Set(Object.keys(args)));
}

// node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
var name216 = "OperatorNode";
var dependencies217 = ["Node"];
var createOperatorNode = /* @__PURE__ */ factory(name216, dependencies217, (_ref) => {
  var {
    Node
  } = _ref;
  function startsWithConstant(expr, parenthesis) {
    var curNode = expr;
    if (parenthesis === "auto") {
      while (isParenthesisNode(curNode))
        curNode = curNode.content;
    }
    if (isConstantNode(curNode))
      return true;
    if (isOperatorNode(curNode)) {
      return startsWithConstant(curNode.args[0], parenthesis);
    }
    return false;
  }
  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
    var precedence = getPrecedence(root, parenthesis, implicit);
    var associativity = getAssociativity(root, parenthesis);
    if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
      return args.map(function(arg) {
        switch (arg.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return false;
          default:
            return true;
        }
      });
    }
    var result;
    switch (args.length) {
      case 0:
        result = [];
        break;
      case 1:
        {
          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          if (latex && operandPrecedence !== null) {
            var operandIdentifier;
            var rootIdentifier;
            if (parenthesis === "keep") {
              operandIdentifier = args[0].getIdentifier();
              rootIdentifier = root.getIdentifier();
            } else {
              operandIdentifier = args[0].getContent().getIdentifier();
              rootIdentifier = root.getContent().getIdentifier();
            }
            if (properties[precedence][rootIdentifier].latexLeftParens === false) {
              result = [false];
              break;
            }
            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
              result = [false];
              break;
            }
          }
          if (operandPrecedence === null) {
            result = [false];
            break;
          }
          if (operandPrecedence <= precedence) {
            result = [true];
            break;
          }
          result = [false];
        }
        break;
      case 2:
        {
          var lhsParens;
          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
          if (lhsPrecedence === null) {
            lhsParens = false;
          } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
            lhsParens = true;
          } else if (lhsPrecedence < precedence) {
            lhsParens = true;
          } else {
            lhsParens = false;
          }
          var rhsParens;
          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
          if (rhsPrecedence === null) {
            rhsParens = false;
          } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
            rhsParens = true;
          } else if (rhsPrecedence < precedence) {
            rhsParens = true;
          } else {
            rhsParens = false;
          }
          if (latex) {
            var _rootIdentifier;
            var lhsIdentifier;
            var rhsIdentifier;
            if (parenthesis === "keep") {
              _rootIdentifier = root.getIdentifier();
              lhsIdentifier = root.args[0].getIdentifier();
              rhsIdentifier = root.args[1].getIdentifier();
            } else {
              _rootIdentifier = root.getContent().getIdentifier();
              lhsIdentifier = root.args[0].getContent().getIdentifier();
              rhsIdentifier = root.args[1].getContent().getIdentifier();
            }
            if (lhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                lhsParens = false;
              }
              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                lhsParens = false;
              }
            }
            if (rhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                rhsParens = false;
              }
              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                rhsParens = false;
              }
            }
          }
          result = [lhsParens, rhsParens];
        }
        break;
      default:
        if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
          result = args.map(function(arg) {
            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);
            var assocWithArg = isAssociativeWith(root, arg, parenthesis);
            var argAssociativity = getAssociativity(arg, parenthesis);
            if (argPrecedence === null) {
              return false;
            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
              return true;
            } else if (argPrecedence < precedence) {
              return true;
            }
            return false;
          });
        }
        break;
    }
    if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
      for (var i = 1;i < result.length; ++i) {
        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i - 1]))) {
          result[i] = true;
        }
      }
    }
    return result;
  }

  class OperatorNode extends Node {
    constructor(op, fn, args, implicit, isPercentage) {
      super();
      if (typeof op !== "string") {
        throw new TypeError('string expected for parameter "op"');
      }
      if (typeof fn !== "string") {
        throw new TypeError('string expected for parameter "fn"');
      }
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.implicit = implicit === true;
      this.isPercentage = isPercentage === true;
      this.op = op;
      this.fn = fn;
      this.args = args || [];
    }
    get type() {
      return name216;
    }
    get isOperatorNode() {
      return true;
    }
    _compile(math, argNames) {
      if (typeof this.fn !== "string" || !isSafeMethod(math, this.fn)) {
        if (!math[this.fn]) {
          throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }
      var fn = getSafeProperty(math, this.fn);
      var evalArgs = map(this.args, function(arg) {
        return arg._compile(math, argNames);
      });
      if (typeof fn === "function" && fn.rawArgs === true) {
        var rawArgs = this.args;
        return function evalOperatorNode(scope, args, context) {
          return fn(rawArgs, math, createSubScope(scope, args));
        };
      } else if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context) {
          return fn(evalArg0(scope, args, context));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context) {
          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
        };
      } else {
        return function evalOperatorNode(scope, args, context) {
          return fn.apply(null, map(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    }
    forEach(callback) {
      for (var i = 0;i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    }
    map(callback) {
      var args = [];
      for (var i = 0;i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);
    }
    clone() {
      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    isUnary() {
      return this.args.length === 1;
    }
    isBinary() {
      return this.args.length === 2;
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options);
        if (parens[0]) {
          operand = "(" + operand + ")";
        }
        var opIsNamed = /[a-zA-Z]+/.test(this.op);
        if (assoc === "right") {
          return this.op + (opIsNamed ? " " : "") + operand;
        } else if (assoc === "left") {
          return operand + (opIsNamed ? " " : "") + this.op;
        }
        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options);
        var rhs = args[1].toString(options);
        if (parens[0]) {
          lhs = "(" + lhs + ")";
        }
        if (parens[1]) {
          rhs = "(" + rhs + ")";
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + " " + rhs;
        }
        return lhs + " " + this.op + " " + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toString(options);
          if (parens[index]) {
            arg = "(" + arg + ")";
          }
          return arg;
        });
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return stringifiedArgs.join(" ");
        }
        return stringifiedArgs.join(" " + this.op + " ");
      } else {
        return this.fn + "(" + this.args.join(", ") + ")";
      }
    }
    toJSON() {
      return {
        mathjs: name216,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    static fromJSON(json) {
      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);
    }
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options);
        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (assoc === "right") {
          return '<span class="math-operator math-unary-operator ' + 'math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
        } else {
          return operand + '<span class="math-operator math-unary-operator ' + 'math-righthand-unary-operator">' + escape(this.op) + "</span>";
        }
      } else if (args.length === 2) {
        var lhs = args[0].toHTML(options);
        var rhs = args[1].toHTML(options);
        if (parens[0]) {
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (parens[1]) {
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + '<span class="math-operator math-binary-operator ' + 'math-implicit-binary-operator"></span>' + rhs;
        }
        return lhs + '<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
      } else {
        var stringifiedArgs = args.map(function(arg, index) {
          arg = arg.toHTML(options);
          if (parens[index]) {
            arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          return arg;
        });
        if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator ' + 'math-implicit-binary-operator"></span>');
          }
          return stringifiedArgs.join('<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(this.op) + "</span>");
        } else {
          return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">' + "(</span>" + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
      var op = latexOperators[this.fn];
      op = typeof op === "undefined" ? this.op : op;
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options);
        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }
        if (assoc === "right") {
          return op + operand;
        } else if (assoc === "left") {
          return operand + op;
        }
        return operand + op;
      } else if (args.length === 2) {
        var lhs = args[0];
        var lhsTex = lhs.toTex(options);
        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }
        var rhs = args[1];
        var rhsTex = rhs.toTex(options);
        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        }
        var lhsIdentifier;
        if (parenthesis === "keep") {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case "OperatorNode:divide":
            return op + "{" + lhsTex + "}" + "{" + rhsTex + "}";
          case "OperatorNode:pow":
            lhsTex = "{" + lhsTex + "}";
            rhsTex = "{" + rhsTex + "}";
            switch (lhsIdentifier) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && implicit === "hide") {
              return lhsTex + "~" + rhsTex;
            }
        }
        return lhsTex + op + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var texifiedArgs = args.map(function(arg, index) {
          arg = arg.toTex(options);
          if (parens[index]) {
            arg = "\\left(".concat(arg, "\\right)");
          }
          return arg;
        });
        if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
          return texifiedArgs.join("~");
        }
        return texifiedArgs.join(op);
      } else {
        return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
          return arg.toTex(options);
        }).join(",") + "\\right)";
      }
    }
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  _defineProperty(OperatorNode, "name", name216);
  return OperatorNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
var name217 = "ParenthesisNode";
var dependencies218 = ["Node"];
var createParenthesisNode = /* @__PURE__ */ factory(name217, dependencies218, (_ref) => {
  var {
    Node
  } = _ref;

  class ParenthesisNode extends Node {
    constructor(content) {
      super();
      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }
      this.content = content;
    }
    get type() {
      return name217;
    }
    get isParenthesisNode() {
      return true;
    }
    _compile(math, argNames) {
      return this.content._compile(math, argNames);
    }
    getContent() {
      return this.content.getContent();
    }
    forEach(callback) {
      callback(this.content, "content", this);
    }
    map(callback) {
      var content = callback(this.content, "content", this);
      return new ParenthesisNode(content);
    }
    clone() {
      return new ParenthesisNode(this.content);
    }
    _toString(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "(" + this.content.toString(options) + ")";
      }
      return this.content.toString(options);
    }
    toJSON() {
      return {
        mathjs: name217,
        content: this.content
      };
    }
    static fromJSON(json) {
      return new ParenthesisNode(json.content);
    }
    _toHTML(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return this.content.toHTML(options);
    }
    _toTex(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "\\left(".concat(this.content.toTex(options), "\\right)");
      }
      return this.content.toTex(options);
    }
  }
  _defineProperty(ParenthesisNode, "name", name217);
  return ParenthesisNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/RangeNode.js
var name218 = "RangeNode";
var dependencies219 = ["Node"];
var createRangeNode = /* @__PURE__ */ factory(name218, dependencies219, (_ref) => {
  var {
    Node
  } = _ref;
  function calculateNecessaryParentheses(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var parens = {};
    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
    if (node.step) {
      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
    }
    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
    return parens;
  }

  class RangeNode extends Node {
    constructor(start, end, step) {
      super();
      if (!isNode(start))
        throw new TypeError("Node expected");
      if (!isNode(end))
        throw new TypeError("Node expected");
      if (step && !isNode(step))
        throw new TypeError("Node expected");
      if (arguments.length > 3)
        throw new Error("Too many arguments");
      this.start = start;
      this.end = end;
      this.step = step || null;
    }
    get type() {
      return name218;
    }
    get isRangeNode() {
      return true;
    }
    needsEnd() {
      var endSymbols = this.filter(function(node) {
        return isSymbolNode(node) && node.name === "end";
      });
      return endSymbols.length > 0;
    }
    _compile(math, argNames) {
      var range = math.range;
      var evalStart = this.start._compile(math, argNames);
      var evalEnd = this.end._compile(math, argNames);
      if (this.step) {
        var evalStep = this.step._compile(math, argNames);
        return function evalRangeNode(scope, args, context) {
          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
        };
      } else {
        return function evalRangeNode(scope, args, context) {
          return range(evalStart(scope, args, context), evalEnd(scope, args, context));
        };
      }
    }
    forEach(callback) {
      callback(this.start, "start", this);
      callback(this.end, "end", this);
      if (this.step) {
        callback(this.step, "step", this);
      }
    }
    map(callback) {
      return new RangeNode(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
    }
    clone() {
      return new RangeNode(this.start, this.end, this.step && this.step);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start = this.start.toString(options);
      if (parens.start) {
        start = "(" + start + ")";
      }
      str = start;
      if (this.step) {
        var step = this.step.toString(options);
        if (parens.step) {
          step = "(" + step + ")";
        }
        str += ":" + step;
      }
      var end = this.end.toString(options);
      if (parens.end) {
        end = "(" + end + ")";
      }
      str += ":" + end;
      return str;
    }
    toJSON() {
      return {
        mathjs: name218,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    static fromJSON(json) {
      return new RangeNode(json.start, json.end, json.step);
    }
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start = this.start.toHTML(options);
      if (parens.start) {
        start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str = start;
      if (this.step) {
        var step = this.step.toHTML(options);
        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }
      var end = this.end.toHTML(options);
      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str = this.start.toTex(options);
      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }
      if (this.step) {
        var step = this.step.toTex(options);
        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }
        str += ":" + step;
      }
      var end = this.end.toTex(options);
      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }
      str += ":" + end;
      return str;
    }
  }
  _defineProperty(RangeNode, "name", name218);
  return RangeNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
var name219 = "RelationalNode";
var dependencies220 = ["Node"];
var createRelationalNode = /* @__PURE__ */ factory(name219, dependencies220, (_ref) => {
  var {
    Node
  } = _ref;
  var operatorMap = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };

  class RelationalNode extends Node {
    constructor(conditionals, params) {
      super();
      if (!Array.isArray(conditionals)) {
        throw new TypeError("Parameter conditionals must be an array");
      }
      if (!Array.isArray(params)) {
        throw new TypeError("Parameter params must be an array");
      }
      if (conditionals.length !== params.length - 1) {
        throw new TypeError("Parameter params must contain exactly one more element " + "than parameter conditionals");
      }
      this.conditionals = conditionals;
      this.params = params;
    }
    get type() {
      return name219;
    }
    get isRelationalNode() {
      return true;
    }
    _compile(math, argNames) {
      var self2 = this;
      var compiled = this.params.map((p) => p._compile(math, argNames));
      return function evalRelationalNode(scope, args, context) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context);
        for (var i = 0;i < self2.conditionals.length; i++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i + 1](scope, args, context);
          var condFn = getSafeProperty(math, self2.conditionals[i]);
          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }
        return true;
      };
    }
    forEach(callback) {
      this.params.forEach((n, i) => callback(n, "params[" + i + "]", this), this);
    }
    map(callback) {
      return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, "params[" + i + "]", this)), this));
    }
    clone() {
      return new RelationalNode(this.conditionals, this.params);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
      });
      var ret = paramStrings[0];
      for (var i = 0;i < this.conditionals.length; i++) {
        ret += " " + operatorMap[this.conditionals[i]];
        ret += " " + paramStrings[i + 1];
      }
      return ret;
    }
    toJSON() {
      return {
        mathjs: name219,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    static fromJSON(json) {
      return new RelationalNode(json.conditionals, json.params);
    }
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
      });
      var ret = paramStrings[0];
      for (var i = 0;i < this.conditionals.length; i++) {
        ret += '<span class="math-operator math-binary-operator ' + 'math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
      }
      return ret;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
      });
      var ret = paramStrings[0];
      for (var i = 0;i < this.conditionals.length; i++) {
        ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
      }
      return ret;
    }
  }
  _defineProperty(RelationalNode, "name", name219);
  return RelationalNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
var name220 = "SymbolNode";
var dependencies221 = ["math", "?Unit", "Node"];
var createSymbolNode = /* @__PURE__ */ factory(name220, dependencies221, (_ref) => {
  var {
    math,
    Unit,
    Node
  } = _ref;
  function isValuelessUnit(name221) {
    return Unit ? Unit.isValuelessUnit(name221) : false;
  }

  class SymbolNode extends Node {
    constructor(name221) {
      super();
      if (typeof name221 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      this.name = name221;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return true;
    }
    _compile(math2, argNames) {
      var name221 = this.name;
      if (argNames[name221] === true) {
        return function(scope, args, context) {
          return getSafeProperty(args, name221);
        };
      } else if (name221 in math2) {
        return function(scope, args, context) {
          return scope.has(name221) ? scope.get(name221) : getSafeProperty(math2, name221);
        };
      } else {
        var isUnit2 = isValuelessUnit(name221);
        return function(scope, args, context) {
          return scope.has(name221) ? scope.get(name221) : isUnit2 ? new Unit(null, name221) : SymbolNode.onUndefinedSymbol(name221);
        };
      }
    }
    forEach(callback) {
    }
    map(callback) {
      return this.clone();
    }
    static onUndefinedSymbol(name221) {
      throw new Error("Undefined symbol " + name221);
    }
    clone() {
      return new SymbolNode(this.name);
    }
    _toString(options) {
      return this.name;
    }
    _toHTML(options) {
      var name221 = escape(this.name);
      if (name221 === "true" || name221 === "false") {
        return '<span class="math-symbol math-boolean">' + name221 + "</span>";
      } else if (name221 === "i") {
        return '<span class="math-symbol math-imaginary-symbol">' + name221 + "</span>";
      } else if (name221 === "Infinity") {
        return '<span class="math-symbol math-infinity-symbol">' + name221 + "</span>";
      } else if (name221 === "NaN") {
        return '<span class="math-symbol math-nan-symbol">' + name221 + "</span>";
      } else if (name221 === "null") {
        return '<span class="math-symbol math-null-symbol">' + name221 + "</span>";
      } else if (name221 === "undefined") {
        return '<span class="math-symbol math-undefined-symbol">' + name221 + "</span>";
      }
      return '<span class="math-symbol">' + name221 + "</span>";
    }
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    static fromJSON(json) {
      return new SymbolNode(json.name);
    }
    _toTex(options) {
      var isUnit2 = false;
      if (typeof math[this.name] === "undefined" && isValuelessUnit(this.name)) {
        isUnit2 = true;
      }
      var symbol = toSymbol(this.name, isUnit2);
      if (symbol[0] === "\\") {
        return symbol;
      }
      return " " + symbol;
    }
  }
  return SymbolNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
var name221 = "FunctionNode";
var dependencies222 = ["math", "Node", "SymbolNode"];
var createFunctionNode = /* @__PURE__ */ factory(name221, dependencies222, (_ref) => {
  var _FunctionNode;
  var {
    math,
    Node,
    SymbolNode
  } = _ref;
  var strin = (entity) => format3(entity, {
    truncate: 78
  });
  function expandTemplate(template, node, options) {
    var latex = "";
    var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
    var inputPos = 0;
    var match;
    while ((match = regex.exec(template)) !== null) {
      latex += template.substring(inputPos, match.index);
      inputPos = match.index;
      if (match[0] === "$") {
        latex += "$";
        inputPos++;
      } else {
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
        }
        if (match[2] === undefined) {
          switch (typeof property) {
            case "string":
              latex += property;
              break;
            case "object":
              if (isNode(property)) {
                latex += property.toTex(options);
              } else if (Array.isArray(property)) {
                latex += property.map(function(arg, index) {
                  if (isNode(arg)) {
                    return arg.toTex(options);
                  }
                  throw new TypeError("Template: " + match[1] + "[" + index + "] is not a Node.");
                }).join(",");
              } else {
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
              }
              break;
            default:
              throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
          }
        } else {
          if (isNode(property[match[2]] && property[match[2]])) {
            latex += property[match[2]].toTex(options);
          } else {
            throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
          }
        }
      }
    }
    latex += template.slice(inputPos);
    return latex;
  }

  class FunctionNode extends Node {
    constructor(fn, args) {
      super();
      if (typeof fn === "string") {
        fn = new SymbolNode(fn);
      }
      if (!isNode(fn))
        throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.fn = fn;
      this.args = args || [];
    }
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return name221;
    }
    get isFunctionNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalArgs = this.args.map((arg) => arg._compile(math2, argNames));
      if (isSymbolNode(this.fn)) {
        var _name = this.fn.name;
        if (!argNames[_name]) {
          var fn = _name in math2 ? getSafeProperty(math2, _name) : undefined;
          var isRaw = typeof fn === "function" && fn.rawArgs === true;
          var resolveFn = (scope) => {
            var value;
            if (scope.has(_name)) {
              value = scope.get(_name);
            } else if (_name in math2) {
              value = getSafeProperty(math2, _name);
            } else {
              return FunctionNode.onUndefinedFunction(_name);
            }
            if (typeof value === "function") {
              return value;
            }
            throw new TypeError("'".concat(_name, `' is not a function; its value is:
  `).concat(strin(value)));
          };
          if (isRaw) {
            var rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = resolveFn(scope);
              if (fn2.rawArgs === true) {
                return fn2(rawArgs, math2, createSubScope(scope, args));
              } else {
                var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                return fn2(...values);
              }
            };
          } else {
            switch (evalArgs.length) {
              case 0:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  return fn2();
                };
              case 1:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  return fn2(evalArg0(scope, args, context));
                };
              case 2:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  var evalArg1 = evalArgs[1];
                  return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                };
              default:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                  return fn2(...values);
                };
            }
          }
        } else {
          var _rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = getSafeProperty(args, _name);
            if (typeof fn2 !== "function") {
              throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs, math2, createSubScope(scope, args));
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values);
            }
          };
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        var evalObject = this.fn.object._compile(math2, argNames);
        var prop = this.fn.index.getObjectProperty();
        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var fn2 = getSafeMethod(object, prop);
          if (fn2 !== null && fn2 !== undefined && fn2.rawArgs) {
            return fn2(_rawArgs2, math2, createSubScope(scope, args));
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(object, values);
          }
        };
      } else {
        var fnExpr = this.fn.toString();
        var evalFn = this.fn._compile(math2, argNames);
        var _rawArgs3 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var fn2 = evalFn(scope, args, context);
          if (typeof fn2 !== "function") {
            throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + `
  `.concat(strin(fn2)));
          }
          if (fn2.rawArgs) {
            return fn2(_rawArgs3, math2, createSubScope(scope, args));
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(fn2, values);
          }
        };
      }
    }
    forEach(callback) {
      callback(this.fn, "fn", this);
      for (var i = 0;i < this.args.length; i++) {
        callback(this.args[i], "args[" + i + "]", this);
      }
    }
    map(callback) {
      var fn = this._ifNode(callback(this.fn, "fn", this));
      var args = [];
      for (var i = 0;i < this.args.length; i++) {
        args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
      }
      return new FunctionNode(fn, args);
    }
    clone() {
      return new FunctionNode(this.fn, this.args.slice(0));
    }
    toString(options) {
      var customString;
      var name222 = this.fn.toString(options);
      if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, name222)) {
        customString = options.handler[name222](this, options);
      }
      if (typeof customString !== "undefined") {
        return customString;
      }
      return super.toString(options);
    }
    _toString(options) {
      var args = this.args.map(function(arg) {
        return arg.toString(options);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
      return fn + "(" + args.join(", ") + ")";
    }
    toJSON() {
      return {
        mathjs: name221,
        fn: this.fn,
        args: this.args
      };
    }
    _toHTML(options) {
      var args = this.args.map(function(arg) {
        return arg.toHTML(options);
      });
      return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    toTex(options) {
      var customTex;
      if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, this.name)) {
        customTex = options.handler[this.name](this, options);
      }
      if (typeof customTex !== "undefined") {
        return customTex;
      }
      return super.toTex(options);
    }
    _toTex(options) {
      var args = this.args.map(function(arg) {
        return arg.toTex(options);
      });
      var latexConverter;
      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      }
      if (math[this.name] && (typeof math[this.name].toTex === "function" || typeof math[this.name].toTex === "object" || typeof math[this.name].toTex === "string")) {
        latexConverter = math[this.name].toTex;
      }
      var customToTex;
      switch (typeof latexConverter) {
        case "function":
          customToTex = latexConverter(this, options);
          break;
        case "string":
          customToTex = expandTemplate(latexConverter, this, options);
          break;
        case "object":
          switch (typeof latexConverter[args.length]) {
            case "function":
              customToTex = latexConverter[args.length](this, options);
              break;
            case "string":
              customToTex = expandTemplate(latexConverter[args.length], this, options);
              break;
          }
      }
      if (typeof customToTex !== "undefined") {
        return customToTex;
      }
      return expandTemplate(defaultTemplate, this, options);
    }
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  _FunctionNode = FunctionNode;
  _defineProperty(FunctionNode, "name", name221);
  _defineProperty(FunctionNode, "onUndefinedFunction", function(name222) {
    throw new Error("Undefined function " + name222);
  });
  _defineProperty(FunctionNode, "fromJSON", function(json) {
    return new _FunctionNode(json.fn, json.args);
  });
  return FunctionNode;
}, {
  isClass: true,
  isNode: true
});
// node_modules/mathjs/lib/esm/expression/parse.js
var name222 = "parse";
var dependencies223 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
var createParse = /* @__PURE__ */ factory(name222, dependencies223, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric2,
    config: config4,
    AccessorNode,
    ArrayNode,
    AssignmentNode,
    BlockNode,
    ConditionalNode,
    ConstantNode,
    FunctionAssignmentNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    RangeNode,
    RelationalNode,
    SymbolNode
  } = _ref;
  var parse3 = typed2(name222, {
    string: function string(expression) {
      return parseStart(expression, {});
    },
    "Array | Matrix": function Array__Matrix(expressions) {
      return parseMultiple(expressions, {});
    },
    "string, Object": function string_Object(expression, options) {
      var extraNodes = options.nodes !== undefined ? options.nodes : {};
      return parseStart(expression, extraNodes);
    },
    "Array | Matrix, Object": parseMultiple
  });
  function parseMultiple(expressions) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var extraNodes = options.nodes !== undefined ? options.nodes : {};
    return deepMap(expressions, function(elem) {
      if (typeof elem !== "string")
        throw new TypeError("String expected");
      return parseStart(elem, extraNodes);
    });
  }
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  };
  var DELIMITERS = {
    ",": true,
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
    '"': true,
    "'": true,
    ";": true,
    "+": true,
    "-": true,
    "*": true,
    ".*": true,
    "/": true,
    "./": true,
    "%": true,
    "^": true,
    ".^": true,
    "~": true,
    "!": true,
    "&": true,
    "|": true,
    "^|": true,
    "=": true,
    ":": true,
    "?": true,
    "==": true,
    "!=": true,
    "<": true,
    ">": true,
    "<=": true,
    ">=": true,
    "<<": true,
    ">>": true,
    ">>>": true
  };
  var NAMED_DELIMITERS = {
    mod: true,
    to: true,
    in: true,
    and: true,
    xor: true,
    or: true,
    not: true
  };
  var CONSTANTS = {
    true: true,
    false: false,
    null: null,
    undefined: undefined
  };
  var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
  var ESCAPE_CHARACTERS = {
    '"': '"',
    "'": "'",
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t"
  };
  function initialState() {
    return {
      extraNodes: {},
      expression: "",
      comment: "",
      index: 0,
      token: "",
      tokenType: TOKENTYPE.NULL,
      nestingLevel: 0,
      conditionalLevel: null
    };
  }
  function currentString(state, length) {
    return state.expression.substr(state.index, length);
  }
  function currentCharacter(state) {
    return currentString(state, 1);
  }
  function next(state) {
    state.index++;
  }
  function prevCharacter(state) {
    return state.expression.charAt(state.index - 1);
  }
  function nextCharacter(state) {
    return state.expression.charAt(state.index + 1);
  }
  function getToken(state) {
    state.tokenType = TOKENTYPE.NULL;
    state.token = "";
    state.comment = "";
    while (true) {
      if (currentCharacter(state) === "#") {
        while (currentCharacter(state) !== `
` && currentCharacter(state) !== "") {
          state.comment += currentCharacter(state);
          next(state);
        }
      }
      if (parse3.isWhitespace(currentCharacter(state), state.nestingLevel)) {
        next(state);
      } else {
        break;
      }
    }
    if (currentCharacter(state) === "") {
      state.tokenType = TOKENTYPE.DELIMITER;
      return;
    }
    if (currentCharacter(state) === `
` && !state.nestingLevel) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = currentCharacter(state);
      next(state);
      return;
    }
    var c1 = currentCharacter(state);
    var c2 = currentString(state, 2);
    var c3 = currentString(state, 3);
    if (c3.length === 3 && DELIMITERS[c3]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c3;
      next(state);
      next(state);
      next(state);
      return;
    }
    if (c2.length === 2 && DELIMITERS[c2]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c2;
      next(state);
      next(state);
      return;
    }
    if (DELIMITERS[c1]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c1;
      next(state);
      return;
    }
    if (parse3.isDigitDot(c1)) {
      state.tokenType = TOKENTYPE.NUMBER;
      var _c = currentString(state, 2);
      if (_c === "0b" || _c === "0o" || _c === "0x") {
        state.token += currentCharacter(state);
        next(state);
        state.token += currentCharacter(state);
        next(state);
        while (parse3.isHexDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === ".") {
          state.token += ".";
          next(state);
          while (parse3.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        } else if (currentCharacter(state) === "i") {
          state.token += "i";
          next(state);
          while (parse3.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        return;
      }
      if (currentCharacter(state) === ".") {
        state.token += currentCharacter(state);
        next(state);
        if (!parse3.isDigit(currentCharacter(state))) {
          state.tokenType = TOKENTYPE.DELIMITER;
          return;
        }
      } else {
        while (parse3.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (parse3.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
      }
      while (parse3.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
        if (parse3.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
          state.token += currentCharacter(state);
          next(state);
          if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
            state.token += currentCharacter(state);
            next(state);
          }
          if (!parse3.isDigit(currentCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
          while (parse3.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse3.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        } else if (nextCharacter(state) === ".") {
          next(state);
          throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
        }
      }
      return;
    }
    if (parse3.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
      while (parse3.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse3.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
        state.tokenType = TOKENTYPE.DELIMITER;
      } else {
        state.tokenType = TOKENTYPE.SYMBOL;
      }
      return;
    }
    state.tokenType = TOKENTYPE.UNKNOWN;
    while (currentCharacter(state) !== "") {
      state.token += currentCharacter(state);
      next(state);
    }
    throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
  }
  function getTokenSkipNewline(state) {
    do {
      getToken(state);
    } while (state.token === `
`);
  }
  function openParams(state) {
    state.nestingLevel++;
  }
  function closeParams(state) {
    state.nestingLevel--;
  }
  parse3.isAlpha = function isAlpha(c, cPrev, cNext) {
    return parse3.isValidLatinOrGreek(c) || parse3.isValidMathSymbol(c, cNext) || parse3.isValidMathSymbol(cPrev, c);
  };
  parse3.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
  };
  parse3.isValidMathSymbol = function isValidMathSymbol(high, low) {
    return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
  };
  parse3.isWhitespace = function isWhitespace(c, nestingLevel) {
    return c === " " || c === "\t" || c === `
` && nestingLevel > 0;
  };
  parse3.isDecimalMark = function isDecimalMark(c, cNext) {
    return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
  };
  parse3.isDigitDot = function isDigitDot(c) {
    return c >= "0" && c <= "9" || c === ".";
  };
  parse3.isDigit = function isDigit(c) {
    return c >= "0" && c <= "9";
  };
  parse3.isHexDigit = function isHexDigit(c) {
    return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
  };
  function parseStart(expression, extraNodes) {
    var state = initialState();
    _extends(state, {
      expression,
      extraNodes
    });
    getToken(state);
    var node = parseBlock(state);
    if (state.token !== "") {
      if (state.tokenType === TOKENTYPE.DELIMITER) {
        throw createError(state, "Unexpected operator " + state.token);
      } else {
        throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
      }
    }
    return node;
  }
  function parseBlock(state) {
    var node;
    var blocks = [];
    var visible;
    if (state.token !== "" && state.token !== `
` && state.token !== ";") {
      node = parseAssignment(state);
      if (state.comment) {
        node.comment = state.comment;
      }
    }
    while (state.token === `
` || state.token === ";") {
      if (blocks.length === 0 && node) {
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
      getToken(state);
      if (state.token !== `
` && state.token !== ";" && state.token !== "") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
    }
    if (blocks.length > 0) {
      return new BlockNode(blocks);
    } else {
      if (!node) {
        node = new ConstantNode(undefined);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      return node;
    }
  }
  function parseAssignment(state) {
    var name223, args, value, valid;
    var node = parseConditional(state);
    if (state.token === "=") {
      if (isSymbolNode(node)) {
        name223 = node.name;
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode(new SymbolNode(name223), value);
      } else if (isAccessorNode(node)) {
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode(node.object, node.index, value);
      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
        valid = true;
        args = [];
        name223 = node.name;
        node.args.forEach(function(arg, index) {
          if (isSymbolNode(arg)) {
            args[index] = arg.name;
          } else {
            valid = false;
          }
        });
        if (valid) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new FunctionAssignmentNode(name223, args, value);
        }
      }
      throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
    }
    return node;
  }
  function parseConditional(state) {
    var node = parseLogicalOr(state);
    while (state.token === "?") {
      var prev = state.conditionalLevel;
      state.conditionalLevel = state.nestingLevel;
      getTokenSkipNewline(state);
      var condition = node;
      var trueExpr = parseAssignment(state);
      if (state.token !== ":")
        throw createSyntaxError(state, "False part of conditional expression expected");
      state.conditionalLevel = null;
      getTokenSkipNewline(state);
      var falseExpr = parseAssignment(state);
      node = new ConditionalNode(condition, trueExpr, falseExpr);
      state.conditionalLevel = prev;
    }
    return node;
  }
  function parseLogicalOr(state) {
    var node = parseLogicalXor(state);
    while (state.token === "or") {
      getTokenSkipNewline(state);
      node = new OperatorNode("or", "or", [node, parseLogicalXor(state)]);
    }
    return node;
  }
  function parseLogicalXor(state) {
    var node = parseLogicalAnd(state);
    while (state.token === "xor") {
      getTokenSkipNewline(state);
      node = new OperatorNode("xor", "xor", [node, parseLogicalAnd(state)]);
    }
    return node;
  }
  function parseLogicalAnd(state) {
    var node = parseBitwiseOr(state);
    while (state.token === "and") {
      getTokenSkipNewline(state);
      node = new OperatorNode("and", "and", [node, parseBitwiseOr(state)]);
    }
    return node;
  }
  function parseBitwiseOr(state) {
    var node = parseBitwiseXor(state);
    while (state.token === "|") {
      getTokenSkipNewline(state);
      node = new OperatorNode("|", "bitOr", [node, parseBitwiseXor(state)]);
    }
    return node;
  }
  function parseBitwiseXor(state) {
    var node = parseBitwiseAnd(state);
    while (state.token === "^|") {
      getTokenSkipNewline(state);
      node = new OperatorNode("^|", "bitXor", [node, parseBitwiseAnd(state)]);
    }
    return node;
  }
  function parseBitwiseAnd(state) {
    var node = parseRelational(state);
    while (state.token === "&") {
      getTokenSkipNewline(state);
      node = new OperatorNode("&", "bitAnd", [node, parseRelational(state)]);
    }
    return node;
  }
  function parseRelational(state) {
    var params = [parseShift(state)];
    var conditionals = [];
    var operators = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    };
    while (hasOwnProperty(operators, state.token)) {
      var cond = {
        name: state.token,
        fn: operators[state.token]
      };
      conditionals.push(cond);
      getTokenSkipNewline(state);
      params.push(parseShift(state));
    }
    if (params.length === 1) {
      return params[0];
    } else if (params.length === 2) {
      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
    } else {
      return new RelationalNode(conditionals.map((c) => c.fn), params);
    }
  }
  function parseShift(state) {
    var node, name223, fn, params;
    node = parseConversion(state);
    var operators = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    };
    while (hasOwnProperty(operators, state.token)) {
      name223 = state.token;
      fn = operators[name223];
      getTokenSkipNewline(state);
      params = [node, parseConversion(state)];
      node = new OperatorNode(name223, fn, params);
    }
    return node;
  }
  function parseConversion(state) {
    var node, name223, fn, params;
    node = parseRange(state);
    var operators = {
      to: "to",
      in: "to"
    };
    while (hasOwnProperty(operators, state.token)) {
      name223 = state.token;
      fn = operators[name223];
      getTokenSkipNewline(state);
      if (name223 === "in" && state.token === "") {
        node = new OperatorNode("*", "multiply", [node, new SymbolNode("in")], true);
      } else {
        params = [node, parseRange(state)];
        node = new OperatorNode(name223, fn, params);
      }
    }
    return node;
  }
  function parseRange(state) {
    var node;
    var params = [];
    if (state.token === ":") {
      node = new ConstantNode(1);
    } else {
      node = parseAddSubtract(state);
    }
    if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
      params.push(node);
      while (state.token === ":" && params.length < 3) {
        getTokenSkipNewline(state);
        if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
          params.push(new SymbolNode("end"));
        } else {
          params.push(parseAddSubtract(state));
        }
      }
      if (params.length === 3) {
        node = new RangeNode(params[0], params[2], params[1]);
      } else {
        node = new RangeNode(params[0], params[1]);
      }
    }
    return node;
  }
  function parseAddSubtract(state) {
    var node, name223, fn, params;
    node = parseMultiplyDivideModulusPercentage(state);
    var operators = {
      "+": "add",
      "-": "subtract"
    };
    while (hasOwnProperty(operators, state.token)) {
      name223 = state.token;
      fn = operators[name223];
      getTokenSkipNewline(state);
      var rightNode = parseMultiplyDivideModulusPercentage(state);
      if (rightNode.isPercentage) {
        params = [node, new OperatorNode("*", "multiply", [node, rightNode])];
      } else {
        params = [node, rightNode];
      }
      node = new OperatorNode(name223, fn, params);
    }
    return node;
  }
  function parseMultiplyDivideModulusPercentage(state) {
    var node, last, name223, fn;
    node = parseImplicitMultiplication(state);
    last = node;
    var operators = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide",
      "%": "mod",
      mod: "mod"
    };
    while (true) {
      if (hasOwnProperty(operators, state.token)) {
        name223 = state.token;
        fn = operators[name223];
        getTokenSkipNewline(state);
        if (name223 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
          if (state.token !== "" && operators[state.token]) {
            var left = new OperatorNode("/", "divide", [node, new ConstantNode(100)], false, true);
            name223 = state.token;
            fn = operators[name223];
            getTokenSkipNewline(state);
            last = parseImplicitMultiplication(state);
            node = new OperatorNode(name223, fn, [left, last]);
          } else {
            node = new OperatorNode("/", "divide", [node, new ConstantNode(100)], false, true);
          }
        } else {
          last = parseImplicitMultiplication(state);
          node = new OperatorNode(name223, fn, [node, last]);
        }
      } else {
        break;
      }
    }
    return node;
  }
  function parseImplicitMultiplication(state) {
    var node, last;
    node = parseRule2(state);
    last = node;
    while (true) {
      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.token === "in" && isOperatorNode(node) && node.fn === "unaryMinus" && isConstantNode(node.args[0]) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
        last = parseRule2(state);
        node = new OperatorNode("*", "multiply", [node, last], true);
      } else {
        break;
      }
    }
    return node;
  }
  function parseRule2(state) {
    var node = parseUnary(state);
    var last = node;
    var tokenStates = [];
    while (true) {
      if (state.token === "/" && rule2Node(last)) {
        tokenStates.push(_extends({}, state));
        getTokenSkipNewline(state);
        if (state.tokenType === TOKENTYPE.NUMBER) {
          tokenStates.push(_extends({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(" || state.token === "in") {
            _extends(state, tokenStates.pop());
            tokenStates.pop();
            last = parseUnary(state);
            node = new OperatorNode("/", "divide", [node, last]);
          } else {
            tokenStates.pop();
            _extends(state, tokenStates.pop());
            break;
          }
        } else {
          _extends(state, tokenStates.pop());
          break;
        }
      } else {
        break;
      }
    }
    return node;
  }
  function parseUnary(state) {
    var name223, params, fn;
    var operators = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    if (hasOwnProperty(operators, state.token)) {
      fn = operators[state.token];
      name223 = state.token;
      getTokenSkipNewline(state);
      params = [parseUnary(state)];
      return new OperatorNode(name223, fn, params);
    }
    return parsePow(state);
  }
  function parsePow(state) {
    var node, name223, fn, params;
    node = parseLeftHandOperators(state);
    if (state.token === "^" || state.token === ".^") {
      name223 = state.token;
      fn = name223 === "^" ? "pow" : "dotPow";
      getTokenSkipNewline(state);
      params = [node, parseUnary(state)];
      node = new OperatorNode(name223, fn, params);
    }
    return node;
  }
  function parseLeftHandOperators(state) {
    var node, name223, fn, params;
    node = parseCustomNodes(state);
    var operators = {
      "!": "factorial",
      "'": "ctranspose"
    };
    while (hasOwnProperty(operators, state.token)) {
      name223 = state.token;
      fn = operators[name223];
      getToken(state);
      params = [node];
      node = new OperatorNode(name223, fn, params);
      node = parseAccessors(state, node);
    }
    return node;
  }
  function parseCustomNodes(state) {
    var params = [];
    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {
      var CustomNode = state.extraNodes[state.token];
      getToken(state);
      if (state.token === "(") {
        params = [];
        openParams(state);
        getToken(state);
        if (state.token !== ")") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
      }
      return new CustomNode(params);
    }
    return parseSymbol(state);
  }
  function parseSymbol(state) {
    var node, name223;
    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
      name223 = state.token;
      getToken(state);
      if (hasOwnProperty(CONSTANTS, name223)) {
        node = new ConstantNode(CONSTANTS[name223]);
      } else if (NUMERIC_CONSTANTS.includes(name223)) {
        node = new ConstantNode(numeric2(name223, "number"));
      } else {
        node = new SymbolNode(name223);
      }
      node = parseAccessors(state, node);
      return node;
    }
    return parseString(state);
  }
  function parseAccessors(state, node, types) {
    var params;
    while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.includes(state.token))) {
      params = [];
      if (state.token === "(") {
        if (isSymbolNode(node) || isAccessorNode(node)) {
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
          node = new FunctionNode(node, params);
        } else {
          return node;
        }
      } else if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== "]") {
          throw createSyntaxError(state, "Parenthesis ] expected");
        }
        closeParams(state);
        getToken(state);
        node = new AccessorNode(node, new IndexNode(params));
      } else {
        getToken(state);
        var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;
        if (!isPropertyName) {
          throw createSyntaxError(state, "Property name expected after dot");
        }
        params.push(new ConstantNode(state.token));
        getToken(state);
        var dotNotation = true;
        node = new AccessorNode(node, new IndexNode(params, dotNotation));
      }
    }
    return node;
  }
  function parseString(state) {
    var node, str;
    if (state.token === '"' || state.token === "'") {
      str = parseStringToken(state, state.token);
      node = new ConstantNode(str);
      node = parseAccessors(state, node);
      return node;
    }
    return parseMatrix(state);
  }
  function parseStringToken(state, quote) {
    var str = "";
    while (currentCharacter(state) !== "" && currentCharacter(state) !== quote) {
      if (currentCharacter(state) === "\\") {
        next(state);
        var char = currentCharacter(state);
        var escapeChar = ESCAPE_CHARACTERS[char];
        if (escapeChar !== undefined) {
          str += escapeChar;
          state.index += 1;
        } else if (char === "u") {
          var unicode = state.expression.slice(state.index + 1, state.index + 5);
          if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {
            str += String.fromCharCode(parseInt(unicode, 16));
            state.index += 5;
          } else {
            throw createSyntaxError(state, "Invalid unicode character \\u".concat(unicode));
          }
        } else {
          throw createSyntaxError(state, "Bad escape character \\".concat(char));
        }
      } else {
        str += currentCharacter(state);
        next(state);
      }
    }
    getToken(state);
    if (state.token !== quote) {
      throw createSyntaxError(state, "End of string ".concat(quote, " expected"));
    }
    getToken(state);
    return str;
  }
  function parseMatrix(state) {
    var array, params, rows, cols;
    if (state.token === "[") {
      openParams(state);
      getToken(state);
      if (state.token !== "]") {
        var row = parseRow(state);
        if (state.token === ";") {
          rows = 1;
          params = [row];
          while (state.token === ";") {
            getToken(state);
            if (state.token !== "]") {
              params[rows] = parseRow(state);
              rows++;
            }
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          cols = params[0].items.length;
          for (var r = 1;r < rows; r++) {
            if (params[r].items.length !== cols) {
              throw createError(state, "Column dimensions mismatch " + "(" + params[r].items.length + " !== " + cols + ")");
            }
          }
          array = new ArrayNode(params);
        } else {
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          array = row;
        }
      } else {
        closeParams(state);
        getToken(state);
        array = new ArrayNode([]);
      }
      return parseAccessors(state, array);
    }
    return parseObject(state);
  }
  function parseRow(state) {
    var params = [parseAssignment(state)];
    var len = 1;
    while (state.token === ",") {
      getToken(state);
      if (state.token !== "]" && state.token !== ";") {
        params[len] = parseAssignment(state);
        len++;
      }
    }
    return new ArrayNode(params);
  }
  function parseObject(state) {
    if (state.token === "{") {
      openParams(state);
      var key;
      var properties2 = {};
      do {
        getToken(state);
        if (state.token !== "}") {
          if (state.token === '"' || state.token === "'") {
            key = parseStringToken(state, state.token);
          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
            key = state.token;
            getToken(state);
          } else {
            throw createSyntaxError(state, "Symbol or string expected as object key");
          }
          if (state.token !== ":") {
            throw createSyntaxError(state, "Colon : expected after object key");
          }
          getToken(state);
          properties2[key] = parseAssignment(state);
        }
      } while (state.token === ",");
      if (state.token !== "}") {
        throw createSyntaxError(state, "Comma , or bracket } expected after object value");
      }
      closeParams(state);
      getToken(state);
      var node = new ObjectNode(properties2);
      node = parseAccessors(state, node);
      return node;
    }
    return parseNumber(state);
  }
  function parseNumber(state) {
    var numberStr;
    if (state.tokenType === TOKENTYPE.NUMBER) {
      numberStr = state.token;
      getToken(state);
      var numericType = safeNumberType(numberStr, config4);
      var value = numeric2(numberStr, numericType);
      return new ConstantNode(value);
    }
    return parseParentheses(state);
  }
  function parseParentheses(state) {
    var node;
    if (state.token === "(") {
      openParams(state);
      getToken(state);
      node = parseAssignment(state);
      if (state.token !== ")") {
        throw createSyntaxError(state, "Parenthesis ) expected");
      }
      closeParams(state);
      getToken(state);
      node = new ParenthesisNode(node);
      node = parseAccessors(state, node);
      return node;
    }
    return parseEnd(state);
  }
  function parseEnd(state) {
    if (state.token === "") {
      throw createSyntaxError(state, "Unexpected end of expression");
    } else {
      throw createSyntaxError(state, "Value expected");
    }
  }
  function col(state) {
    return state.index - state.token.length + 1;
  }
  function createSyntaxError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  function createError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  typed2.addConversion({
    from: "string",
    to: "Node",
    convert: parse3
  });
  return parse3;
});
// node_modules/mathjs/lib/esm/expression/function/compile.js
var name223 = "compile";
var dependencies224 = ["typed", "parse"];
var createCompile = /* @__PURE__ */ factory(name223, dependencies224, (_ref) => {
  var {
    typed: typed2,
    parse: parse3
  } = _ref;
  return typed2(name223, {
    string: function string(expr) {
      return parse3(expr).compile();
    },
    "Array | Matrix": function Array__Matrix(expr) {
      return deepMap(expr, function(entry) {
        return parse3(entry).compile();
      });
    }
  });
});
// node_modules/mathjs/lib/esm/expression/function/evaluate.js
var name224 = "evaluate";
var dependencies225 = ["typed", "parse"];
var createEvaluate = /* @__PURE__ */ factory(name224, dependencies225, (_ref) => {
  var {
    typed: typed2,
    parse: parse3
  } = _ref;
  return typed2(name224, {
    string: function string(expr) {
      var scope = createEmptyMap();
      return parse3(expr).compile().evaluate(scope);
    },
    "string, Map | Object": function string_Map__Object(expr, scope) {
      return parse3(expr).compile().evaluate(scope);
    },
    "Array | Matrix": function Array__Matrix(expr) {
      var scope = createEmptyMap();
      return deepMap(expr, function(entry) {
        return parse3(entry).compile().evaluate(scope);
      });
    },
    "Array | Matrix, Map | Object": function Array__Matrix_Map__Object(expr, scope) {
      return deepMap(expr, function(entry) {
        return parse3(entry).compile().evaluate(scope);
      });
    }
  });
});
// node_modules/mathjs/lib/esm/expression/Parser.js
var name225 = "Parser";
var dependencies226 = ["evaluate", "parse"];
var createParserClass = /* @__PURE__ */ factory(name225, dependencies226, (_ref) => {
  var {
    evaluate,
    parse: parse3
  } = _ref;
  function Parser() {
    if (!(this instanceof Parser)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    Object.defineProperty(this, "scope", {
      value: createEmptyMap(),
      writable: false
    });
  }
  Parser.prototype.type = "Parser";
  Parser.prototype.isParser = true;
  Parser.prototype.evaluate = function(expr) {
    return evaluate(expr, this.scope);
  };
  Parser.prototype.get = function(name226) {
    if (this.scope.has(name226)) {
      return this.scope.get(name226);
    }
  };
  Parser.prototype.getAll = function() {
    return toObject(this.scope);
  };
  Parser.prototype.getAllAsMap = function() {
    return this.scope;
  };
  function isValidVariableName(name226) {
    if (name226.length === 0) {
      return false;
    }
    for (var i = 0;i < name226.length; i++) {
      var cPrev = name226.charAt(i - 1);
      var c = name226.charAt(i);
      var cNext = name226.charAt(i + 1);
      var valid = parse3.isAlpha(c, cPrev, cNext) || i > 0 && parse3.isDigit(c);
      if (!valid) {
        return false;
      }
    }
    return true;
  }
  Parser.prototype.set = function(name226, value) {
    if (!isValidVariableName(name226)) {
      throw new Error("Invalid variable name: '".concat(name226, "'. Variable names must follow the specified rules."));
    }
    this.scope.set(name226, value);
    return value;
  };
  Parser.prototype.remove = function(name226) {
    this.scope.delete(name226);
  };
  Parser.prototype.clear = function() {
    this.scope.clear();
  };
  return Parser;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/expression/function/parser.js
var name226 = "parser";
var dependencies227 = ["typed", "Parser"];
var createParser = /* @__PURE__ */ factory(name226, dependencies227, (_ref) => {
  var {
    typed: typed2,
    Parser
  } = _ref;
  return typed2(name226, {
    "": function _() {
      return new Parser;
    }
  });
});
// node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
var name227 = "lup";
var dependencies228 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = /* @__PURE__ */ factory(name227, dependencies228, (_ref) => {
  var {
    typed: typed2,
    matrix,
    abs: abs2,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    larger,
    equalScalar,
    unaryMinus,
    DenseMatrix,
    SparseMatrix,
    Spa
  } = _ref;
  return typed2(name227, {
    DenseMatrix: function DenseMatrix(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix(m) {
      return _sparseLUP(m);
    },
    Array: function Array(a) {
      var m = matrix(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i, j, k;
    var p = [];
    for (i = 0;i < rows; i++) {
      p[i] = i;
    }
    for (j = 0;j < columns; j++) {
      if (j > 0) {
        for (i = 0;i < rows; i++) {
          var min2 = Math.min(i, j);
          var s = 0;
          for (k = 0;k < min2; k++) {
            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
          }
          data[i][j] = subtractScalar(data[i][j], s);
        }
      }
      var pi2 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i = j;i < rows; i++) {
        var v = data[i][j];
        var absv = abs2(v);
        if (larger(absv, pabsv)) {
          pi2 = i;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi2) {
        p[j] = [p[pi2], p[pi2] = p[j]][0];
        DenseMatrix._swapRows(j, pi2, data);
      }
      if (j < rows) {
        for (i = j + 1;i < rows; i++) {
          var vij = data[i][j];
          if (!equalScalar(vij, 0)) {
            data[i][j] = divideScalar(data[i][j], vjj);
          }
        }
      }
    }
    for (j = 0;j < columns; j++) {
      for (i = 0;i < rows; i++) {
        if (j === 0) {
          if (i < columns) {
            udata[i] = [];
          }
          ldata[i] = [];
        }
        if (i < j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 0;
          }
          continue;
        }
        if (i === j) {
          if (i < columns) {
            udata[i][j] = data[i][j];
          }
          if (j < rows) {
            ldata[i][j] = 1;
          }
          continue;
        }
        if (i < columns) {
          udata[i][j] = 0;
        }
        if (j < rows) {
          ldata[i][j] = data[i][j];
        }
      }
    }
    var l = new DenseMatrix({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i = 0, n = p.length;i < n; i++) {
      pv[p[i]] = i;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
P: ` + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i = 0;i < rows; i++) {
      pvCo[i] = i;
      pvOc[i] = i;
    }
    var swapIndeces = function swapIndeces(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop() {
      var spa = new Spa;
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0;k < k1; k++) {
        i = index[k];
        spa.set(pvCo[i], values[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix._forEachRow(k2, lvalues, lindex, lptr, function(i2, vik) {
            if (i2 > k2) {
              spa.accumulate(i2, unaryMinus(multiplyScalar(vik, vkj)));
            }
          });
        });
      }
      var pi2 = j;
      var vjj = spa.get(j);
      var pabsv = abs2(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v) {
        var absv = abs2(v);
        if (larger(absv, pabsv)) {
          pi2 = x;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi2) {
        SparseMatrix._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
        SparseMatrix._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi2);
        swapIndeces(j, pi2);
      }
      spa.forEach(0, rows - 1, function(x, v) {
        if (x <= j) {
          uvalues.push(v);
          uindex.push(x);
        } else {
          v = divideScalar(v, vjj);
          if (!equalScalar(v, 0)) {
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0;j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
P: ` + this.p;
      }
    };
  }
});
// node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
var name228 = "qr";
var dependencies229 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"];
var createQr = /* @__PURE__ */ factory(name228, dependencies229, (_ref) => {
  var {
    typed: typed2,
    matrix,
    zeros: zeros2,
    identity,
    isZero,
    equal,
    sign: sign3,
    sqrt: sqrt2,
    conj,
    unaryMinus,
    addScalar,
    divideScalar,
    multiplyScalar,
    subtractScalar,
    complex
  } = _ref;
  return _extends(typed2(name228, {
    DenseMatrix: function DenseMatrix(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix(m) {
      return _sparseQR(m);
    },
    Array: function Array(a) {
      var m = matrix(a);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q2 = identity([rows], "dense");
    var Qdata = Q2._data;
    var R = m.clone();
    var Rdata = R._data;
    var i, j, k;
    var w = zeros2([rows], "");
    for (k = 0;k < Math.min(cols, rows); ++k) {
      var pivot = Rdata[k][k];
      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign3(pivot));
      var conjSgn = conj(sgn);
      var alphaSquared = 0;
      for (i = k;i < rows; i++) {
        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
      }
      var alpha = multiplyScalar(sgn, sqrt2(alphaSquared));
      if (!isZero(alpha)) {
        var u1 = subtractScalar(pivot, alpha);
        w[k] = 1;
        for (i = k + 1;i < rows; i++) {
          w[i] = divideScalar(Rdata[i][k], u1);
        }
        var tau2 = unaryMinus(conj(divideScalar(u1, alpha)));
        var s = undefined;
        for (j = k;j < cols; j++) {
          s = 0;
          for (i = k;i < rows; i++) {
            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
          }
          s = multiplyScalar(s, tau2);
          for (i = k;i < rows; i++) {
            Rdata[i][j] = multiplyScalar(subtractScalar(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
          }
        }
        for (i = 0;i < rows; i++) {
          s = 0;
          for (j = k;j < rows; j++) {
            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
          }
          s = multiplyScalar(s, tau2);
          for (j = k;j < rows; ++j) {
            Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q: Q2,
      R,
      toString: function toString() {
        return "Q: " + this.Q.toString() + `
R: ` + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero = Rdata[0][0].type === "Complex" ? complex(0) : 0;
      for (var i = 0;i < Rdata.length; ++i) {
        for (var j = 0;j < i && j < (Rdata[0] || []).length; ++j) {
          Rdata[i][j] = zero;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});
// node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
function csPermute(a, pinv, q, values) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0;k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0;t < t1; t++) {
      var r = pinv ? pinv[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
function csTdfs(j, k, w, head, next, post, stack) {
  var top = 0;
  w[stack] = j;
  while (top >= 0) {
    var p = w[stack + top];
    var i = w[head + p];
    if (i === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i];
      ++top;
      w[stack + top] = i;
    }
  }
  return k;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0;j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1;j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0;j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i, inext;
  if (ata) {
    for (i = 0;i < m; i++) {
      w[prev + i] = -1;
    }
  }
  for (var k = 0;k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0;p < p1; p++) {
      var r = aindex[p];
      i = ata ? w[prev + r] : r;
      for (;i !== -1 && i < k; i = inext) {
        inext = w[ancestor + i];
        w[ancestor + i] = k;
        if (inext === -1) {
          parent[i] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0;j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (;p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
function csFlip(i) {
  return -i - 2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
var name229 = "csAmd";
var dependencies230 = ["add", "multiply", "transpose"];
var createCsAmd = /* @__PURE__ */ factory(name229, dependencies230, (_ref) => {
  var {
    add: add2,
    multiply,
    transpose
  } = _ref;
  return function csAmd(order, a) {
    if (!a || order <= 0 || order > 3) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P5 = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last = P5;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    var mindeg = 0;
    var i, j, k, k1, k2, e2, pj, ln2, nvi, pk, eln, p1, p2, pn, h, d;
    while (nel < n) {
      for (k = -1;mindeg < n && (k = W[head + mindeg]) === -1; mindeg++)
        ;
      if (W[next + k] !== -1) {
        last[W[next + k]] = -1;
      }
      W[head + mindeg] = W[next + k];
      var elenk = W[elen + k];
      var nvk = W[nv + k];
      nel += nvk;
      var dk = 0;
      W[nv + k] = -nvk;
      var p = cptr[k];
      var pk1 = elenk === 0 ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1;k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e2 = k;
          pj = p;
          ln2 = W[len + k] - elenk;
        } else {
          e2 = cindex[p++];
          pj = cptr[e2];
          ln2 = W[len + e2];
        }
        for (k2 = 1;k2 <= ln2; k2++) {
          i = cindex[pj++];
          if ((nvi = W[nv + i]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i] = -nvi;
          cindex[pk2++] = i;
          if (W[next + i] !== -1) {
            last[W[next + i]] = last[i];
          }
          if (last[i] !== -1) {
            W[next + last[i]] = W[next + i];
          } else {
            W[head + W[degree + i]] = W[next + i];
          }
        }
        if (e2 !== k) {
          cptr[e2] = csFlip(k);
          W[w + e2] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k] = dk;
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      W[elen + k] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        if ((eln = W[elen + i]) <= 0) {
          continue;
        }
        nvi = -W[nv + i];
        var wnvi = mark - nvi;
        for (p = cptr[i], p1 = cptr[i] + eln - 1;p <= p1; p++) {
          e2 = cindex[p];
          if (W[w + e2] >= mark) {
            W[w + e2] -= nvi;
          } else if (W[w + e2] !== 0) {
            W[w + e2] = W[degree + e2] + wnvi;
          }
        }
      }
      for (pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        p1 = cptr[i];
        p2 = p1 + W[elen + i] - 1;
        pn = p1;
        for (h = 0, d = 0, p = p1;p <= p2; p++) {
          e2 = cindex[p];
          if (W[w + e2] !== 0) {
            var dext = W[w + e2] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e2;
              h += e2;
            } else {
              cptr[e2] = csFlip(k);
              W[w + e2] = 0;
            }
          }
        }
        W[elen + i] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i];
        for (p = p2 + 1;p < p4; p++) {
          j = cindex[p];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h += j;
        }
        if (d === 0) {
          cptr[i] = csFlip(k);
          nvi = -W[nv + i];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i] = 0;
          W[elen + i] = -1;
        } else {
          W[degree + i] = Math.min(W[degree + i], d);
          cindex[pn] = cindex[p3];
          cindex[p3] = cindex[p1];
          cindex[p1] = k;
          W[len + i] = pn - p1 + 1;
          h = (h < 0 ? -h : h) % n;
          W[next + i] = W[hhead + h];
          W[hhead + h] = i;
          last[i] = h;
        }
      }
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        if (W[nv + i] >= 0) {
          continue;
        }
        h = last[i];
        i = W[hhead + h];
        W[hhead + h] = -1;
        for (;i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
          ln2 = W[len + i];
          eln = W[elen + i];
          for (p = cptr[i] + 1;p <= cptr[i] + ln2 - 1; p++) {
            W[w + cindex[p]] = mark;
          }
          var jlast = i;
          for (j = W[next + i];j !== -1; ) {
            var ok = W[len + j] === ln2 && W[elen + j] === eln;
            for (p = cptr[j] + 1;ok && p <= cptr[j] + ln2 - 1; p++) {
              if (W[w + cindex[p]] !== mark) {
                ok = 0;
              }
            }
            if (ok) {
              cptr[j] = csFlip(i);
              W[nv + i] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p = pk1, pk = pk1;pk < pk2; pk++) {
        i = cindex[pk];
        if ((nvi = -W[nv + i]) <= 0) {
          continue;
        }
        W[nv + i] = nvi;
        d = W[degree + i] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last[W[head + d]] = i;
        }
        W[next + i] = W[head + d];
        last[i] = -1;
        W[head + d] = i;
        mindeg = Math.min(mindeg, d);
        W[degree + i] = d;
        cindex[p++] = i;
      }
      W[nv + k] = nvk;
      if ((W[len + k] = p - pk1) === 0) {
        cptr[k] = -1;
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        cnz = p;
      }
    }
    for (i = 0;i < n; i++) {
      cptr[i] = csFlip(cptr[i]);
    }
    for (j = 0;j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n;j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e2 = n;e2 >= 0; e2--) {
      if (W[nv + e2] <= 0) {
        continue;
      }
      if (cptr[e2] !== -1) {
        W[next + e2] = W[head + cptr[e2]];
        W[head + cptr[e2]] = e2;
      }
    }
    for (k = 0, i = 0;i <= n; i++) {
      if (cptr[i] === -1) {
        k = csTdfs(i, k, W, head, next, P5, w);
      }
    }
    P5.splice(P5.length - 1, 1);
    return P5;
  };
  function _createTargetMatrix(order, a, m, n, dense) {
    var at = transpose(a);
    if (order === 1 && n === m) {
      return add2(a, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0;j < m; j++) {
        var p = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1];p < p1; p++) {
          tindex[p2++] = tindex[p];
        }
      }
      tptr[m] = p2;
      a = transpose(at);
      return multiply(at, a);
    }
    return multiply(at, a);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    for (var k = 0;k < n; k++) {
      W[len + k] = cptr[k + 1] - cptr[k];
    }
    W[len + n] = 0;
    for (var i = 0;i <= n; i++) {
      W[head + i] = -1;
      last[i] = -1;
      W[next + i] = -1;
      W[hhead + i] = -1;
      W[nv + i] = 1;
      W[w + i] = 1;
      W[elen + i] = 0;
      W[degree + i] = W[len + i];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    var nel = 0;
    for (var i = 0;i < n; i++) {
      var d = W[degree + i];
      if (d === 0) {
        W[elen + i] = -2;
        nel++;
        cptr[i] = -1;
        W[w + i] = 0;
      } else if (d > dense) {
        W[nv + i] = 0;
        W[elen + i] = -1;
        nel++;
        cptr[i] = csFlip(n);
        W[nv + n]++;
      } else {
        var h = W[head + d];
        if (h !== -1) {
          last[h] = i;
        }
        W[next + i] = W[head + d];
        W[head + d] = i;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k = 0;k < n; k++) {
        if (W[w + k] !== 0) {
          W[w + k] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i, j) {
    return i !== j;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i <= j || w[first + j] <= w[maxfirst + i]) {
    return -1;
  }
  w[maxfirst + i] = w[first + j];
  var jprev = w[prevleaf + i];
  w[prevleaf + i] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i;
  } else {
    jleaf = 2;
    for (q = jprev;q !== w[ancestor + q]; q = w[ancestor + q])
      ;
    for (s = jprev;s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
var name230 = "csCounts";
var dependencies231 = ["transpose"];
var createCsCounts = /* @__PURE__ */ factory(name230, dependencies231, (_ref) => {
  var {
    transpose
  } = _ref;
  return function(a, parent, post, ata) {
    if (!a || !parent || !post) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var i, j, k, J, p, p0, p1;
    var s = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k = 0;k < s; k++) {
      w[k] = -1;
    }
    var colcount = [];
    var at = transpose(a);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k = 0;k < n; k++) {
      j = post[k];
      colcount[j] = w[first + j] === -1 ? 1 : 0;
      for (;j !== -1 && w[first + j] === -1; j = parent[j]) {
        w[first + j] = k;
      }
    }
    if (ata) {
      for (k = 0;k < n; k++) {
        w[post[k]] = k;
      }
      for (i = 0;i < m; i++) {
        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0;p < p1; p++) {
          k = Math.min(k, w[tindex[p]]);
        }
        w[next + i] = w[head + k];
        w[head + k] = i;
      }
    }
    for (i = 0;i < n; i++) {
      w[ancestor + i] = i;
    }
    for (k = 0;k < n; k++) {
      j = post[k];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k] : j;J !== -1; J = ata ? w[next + J] : -1) {
        for (p = tptr[J];p < tptr[J + 1]; p++) {
          i = tindex[p];
          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0;j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
var name231 = "csSqr";
var dependencies232 = ["add", "multiply", "transpose"];
var createCsSqr = /* @__PURE__ */ factory(name231, dependencies232, (_ref) => {
  var {
    add: add2,
    multiply,
    transpose
  } = _ref;
  var csAmd = createCsAmd({
    add: add2,
    multiply,
    transpose
  });
  var csCounts = createCsCounts({
    transpose
  });
  return function csSqr(order, a, qr) {
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var k;
    var s = {};
    s.q = csAmd(order, a);
    if (order && !s.q) {
      return null;
    }
    if (qr) {
      var c = order ? csPermute(a, null, s.q, 0) : a;
      s.parent = csEtree(c, 1);
      var post = csPost(s.parent, n);
      s.cp = csCounts(c, s.parent, post, 1);
      if (c && s.parent && s.cp && _vcount(c, s)) {
        for (s.unz = 0, k = 0;k < n; k++) {
          s.unz += s.cp[k];
        }
      }
    } else {
      s.unz = 4 * aptr[n] + n;
      s.lnz = s.unz;
    }
    return s;
  };
  function _vcount(a, s) {
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    s.pinv = [];
    s.leftmost = [];
    var parent = s.parent;
    var pinv = s.pinv;
    var leftmost = s.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i, k, p, p0, p1;
    for (k = 0;k < n; k++) {
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    for (i = 0;i < m; i++) {
      leftmost[i] = -1;
    }
    for (k = n - 1;k >= 0; k--) {
      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0;p < p1; p++) {
        leftmost[aindex[p]] = k;
      }
    }
    for (i = m - 1;i >= 0; i--) {
      pinv[i] = -1;
      k = leftmost[i];
      if (k === -1) {
        continue;
      }
      if (w[nque + k]++ === 0) {
        w[tail + k] = i;
      }
      w[next + i] = w[head + k];
      w[head + k] = i;
    }
    s.lnz = 0;
    s.m2 = m;
    for (k = 0;k < n; k++) {
      i = w[head + k];
      s.lnz++;
      if (i < 0) {
        i = s.m2++;
      }
      pinv[i] = k;
      if (--nque[k] <= 0) {
        continue;
      }
      s.lnz += w[nque + k];
      var pa = parent[k];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k];
        }
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i = 0;i < m; i++) {
      if (pinv[i] < 0) {
        pinv[i] = k++;
      }
    }
    return true;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
function csMarked(w, j) {
  return w[j] < 0;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
function csUnflip(i) {
  return i < 0 ? csFlip(i) : i;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
function csDfs(j, g, top, xi, pinv) {
  var index = g._index;
  var ptr = g._ptr;
  var size = g._size;
  var n = size[1];
  var i, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv ? pinv[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]);p < p2; p++) {
      i = index[p];
      if (csMarked(ptr, i)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
function csReach(g, b, k, xi, pinv) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0;p < p1; p++) {
    var i = bindex[p];
    if (!csMarked(gptr, i)) {
      top = csDfs(i, g, top, xi, pinv);
    }
  }
  for (p = top;p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
var name232 = "csSpsolve";
var dependencies233 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = /* @__PURE__ */ factory(name232, dependencies233, (_ref) => {
  var {
    divideScalar,
    multiply,
    subtract
  } = _ref;
  return function csSpsolve(g, b, k, xi, x, pinv, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p, p0, p1, q;
    var top = csReach(g, b, k, xi, pinv);
    for (p = top;p < n; p++) {
      x[xi[p]] = 0;
    }
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0;p < p1; p++) {
      x[bindex[p]] = bvalues[p];
    }
    for (var px = top;px < n; px++) {
      var j = xi[px];
      var J = pinv ? pinv[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
      p = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (;p < q; p++) {
        var i = gindex[p];
        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
      }
    }
    return top;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
var name233 = "csLu";
var dependencies234 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = /* @__PURE__ */ factory(name233, dependencies234, (_ref) => {
  var {
    abs: abs2,
    divideScalar,
    multiply,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  } = _ref;
  var csSpsolve = createCsSpsolve({
    divideScalar,
    multiply,
    subtract
  });
  return function csLu(m, s, tol) {
    if (!m) {
      return null;
    }
    var size = m._size;
    var n = size[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv = [];
    var i, p;
    var x = [];
    var xi = [];
    for (i = 0;i < n; i++) {
      x[i] = 0;
      pinv[i] = -1;
      lptr[i + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k = 0;k < n; k++) {
      lptr[k] = lnz;
      uptr[k] = unz;
      var col = q ? q[k] : k;
      var top = csSpsolve(L, m, col, xi, x, pinv, 1);
      var ipiv = -1;
      var a = -1;
      for (p = top;p < n; p++) {
        i = xi[p];
        if (pinv[i] < 0) {
          var xabs = abs2(x[i]);
          if (larger(xabs, a)) {
            a = xabs;
            ipiv = i;
          }
        } else {
          uindex[unz] = pinv[i];
          uvalues[unz++] = x[i];
        }
      }
      if (ipiv === -1 || a <= 0) {
        return null;
      }
      if (pinv[col] < 0 && largerEq(abs2(x[col]), multiply(a, tol))) {
        ipiv = col;
      }
      var pivot = x[ipiv];
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      pinv[ipiv] = k;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p = top;p < n; p++) {
        i = xi[p];
        if (pinv[i] < 0) {
          lindex[lnz] = i;
          lvalues[lnz++] = divideScalar(x[i], pivot);
        }
        x[i] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p = 0;p < lnz; p++) {
      lindex[p] = pinv[lindex[p]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv
    };
  };
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
var name234 = "slu";
var dependencies235 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = /* @__PURE__ */ factory(name234, dependencies235, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply,
    transpose,
    divideScalar,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  } = _ref;
  var csSqr = createCsSqr({
    add: add2,
    multiply,
    transpose
  });
  var csLu = createCsLu({
    abs: abs2,
    divideScalar,
    multiply,
    subtract,
    larger,
    largerEq,
    SparseMatrix
  });
  return typed2(name234, {
    "SparseMatrix, number, number": function SparseMatrix_number_number(a, order, threshold) {
      if (!isInteger(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold < 0 || threshold > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s = csSqr(order, a, false);
      var f = csLu(a, s, threshold);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function toString() {
          return "L: " + this.L.toString() + `
U: ` + this.U.toString() + `
p: ` + this.p.toString() + (this.q ? `
q: ` + this.q.toString() : "") + `
`;
        }
      };
    }
  });
});
// node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
function csIpvec(p, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p) {
    for (k = 0;k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0;k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
var name235 = "lusolve";
var dependencies236 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = /* @__PURE__ */ factory(name235, dependencies236, (_ref) => {
  var {
    typed: typed2,
    matrix,
    lup,
    slu,
    usolve,
    lsolve,
    DenseMatrix
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix
  });
  return typed2(name235, {
    "Array, Array | Matrix": function Array_Array__Matrix(a, b) {
      a = matrix(a);
      var d = lup(a);
      var x = _lusolve(d.L, d.U, d.p, null, b);
      return x.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrix_Array__Matrix(a, b) {
      var d = lup(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrix_Array__Matrix(a, b) {
      var d = lup(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrix_Array__Matrix_number_number(a, b, order, threshold) {
      var d = slu(a, order, threshold);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function Object_Array__Matrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a) {
    if (isMatrix(a)) {
      return a;
    }
    if (isArray(a)) {
      return matrix(a);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p) {
      b = solveValidation(l, b, true);
      b._data = csIpvec(p, b._data);
    }
    var y = lsolve(l, b);
    var x = usolve(u, y);
    if (q) {
      x._data = csIpvec(q, x._data);
    }
    return x;
  }
});
// node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
var name236 = "polynomialRoot";
var dependencies237 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
var createPolynomialRoot = /* @__PURE__ */ factory(name236, dependencies237, (_ref) => {
  var {
    typed: typed2,
    isZero,
    equalScalar,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    sqrt: sqrt2,
    unaryMinus,
    cbrt: cbrt4,
    typeOf: typeOf2,
    im,
    re
  } = _ref;
  return typed2(name236, {
    "number|Complex, ...number|Complex": (constant, restCoeffs) => {
      var coeffs = [constant, ...restCoeffs];
      while (coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])) {
        coeffs.pop();
      }
      if (coeffs.length < 2) {
        throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
      }
      switch (coeffs.length) {
        case 2:
          return [unaryMinus(divide2(coeffs[0], coeffs[1]))];
        case 3: {
          var [c, b, a] = coeffs;
          var denom = multiply(2, a);
          var d1 = multiply(b, b);
          var d2 = multiply(4, a, c);
          if (equalScalar(d1, d2))
            return [divide2(unaryMinus(b), denom)];
          var discriminant = sqrt2(subtract(d1, d2));
          return [divide2(subtract(discriminant, b), denom), divide2(subtract(unaryMinus(discriminant), b), denom)];
        }
        case 4: {
          var [d, _c, _b, _a] = coeffs;
          var _denom = unaryMinus(multiply(3, _a));
          var D0_1 = multiply(_b, _b);
          var D0_2 = multiply(3, _a, _c);
          var D1_1 = add2(multiply(2, _b, _b, _b), multiply(27, _a, _a, d));
          var D1_2 = multiply(9, _a, _b, _c);
          if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {
            return [divide2(_b, _denom)];
          }
          var Delta0 = subtract(D0_1, D0_2);
          var Delta1 = subtract(D1_1, D1_2);
          var discriminant1 = add2(multiply(18, _a, _b, _c, d), multiply(_b, _b, _c, _c));
          var discriminant2 = add2(multiply(4, _b, _b, _b, d), multiply(4, _a, _c, _c, _c), multiply(27, _a, _a, d, d));
          if (equalScalar(discriminant1, discriminant2)) {
            return [
              divide2(subtract(multiply(4, _a, _b, _c), add2(multiply(9, _a, _a, d), multiply(_b, _b, _b))), multiply(_a, Delta0)),
              divide2(subtract(multiply(9, _a, d), multiply(_b, _c)), multiply(2, Delta0))
            ];
          }
          var Ccubed;
          if (equalScalar(D0_1, D0_2)) {
            Ccubed = Delta1;
          } else {
            Ccubed = divide2(add2(Delta1, sqrt2(subtract(multiply(Delta1, Delta1), multiply(4, Delta0, Delta0, Delta0)))), 2);
          }
          var allRoots = true;
          var rawRoots = cbrt4(Ccubed, allRoots).toArray().map((C) => divide2(add2(_b, C, divide2(Delta0, C)), _denom));
          return rawRoots.map((r) => {
            if (typeOf2(r) === "Complex" && equalScalar(re(r), re(r) + im(r))) {
              return re(r);
            }
            return r;
          });
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
      }
    }
  });
});
// node_modules/mathjs/lib/esm/expression/Help.js
var name237 = "Help";
var dependencies238 = ["evaluate"];
var createHelpClass = /* @__PURE__ */ factory(name237, dependencies238, (_ref) => {
  var {
    evaluate
  } = _ref;
  function Help(doc) {
    if (!(this instanceof Help)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (!doc)
      throw new Error('Argument "doc" missing');
    this.doc = doc;
  }
  Help.prototype.type = "Help";
  Help.prototype.isHelp = true;
  Help.prototype.toString = function() {
    var doc = this.doc || {};
    var desc = `
`;
    if (doc.name) {
      desc += "Name: " + doc.name + `

`;
    }
    if (doc.category) {
      desc += "Category: " + doc.category + `

`;
    }
    if (doc.description) {
      desc += `Description:
    ` + doc.description + `

`;
    }
    if (doc.syntax) {
      desc += `Syntax:
    ` + doc.syntax.join(`
    `) + `

`;
    }
    if (doc.examples) {
      desc += `Examples:
`;
      var configChanged = false;
      var originalConfig = evaluate("config()");
      var scope = {
        config: (newConfig) => {
          configChanged = true;
          return evaluate("config(newConfig)", {
            newConfig
          });
        }
      };
      for (var i = 0;i < doc.examples.length; i++) {
        var expr = doc.examples[i];
        desc += "    " + expr + `
`;
        var res = undefined;
        try {
          res = evaluate(expr, scope);
        } catch (e2) {
          res = e2;
        }
        if (res !== undefined && !isHelp(res)) {
          desc += "        " + format3(res, {
            precision: 14
          }) + `
`;
        }
      }
      desc += `
`;
      if (configChanged) {
        evaluate("config(originalConfig)", {
          originalConfig
        });
      }
    }
    if (doc.mayThrow && doc.mayThrow.length) {
      desc += "Throws: " + doc.mayThrow.join(", ") + `

`;
    }
    if (doc.seealso && doc.seealso.length) {
      desc += "See also: " + doc.seealso.join(", ") + `
`;
    }
    return desc;
  };
  Help.prototype.toJSON = function() {
    var obj = clone(this.doc);
    obj.mathjs = "Help";
    return obj;
  };
  Help.fromJSON = function(json) {
    var doc = {};
    Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
      doc[prop] = json[prop];
    });
    return new Help(doc);
  };
  Help.prototype.valueOf = Help.prototype.toString;
  return Help;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/type/chain/Chain.js
var name238 = "Chain";
var dependencies239 = ["?on", "math", "typed"];
var createChainClass = /* @__PURE__ */ factory(name238, dependencies239, (_ref) => {
  var {
    on,
    math,
    typed: typed2
  } = _ref;
  function Chain(value) {
    if (!(this instanceof Chain)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (isChain(value)) {
      this.value = value.value;
    } else {
      this.value = value;
    }
  }
  Chain.prototype.type = "Chain";
  Chain.prototype.isChain = true;
  Chain.prototype.done = function() {
    return this.value;
  };
  Chain.prototype.valueOf = function() {
    return this.value;
  };
  Chain.prototype.toString = function() {
    return format3(this.value);
  };
  Chain.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  };
  Chain.fromJSON = function(json) {
    return new Chain(json.value);
  };
  function createProxy(name239, fn) {
    if (typeof fn === "function") {
      Chain.prototype[name239] = chainify(fn);
    }
  }
  function createLazyProxy(name239, resolver) {
    lazy(Chain.prototype, name239, function outerResolver() {
      var fn = resolver();
      if (typeof fn === "function") {
        return chainify(fn);
      }
      return;
    });
  }
  function chainify(fn) {
    return function() {
      if (arguments.length === 0) {
        return new Chain(fn(this.value));
      }
      var args = [this.value];
      for (var i = 0;i < arguments.length; i++) {
        args[i + 1] = arguments[i];
      }
      if (typed2.isTypedFunction(fn)) {
        var sigObject = typed2.resolve(fn, args);
        if (sigObject.params.length === 1) {
          throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
        }
        return new Chain(sigObject.implementation.apply(fn, args));
      }
      return new Chain(fn.apply(fn, args));
    };
  }
  Chain.createProxy = function(arg0, arg1) {
    if (typeof arg0 === "string") {
      createProxy(arg0, arg1);
    } else {
      var _loop = function _loop(_name2) {
        if (hasOwnProperty(arg0, _name2) && excludedNames[_name2] === undefined) {
          createLazyProxy(_name2, () => arg0[_name2]);
        }
      };
      for (var _name in arg0) {
        _loop(_name);
      }
    }
  };
  var excludedNames = {
    expression: true,
    docs: true,
    type: true,
    classes: true,
    json: true,
    error: true,
    isChain: true
  };
  Chain.createProxy(math);
  if (on) {
    on("import", function(name239, resolver, path) {
      if (!path) {
        createLazyProxy(name239, resolver);
      }
    });
  }
  return Chain;
}, {
  isClass: true
});
// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
var eDocs = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
var falseDocs = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
var iDocs = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
var InfinityDocs = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
var LN10Docs = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
var LN2Docs = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
var LOG10EDocs = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
var LOG2EDocs = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
var NaNDocs = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
var nullDocs = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
var phiDocs = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
var piDocs = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
var SQRT12Docs = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
var SQRT2Docs = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
var tauDocs = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
var trueDocs = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
var versionDocs = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
var bignumberDocs = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "bigint", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bigint.js
var bigintDocs = {
  name: "bigint",
  category: "Construction",
  syntax: ["bigint(x)"],
  description: "Create a bigint, an integer with an arbitrary number of digits, from a number or string.",
  examples: ["123123123123123123 # a large number will lose digits", 'bigint("123123123123123123")', 'bignumber(["1", "3", "5"])'],
  seealso: ["boolean", "bignumber", "number", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
var booleanDocs = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
var complexDocs = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
var createUnitDocs = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
var fractionDocs = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
var indexDocs = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
var matrixDocs = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
var numberDocs = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "bigint", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
var sparseDocs = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
var splitUnitDocs = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
var stringDocs = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
var unitDocs = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
var configDocs = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
var importDocs = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
var typedDocs = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
var derivativeDocs = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
var leafCountDocs = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
var lsolveDocs = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
var lsolveAllDocs = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
var lupDocs = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
var lusolveDocs = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/polynomialRoot.js
var polynomialRootDocs = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
  seealso: ["cbrt", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
var qrDocs = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
var rationalizeDocs = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
var resolveDocs = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
var simplifyDocs = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js
var simplifyConstantDocs = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
var simplifyCoreDocs = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
var sluDocs = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
var symbolicEqualDocs = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
var usolveDocs = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
var usolveAllDocs = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
var absDocs = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
var addDocs = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
var cbrtDocs = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
var ceilDocs = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)", "ceil(x, n)", "ceil(unit, valuelessUnit)", "ceil(unit, n, valuelessUnit)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)", "ceil(3.241cm, cm)", "ceil(3.241cm, 2, cm)"],
  seealso: ["floor", "fix", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
var cubeDocs = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
var divideDocs = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
var dotDivideDocs = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
var dotMultiplyDocs = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
var dotPowDocs = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
var expDocs = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
  seealso: ["expm", "expm1", "pow", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
var expmDocs = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. " + "The matrix must be square. " + "Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
var expm1Docs = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
var fixDocs = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)", "fix(x, n)", "fix(unit, valuelessUnit)", "fix(unit, n, valuelessUnit)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)", "fix(3.241cm, cm)", "fix(3.241cm, 2, cm)"],
  seealso: ["ceil", "floor", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
var floorDocs = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)", "floor(x, n)", "floor(unit, valuelessUnit)", "floor(unit, n, valuelessUnit)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)", "floor(3.241cm, cm)", "floor(3.241cm, 2, cm)"],
  seealso: ["ceil", "fix", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
var gcdDocs = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
var hypotDocs = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenuse of a list with values.",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
var invmodDocs = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)",
  examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
  seealso: ["gcd", "xgcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
var lcmDocs = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
var logDocs = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
var log10Docs = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
var log1pDocs = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
var log2Docs = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
var modDocs = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
var multiplyDocs = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
var normDocs = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
var nthRootDocs = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: "Calculate the nth root of a value. " + "The principal nth root of a positive real number A, " + 'is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
var nthRootsDocs = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: "" + "Calculate the nth roots of a value. " + "An nth root of a positive real number A, " + 'is a positive real solution of the equation "x^root = A". ' + "This function returns an array of complex values.",
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
var powDocs = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
var roundDocs = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)", "round(unit, valuelessUnit)", "round(unit, n, valuelessUnit)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)", "round(3.241cm, 2, cm)", "round([3.2, 3.8, -4.7])"],
  seealso: ["ceil", "floor", "fix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
var signDocs = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>0, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
var sqrtDocs = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
var sqrtmDocs = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/sylvester.js
var sylvesterDocs = {
  name: "sylvester",
  category: "Algebra",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
  seealso: ["schur", "lyap"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/schur.js
var schurDocs = {
  name: "schur",
  category: "Algebra",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU'",
  examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
  seealso: ["lyap", "sylvester"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lyap.js
var lyapDocs = {
  name: "lyap",
  category: "Algebra",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
  examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
  seealso: ["schur", "sylvester"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
var squareDocs = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
var subtractDocs = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
var unaryMinusDocs = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
var unaryPlusDocs = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
var xgcdDocs = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
var bitAndDocs = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
var bitNotDocs = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
var bitOrDocs = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
var bitXorDocs = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
var leftShiftDocs = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
var rightArithShiftDocs = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
var rightLogShiftDocs = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
var bellNumbersDocs = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
var catalanDocs = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
var compositionDocs = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
var stirlingS2Docs = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
var argDocs = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
var conjDocs = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
var imDocs = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
var reDocs = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
var evaluateDocs = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
var helpDocs = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
var distanceDocs = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
var intersectDocs = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
var andDocs = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
var notDocs = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
var orDocs = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
var xorDocs = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/mapSlices.js
var mapSlicesDocs = {
  name: "mapSlices",
  category: "Matrix",
  syntax: ["mapSlices(A, dim, callback)"],
  description: "Generate a matrix one dimension less than A by applying callback to " + "each slice of A along dimension dim.",
  examples: [
    "A = [[1, 2], [3, 4]]",
    "mapSlices(A, 1, sum)",
    "mapSlices(A, 2, product)"
  ],
  seealso: ["map", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
var columnDocs = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
var concatDocs = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
var countDocs = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
var crossDocs = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
var ctransposeDocs = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
var detDocs = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
var diagDocs = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
var diffDocs = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicate the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
  seealso: ["subtract", "partitionSelect"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
var dotDocs = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. " + "The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] " + "is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
var eigsDocs = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])", "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"],
  seealso: ["inv"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
var filterDocs = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
var flattenDocs = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
var forEachDocs = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
var getMatrixDataTypeDocs = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: "Find the data type of all elements in a matrix or array, " + 'for example "number" if all items are a number ' + 'and "Complex" if all values are complex numbers. ' + 'If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
var identityDocs = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
var invDocs = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
var pinvDocs = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore–Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
var kronDocs = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the Kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
var mapDocs = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)", "map(x, y, ..., callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array or the matrices/arrays.",
  examples: ["map([1, 2, 3], square)", "map([1, 2], [3, 4], f(a,b) = a + b)"],
  seealso: ["filter", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
var matrixFromColumnsDocs = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
var matrixFromFunctionDocs = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
var matrixFromRowsDocs = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
var onesDocs = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
var partitionSelectDocs = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
  seealso: ["sort"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
var rangeDocs = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
var reshapeDocs = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
  seealso: ["size", "squeeze", "resize"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
var resizeDocs = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
var rotateDocs = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). " + "Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
var rotationMatrixDocs = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). " + "Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
var rowDocs = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
var sizeDocs = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
var sortDocs = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
var squeezeDocs = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
var subsetDocs = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or " + "characters of a string. " + "Indexes are one-based. There should be one index specification for " + "each dimension of the target. Each specification can be a single " + "index, a list of indices, or a range in colon notation `l:u`. " + "In a range, both the lower bound l and upper bound u are included; " + "and if a bound is omitted it defaults to the most extreme valid value. " + "The cartesian product of the indices specified in each dimension " + "determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
var traceDocs = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
var transposeDocs = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
var zerosDocs = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
var fftDocs = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional Fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
var ifftDocs = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse Fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
var combinationsDocs = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
var combinationsWithRepDocs = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
var factorialDocs = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
var gammaDocs = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
var lgammaDocs = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, " + "using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
var kldivergenceDocs = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
var multinomialDocs = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
var permutationsDocs = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
var pickRandomDocs = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
var randomDocs = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
var randomIntDocs = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
var compareDocs = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. " + "Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
var compareNaturalDocs = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. " + "Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
var compareTextDocs = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. " + "Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
var deepEqualDocs = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
var equalDocs = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
var equalTextDocs = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
var largerDocs = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
var largerEqDocs = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
var smallerDocs = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
var smallerEqDocs = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
var unequalDocs = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
var setCartesianDocs = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
var setDifferenceDocs = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
var setDistinctDocs = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
var setIntersectDocs = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
var setIsSubsetDocs = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
var setMultiplicityDocs = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
var setPowersetDocs = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
var setSizeDocs = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
var setSymDifferenceDocs = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
var setUnionDocs = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/zpk2tf.js
var zpk2tfDocs = {
  name: "zpk2tf",
  category: "Signal",
  syntax: ["zpk2tf(z, p, k)"],
  description: "Compute the transfer function of a zero-pole-gain model.",
  examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/freqz.js
var freqzDocs = {
  name: "freqz",
  category: "Signal",
  syntax: ["freqz(b, a)", "freqz(b, a, w)"],
  description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
  examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
var erfDocs = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/zeta.js
var zetaDocs = {
  name: "zeta",
  category: "Special",
  syntax: ["zeta(s)"],
  description: "Compute the Riemann Zeta Function using an infinite series and Riemann's Functional Equation for the entire complex plane",
  examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
var madDocs = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
var maxDocs = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
var meanDocs = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
var medianDocs = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
var minDocs = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
var modeDocs = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
var prodDocs = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
var quantileSeqDocs = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: `Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probability are: Number, BigNumber. 

In case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.`,
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
var stdDocs = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
var cumSumDocs = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
var sumDocs = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
var varianceDocs = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/corr.js
var corrDocs = {
  name: "corr",
  category: "Statistics",
  syntax: ["corr(A,B)"],
  description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
  examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
var acosDocs = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
var acoshDocs = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
var acotDocs = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
var acothDocs = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the inverse hyperbolic tangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
var acscDocs = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
var acschDocs = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the inverse hyperbolic cosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
var asecDocs = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
var asechDocs = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
var asinDocs = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
var asinhDocs = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
var atanDocs = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
var atan2Docs = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
var atanhDocs = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
var cosDocs = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
var coshDocs = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
var cotDocs = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
var cothDocs = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
var cscDocs = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
var cschDocs = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
var secDocs = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
var sechDocs = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
var sinDocs = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
var sinhDocs = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
var tanDocs = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
var tanhDocs = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
var toDocs = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
var binDocs = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
var cloneDocs = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables, and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
var formatDocs = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
var hasNumericValueDocs = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. " + "In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
var hexDocs = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
var isIntegerDocs = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
var isNaNDocs = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
var isNegativeDocs = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
var isNumericDocs = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. " + "Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
var isPositiveDocs = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
var isPrimeDocs = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
var isZeroDocs = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
var numericDocs = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "bigint")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
  seealso: ["number", "bigint", "fraction", "bignumber", "string", "format"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
var octDocs = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
var printDocs = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
  seealso: ["format"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
var typeOfDocs = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/numeric/solveODE.js
var solveODEDocs = {
  name: "solveODE",
  category: "Numeric",
  syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
  description: "Numerical Integration of Ordinary Differential Equations.",
  examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
  seealso: ["derivative", "simplifyCore"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
var embeddedDocs = {
  bignumber: bignumberDocs,
  bigint: bigintDocs,
  boolean: booleanDocs,
  complex: complexDocs,
  createUnit: createUnitDocs,
  fraction: fractionDocs,
  index: indexDocs,
  matrix: matrixDocs,
  number: numberDocs,
  sparse: sparseDocs,
  splitUnit: splitUnitDocs,
  string: stringDocs,
  unit: unitDocs,
  e: eDocs,
  E: eDocs,
  false: falseDocs,
  i: iDocs,
  Infinity: InfinityDocs,
  LN2: LN2Docs,
  LN10: LN10Docs,
  LOG2E: LOG2EDocs,
  LOG10E: LOG10EDocs,
  NaN: NaNDocs,
  null: nullDocs,
  pi: piDocs,
  PI: piDocs,
  phi: phiDocs,
  SQRT1_2: SQRT12Docs,
  SQRT2: SQRT2Docs,
  tau: tauDocs,
  true: trueDocs,
  version: versionDocs,
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Bohr magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Bohr radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro's number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  derivative: derivativeDocs,
  lsolve: lsolveDocs,
  lsolveAll: lsolveAllDocs,
  lup: lupDocs,
  lusolve: lusolveDocs,
  leafCount: leafCountDocs,
  polynomialRoot: polynomialRootDocs,
  resolve: resolveDocs,
  simplify: simplifyDocs,
  simplifyConstant: simplifyConstantDocs,
  simplifyCore: simplifyCoreDocs,
  symbolicEqual: symbolicEqualDocs,
  rationalize: rationalizeDocs,
  slu: sluDocs,
  usolve: usolveDocs,
  usolveAll: usolveAllDocs,
  qr: qrDocs,
  abs: absDocs,
  add: addDocs,
  cbrt: cbrtDocs,
  ceil: ceilDocs,
  cube: cubeDocs,
  divide: divideDocs,
  dotDivide: dotDivideDocs,
  dotMultiply: dotMultiplyDocs,
  dotPow: dotPowDocs,
  exp: expDocs,
  expm: expmDocs,
  expm1: expm1Docs,
  fix: fixDocs,
  floor: floorDocs,
  gcd: gcdDocs,
  hypot: hypotDocs,
  lcm: lcmDocs,
  log: logDocs,
  log2: log2Docs,
  log1p: log1pDocs,
  log10: log10Docs,
  mod: modDocs,
  multiply: multiplyDocs,
  norm: normDocs,
  nthRoot: nthRootDocs,
  nthRoots: nthRootsDocs,
  pow: powDocs,
  round: roundDocs,
  sign: signDocs,
  sqrt: sqrtDocs,
  sqrtm: sqrtmDocs,
  square: squareDocs,
  subtract: subtractDocs,
  unaryMinus: unaryMinusDocs,
  unaryPlus: unaryPlusDocs,
  xgcd: xgcdDocs,
  invmod: invmodDocs,
  bitAnd: bitAndDocs,
  bitNot: bitNotDocs,
  bitOr: bitOrDocs,
  bitXor: bitXorDocs,
  leftShift: leftShiftDocs,
  rightArithShift: rightArithShiftDocs,
  rightLogShift: rightLogShiftDocs,
  bellNumbers: bellNumbersDocs,
  catalan: catalanDocs,
  composition: compositionDocs,
  stirlingS2: stirlingS2Docs,
  config: configDocs,
  import: importDocs,
  typed: typedDocs,
  arg: argDocs,
  conj: conjDocs,
  re: reDocs,
  im: imDocs,
  evaluate: evaluateDocs,
  help: helpDocs,
  distance: distanceDocs,
  intersect: intersectDocs,
  and: andDocs,
  not: notDocs,
  or: orDocs,
  xor: xorDocs,
  mapSlices: mapSlicesDocs,
  concat: concatDocs,
  count: countDocs,
  cross: crossDocs,
  column: columnDocs,
  ctranspose: ctransposeDocs,
  det: detDocs,
  diag: diagDocs,
  diff: diffDocs,
  dot: dotDocs,
  getMatrixDataType: getMatrixDataTypeDocs,
  identity: identityDocs,
  filter: filterDocs,
  flatten: flattenDocs,
  forEach: forEachDocs,
  inv: invDocs,
  pinv: pinvDocs,
  eigs: eigsDocs,
  kron: kronDocs,
  matrixFromFunction: matrixFromFunctionDocs,
  matrixFromRows: matrixFromRowsDocs,
  matrixFromColumns: matrixFromColumnsDocs,
  map: mapDocs,
  ones: onesDocs,
  partitionSelect: partitionSelectDocs,
  range: rangeDocs,
  resize: resizeDocs,
  reshape: reshapeDocs,
  rotate: rotateDocs,
  rotationMatrix: rotationMatrixDocs,
  row: rowDocs,
  size: sizeDocs,
  sort: sortDocs,
  squeeze: squeezeDocs,
  subset: subsetDocs,
  trace: traceDocs,
  transpose: transposeDocs,
  zeros: zerosDocs,
  fft: fftDocs,
  ifft: ifftDocs,
  sylvester: sylvesterDocs,
  schur: schurDocs,
  lyap: lyapDocs,
  solveODE: solveODEDocs,
  combinations: combinationsDocs,
  combinationsWithRep: combinationsWithRepDocs,
  factorial: factorialDocs,
  gamma: gammaDocs,
  kldivergence: kldivergenceDocs,
  lgamma: lgammaDocs,
  multinomial: multinomialDocs,
  permutations: permutationsDocs,
  pickRandom: pickRandomDocs,
  random: randomDocs,
  randomInt: randomIntDocs,
  compare: compareDocs,
  compareNatural: compareNaturalDocs,
  compareText: compareTextDocs,
  deepEqual: deepEqualDocs,
  equal: equalDocs,
  equalText: equalTextDocs,
  larger: largerDocs,
  largerEq: largerEqDocs,
  smaller: smallerDocs,
  smallerEq: smallerEqDocs,
  unequal: unequalDocs,
  setCartesian: setCartesianDocs,
  setDifference: setDifferenceDocs,
  setDistinct: setDistinctDocs,
  setIntersect: setIntersectDocs,
  setIsSubset: setIsSubsetDocs,
  setMultiplicity: setMultiplicityDocs,
  setPowerset: setPowersetDocs,
  setSize: setSizeDocs,
  setSymDifference: setSymDifferenceDocs,
  setUnion: setUnionDocs,
  zpk2tf: zpk2tfDocs,
  freqz: freqzDocs,
  erf: erfDocs,
  zeta: zetaDocs,
  cumsum: cumSumDocs,
  mad: madDocs,
  max: maxDocs,
  mean: meanDocs,
  median: medianDocs,
  min: minDocs,
  mode: modeDocs,
  prod: prodDocs,
  quantileSeq: quantileSeqDocs,
  std: stdDocs,
  sum: sumDocs,
  variance: varianceDocs,
  corr: corrDocs,
  acos: acosDocs,
  acosh: acoshDocs,
  acot: acotDocs,
  acoth: acothDocs,
  acsc: acscDocs,
  acsch: acschDocs,
  asec: asecDocs,
  asech: asechDocs,
  asin: asinDocs,
  asinh: asinhDocs,
  atan: atanDocs,
  atanh: atanhDocs,
  atan2: atan2Docs,
  cos: cosDocs,
  cosh: coshDocs,
  cot: cotDocs,
  coth: cothDocs,
  csc: cscDocs,
  csch: cschDocs,
  sec: secDocs,
  sech: sechDocs,
  sin: sinDocs,
  sinh: sinhDocs,
  tan: tanDocs,
  tanh: tanhDocs,
  to: toDocs,
  clone: cloneDocs,
  format: formatDocs,
  bin: binDocs,
  oct: octDocs,
  hex: hexDocs,
  isNaN: isNaNDocs,
  isInteger: isIntegerDocs,
  isNegative: isNegativeDocs,
  isNumeric: isNumericDocs,
  hasNumericValue: hasNumericValueDocs,
  isPositive: isPositiveDocs,
  isPrime: isPrimeDocs,
  isZero: isZeroDocs,
  print: printDocs,
  typeOf: typeOfDocs,
  numeric: numericDocs
};

// node_modules/mathjs/lib/esm/expression/function/help.js
var name239 = "help";
var dependencies240 = ["typed", "mathWithTransform", "Help"];
var createHelp = /* @__PURE__ */ factory(name239, dependencies240, (_ref) => {
  var {
    typed: typed2,
    mathWithTransform,
    Help
  } = _ref;
  return typed2(name239, {
    any: function any(search) {
      var prop;
      var searchName = search;
      if (typeof search !== "string") {
        for (prop in mathWithTransform) {
          if (hasOwnProperty(mathWithTransform, prop) && search === mathWithTransform[prop]) {
            searchName = prop;
            break;
          }
        }
      }
      var doc = getSafeProperty(embeddedDocs, searchName);
      if (!doc) {
        var searchText = typeof searchName === "function" ? searchName.name : searchName;
        throw new Error('No documentation found on "' + searchText + '"');
      }
      return new Help(doc);
    }
  });
});
// node_modules/mathjs/lib/esm/type/chain/function/chain.js
var name240 = "chain";
var dependencies241 = ["typed", "Chain"];
var createChain = /* @__PURE__ */ factory(name240, dependencies241, (_ref) => {
  var {
    typed: typed2,
    Chain
  } = _ref;
  return typed2(name240, {
    "": function _() {
      return new Chain;
    },
    any: function any(value) {
      return new Chain(value);
    }
  });
});
// node_modules/mathjs/lib/esm/function/matrix/det.js
var name241 = "det";
var dependencies242 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = /* @__PURE__ */ factory(name241, dependencies242, (_ref) => {
  var {
    typed: typed2,
    matrix,
    subtractScalar,
    multiply,
    divideScalar,
    isZero,
    unaryMinus
  } = _ref;
  return typed2(name241, {
    any: function any(x) {
      return clone(x);
    },
    "Array | Matrix": function det(x) {
      var size;
      if (isMatrix(x)) {
        size = x.size();
      } else if (Array.isArray(x)) {
        x = matrix(x);
        size = x.size();
      } else {
        size = [];
      }
      switch (size.length) {
        case 0:
          return clone(x);
        case 1:
          if (size[0] === 1) {
            return clone(x.valueOf()[0]);
          }
          if (size[0] === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size) + ")");
          }
        case 2: {
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows, cols);
          }
          if (cols === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional " + "(size: " + format3(size) + ")");
      }
    }
  });
  function _det(matrix2, rows, cols) {
    if (rows === 1) {
      return clone(matrix2[0][0]);
    } else if (rows === 2) {
      return subtractScalar(multiply(matrix2[0][0], matrix2[1][1]), multiply(matrix2[1][0], matrix2[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i2) => i2);
      for (var k = 0;k < rows; k++) {
        var k_ = rowIndices[k];
        if (isZero(matrix2[k_][k])) {
          var _k = undefined;
          for (_k = k + 1;_k < rows; _k++) {
            if (!isZero(matrix2[rowIndices[_k]][k])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k];
              rowIndices[k] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows)
            return matrix2[k_][k];
        }
        var piv = matrix2[k_][k];
        var piv_ = k === 0 ? 1 : matrix2[rowIndices[k - 1]][k - 1];
        for (var i = k + 1;i < rows; i++) {
          var i_ = rowIndices[i];
          for (var j = k + 1;j < rows; j++) {
            matrix2[i_][j] = divideScalar(subtractScalar(multiply(matrix2[i_][j], piv), multiply(matrix2[i_][k], matrix2[k_][j])), piv_);
          }
        }
      }
      var det = matrix2[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus(det) : det;
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/inv.js
var name242 = "inv";
var dependencies243 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = /* @__PURE__ */ factory(name242, dependencies243, (_ref) => {
  var {
    typed: typed2,
    matrix,
    divideScalar,
    addScalar,
    multiply,
    unaryMinus,
    det,
    identity,
    abs: abs2
  } = _ref;
  return typed2(name242, {
    "Array | Matrix": function Array__Matrix(x) {
      var size = isMatrix(x) ? x.size() : arraySize(x);
      switch (size.length) {
        case 1:
          if (size[0] === 1) {
            if (isMatrix(x)) {
              return matrix([divideScalar(1, x.valueOf()[0])]);
            } else {
              return [divideScalar(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size) + ")");
          }
        case 2: {
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional " + "(size: " + format3(size) + ")");
      }
    },
    any: function any(x) {
      return divideScalar(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar(1, value)]];
    } else if (rows === 2) {
      var d = det(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
    } else {
      var A = mat.concat();
      for (r = 0;r < rows; r++) {
        A[r] = A[r].concat();
      }
      var B = identity(rows).valueOf();
      for (var c = 0;c < cols; c++) {
        var ABig = abs2(A[c][c]);
        var rBig = c;
        r = c + 1;
        while (r < rows) {
          if (abs2(A[r][c]) > ABig) {
            ABig = abs2(A[r][c]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c) {
          temp = A[c];
          A[c] = A[r];
          A[r] = temp;
          temp = B[c];
          B[c] = B[r];
          B[r] = temp;
        }
        var Ac = A[c];
        var Bc = B[c];
        for (r = 0;r < rows; r++) {
          var Ar = A[r];
          var Br = B[r];
          if (r !== c) {
            if (Ar[c] !== 0) {
              f = divideScalar(unaryMinus(Ar[c]), Ac[c]);
              for (s = c;s < cols; s++) {
                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
              }
              for (s = 0;s < cols; s++) {
                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c];
            for (s = c;s < cols; s++) {
              Ar[s] = divideScalar(Ar[s], f);
            }
            for (s = 0;s < cols; s++) {
              Br[s] = divideScalar(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/pinv.js
var name243 = "pinv";
var dependencies244 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = /* @__PURE__ */ factory(name243, dependencies244, (_ref) => {
  var {
    typed: typed2,
    matrix,
    inv,
    deepEqual,
    equal,
    dotDivide,
    dot,
    ctranspose,
    divideScalar,
    multiply,
    add: add2,
    Complex: Complex2
  } = _ref;
  return typed2(name243, {
    "Array | Matrix": function Array__Matrix(x) {
      var size = isMatrix(x) ? x.size() : arraySize(x);
      switch (size.length) {
        case 1:
          if (_isZeros(x))
            return ctranspose(x);
          if (size[0] === 1) {
            return inv(x);
          } else {
            return dotDivide(ctranspose(x), dot(x, x));
          }
        case 2: {
          if (_isZeros(x))
            return ctranspose(x);
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            try {
              return inv(x);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
              } else {
                throw err;
              }
            }
          }
          if (isMatrix(x)) {
            return matrix(_pinv(x.valueOf(), rows, cols), x.storage());
          } else {
            return _pinv(x, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional " + "(size: " + format3(size) + ")");
      }
    },
    any: function any(x) {
      if (equal(x, 0))
        return clone(x);
      return divideScalar(1, x);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));
    var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));
    return multiply(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone(mat);
    var lead = 0;
    for (var r = 0;r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i = r;
      while (_isZero(M[i][lead])) {
        i++;
        if (rows === i) {
          i = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i], M[r]] = [M[r], M[i]];
      var val = M[r][lead];
      for (var j = 0;j < cols; j++) {
        M[r][j] = dotDivide(M[r][j], val);
      }
      for (var _i = 0;_i < rows; _i++) {
        if (_i === r)
          continue;
        val = M[_i][lead];
        for (var _j = 0;_j < cols; _j++) {
          M[_i][_j] = add2(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C = mat.map((_, i) => _.filter((_2, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));
    var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));
    return {
      C,
      F
    };
  }
  function _isZero(x) {
    return equal(add2(x, Complex2(1, 1)), add2(0, Complex2(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual(add2(arr, Complex2(1, 1)), add2(multiply(arr, 0), Complex2(1, 1)));
  }
});
// node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
function createComplexEigs(_ref) {
  var {
    addScalar,
    subtract,
    flatten: flatten2,
    multiply,
    multiplyScalar,
    divideScalar,
    sqrt: sqrt2,
    abs: abs2,
    bignumber,
    diag,
    size,
    reshape: reshape2,
    inv,
    qr,
    usolve,
    usolveAll,
    equal,
    complex,
    larger,
    smaller,
    matrixFromColumns,
    dot
  } = _ref;
  function complexEigs(arr, N, prec, type) {
    var findVectors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    if (findVectors) {
      var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);
      return {
        values,
        eigenvectors
      };
    }
    return {
      values
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber(0) : 0;
    var one = big ? bignumber(1) : cplx ? complex(1) : 1;
    var realone = big ? bignumber(1) : 1;
    var radix = big ? bignumber(10) : 2;
    var radixSq = multiplyScalar(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i = 0;i < N; i++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0;j < N; j++) {
          if (i === j)
            continue;
          colNorm = addScalar(colNorm, abs2(arr[j][i]));
          rowNorm = addScalar(rowNorm, abs2(arr[i][j]));
        }
        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
          var f = realone;
          var c = colNorm;
          var rowDivRadix = divideScalar(rowNorm, radix);
          var rowMulRadix = multiplyScalar(rowNorm, radix);
          while (smaller(c, rowDivRadix)) {
            c = multiplyScalar(c, radixSq);
            f = multiplyScalar(f, radix);
          }
          while (larger(c, rowMulRadix)) {
            c = divideScalar(c, radixSq);
            f = divideScalar(f, radix);
          }
          var condition = smaller(divideScalar(addScalar(c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g = divideScalar(1, f);
            for (var _j = 0;_j < N; _j++) {
              if (i === _j) {
                continue;
              }
              arr[i][_j] = multiplyScalar(arr[i][_j], g);
              arr[_j][i] = multiplyScalar(arr[_j][i], f);
            }
            if (findVectors) {
              Rdiag[i] = multiplyScalar(Rdiag[i], g);
            }
          }
        }
      }
    }
    return findVectors ? diag(Rdiag) : null;
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
    if (big) {
      prec = bignumber(prec);
    }
    for (var i = 0;i < N - 2; i++) {
      var maxIndex = 0;
      var max2 = zero;
      for (var j = i + 1;j < N; j++) {
        var el = arr[j][i];
        if (smaller(abs2(max2), abs2(el))) {
          max2 = el;
          maxIndex = j;
        }
      }
      if (smaller(abs2(max2), prec)) {
        continue;
      }
      if (maxIndex !== i + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i + 1];
        arr[i + 1] = tmp1;
        for (var _j2 = 0;_j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i + 1];
          arr[_j2][i + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i + 1];
          R[i + 1] = tmp3;
        }
      }
      for (var _j3 = i + 2;_j3 < N; _j3++) {
        var n = divideScalar(arr[_j3][i], max2);
        if (n === 0) {
          continue;
        }
        for (var k = 0;k < N; k++) {
          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));
        }
        for (var _k = 0;_k < N; _k++) {
          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0;_k2 < N; _k2++) {
            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber(1) : cplx ? complex(1) : 1;
    if (big) {
      prec = bignumber(prec);
    }
    var arr = clone(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;
    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = arr[n - 1][n - 1];
      for (var i = 0;i < n; i++) {
        arr[i][i] = subtract(arr[i][i], k);
      }
      var {
        Q: Q2,
        R
      } = qr(arr);
      arr = multiply(R, Q2);
      for (var _i = 0;_i < n; _i++) {
        arr[_i][_i] = addScalar(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply(Qpartial, Q2);
      }
      if (n === 1 || smaller(abs2(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0;_i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller(abs2(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0;_i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract(abs2(a), abs2(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    var Cinv = inv(C);
    var U = multiply(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
    var one = big ? bignumber(1) : cplx ? complex(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var lambda of values) {
      var i = indexOf(uniqueValues, lambda, equal);
      if (i === -1) {
        uniqueValues.push(lambda);
        multiplicities.push(1);
      } else {
        multiplicities[i] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero);
    var E = diag(Array(N).fill(one));
    var _loop = function _loop() {
      var lambda2 = uniqueValues[_i4];
      var S = subtract(U, multiply(lambda2, E));
      var solutions = usolveAll(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i4]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec === null) {
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply(inv(R), C);
      solutions = solutions.map((v) => multiply(correction, v));
      vectors.push(...solutions.map((v) => ({
        value: lambda2,
        vector: flatten2(v)
      })));
    };
    for (var _i4 = 0;_i4 < len; _i4++) {
      _loop();
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar(a, d);
    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
    var x = multiplyScalar(trA, 0.5);
    var y = multiplyScalar(sqrt2(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
    return [addScalar(x, y), subtract(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
    var one = big ? bignumber(1) : cplx ? complex(1) : 1;
    if (smaller(abs2(c), prec)) {
      return [[one, zero], [zero, one]];
    }
    if (larger(abs2(subtract(l1, l2)), prec)) {
      return [[subtract(l1, d), subtract(l2, d)], [c, c]];
    }
    var na = subtract(a, l1);
    var nd = subtract(d, l1);
    if (smaller(abs2(b), prec) && smaller(abs2(nd), prec)) {
      return [[na, one], [c, zero]];
    } else {
      return [[b, zero], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i = 0;i < arr.length; i++) {
      arr[i].push(...Array(N - arr[i].length).fill(0));
    }
    for (var _i5 = arr.length;_i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i = 0;i < N; i++) {
      M[i] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub2 of arr) {
      var n = sub2.length;
      for (var _i6 = 0;_i6 < n; _i6++) {
        for (var j = 0;j < n; j++) {
          M[I + _i6][I + j] = sub2[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i = 0;i < arr.length; i++) {
      if (fn(arr[i], el)) {
        return i;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber(1000) : 1000;
    var b;
    var i = 0;
    for (;i < 5; ++i) {
      b = randomOrthogonalVector(N, orthog, type);
      try {
        b = usolve(A, b);
      } catch (_unused) {
        continue;
      }
      if (larger(norm(b), largeNum)) {
        break;
      }
    }
    if (i >= 5) {
      return null;
    }
    i = 0;
    while (true) {
      var c = usolve(A, b);
      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber(n));
    }
    if (cplx) {
      v = v.map((n) => complex(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    var vectorShape = size(v);
    for (var w of orthog) {
      w = reshape2(w, vectorShape);
      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
    }
    return v;
  }
  function norm(v) {
    return abs2(sqrt2(dot(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber(1) : cplx ? complex(1) : 1;
    return multiply(divideScalar(one, norm(v)), v);
  }
  return complexEigs;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs/realSymmetric.js
function createRealSymmetric(_ref) {
  var {
    config: config4,
    addScalar,
    subtract,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar,
    inv,
    bignumber,
    multiply,
    add: add2
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config4.relTol;
    var type = arguments.length > 3 ? arguments[3] : undefined;
    var computeVectors = arguments.length > 4 ? arguments[4] : undefined;
    if (type === "number") {
      return diag(arr, prec, computeVectors);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec, computeVectors);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag(x, precision, computeVectors) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i = 0;i < N; i++) {
        Sij[i] = Array(N).fill(0);
        Sij[i][i] = 1;
      }
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      if (computeVectors)
        Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i2 = 0;_i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function diagBig(x, precision, computeVectors) {
    var N = x.length;
    var e0 = abs2(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i = 0;i < N; i++) {
        Sij[i] = Array(N).fill(0);
        Sij[i][i] = 1;
      }
    }
    var Vab = getAijBig(x);
    while (abs2(Vab[1]) >= abs2(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      if (computeVectors)
        Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i4 = 0;_i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config4.relTol) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract(ajj, aii);
    if (abs2(denom) <= config4.relTol) {
      return bignumber(-1).acos().div(4);
    } else {
      return multiplyScalar(0.5, atan3(multiply(2, aij, inv(denom))));
    }
  }
  function Sij1(Sij, theta, i, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = Array(N).fill(0);
    var Skj = Array(N).fill(0);
    for (var k = 0;k < N; k++) {
      Ski[k] = c * Sij[k][i] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i] + c * Sij[k][j];
    }
    for (var _k = 0;_k < N; _k++) {
      Sij[_k][i] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i, j) {
    var N = Sij.length;
    var c = cos2(theta);
    var s = sin2(theta);
    var Ski = Array(N).fill(bignumber(0));
    var Skj = Array(N).fill(bignumber(0));
    for (var k = 0;k < N; k++) {
      Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
      Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
    }
    for (var _k2 = 0;_k2 < N; _k2++) {
      Sij[_k2][i] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i, j) {
    var N = Hij.length;
    var c = bignumber(cos2(theta));
    var s = bignumber(sin2(theta));
    var c2 = multiplyScalar(c, c);
    var s2 = multiplyScalar(s, s);
    var Aki = Array(N).fill(bignumber(0));
    var Akj = Array(N).fill(bignumber(0));
    var csHij = multiply(bignumber(2), c, s, Hij[i][j]);
    var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
    var Ajj = add2(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j]));
    for (var k = 0;k < N; k++) {
      Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
      Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
    }
    Hij[i][i] = Aii;
    Hij[j][j] = Ajj;
    Hij[i][j] = bignumber(0);
    Hij[j][i] = bignumber(0);
    for (var _k3 = 0;_k3 < N; _k3++) {
      if (_k3 !== i && _k3 !== j) {
        Hij[i][_k3] = Aki[_k3];
        Hij[_k3][i] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = Array(N).fill(0);
    var Akj = Array(N).fill(0);
    var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
    for (var k = 0;k < N; k++) {
      Aki[k] = c * Hij[i][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i][k] + c * Hij[j][k];
    }
    Hij[i][i] = Aii;
    Hij[j][j] = Ajj;
    Hij[i][j] = 0;
    Hij[j][i] = 0;
    for (var _k4 = 0;_k4 < N; _k4++) {
      if (_k4 !== i && _k4 !== j) {
        Hij[i][_k4] = Aki[_k4];
        Hij[_k4][i] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i = 0;i < N; i++) {
      for (var j = i + 1;j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
          maxMij = Math.abs(Mij[i][j]);
          maxIJ = [i, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i = 0;i < N; i++) {
      for (var j = i + 1;j < N; j++) {
        if (abs2(maxMij) < abs2(Mij[i][j])) {
          maxMij = abs2(Mij[i][j]);
          maxIJ = [i, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S, computeVectors) {
    var N = E.length;
    var values = Array(N);
    var vecs;
    if (computeVectors) {
      vecs = Array(N);
      for (var k = 0;k < N; k++) {
        vecs[k] = Array(N);
      }
    }
    for (var i = 0;i < N; i++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0;j < E.length; j++) {
        if (abs2(E[j]) < abs2(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i] = E.splice(minID, 1)[0];
      if (computeVectors) {
        for (var _k5 = 0;_k5 < N; _k5++) {
          vecs[i][_k5] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
    }
    if (!computeVectors)
      return {
        values
      };
    var eigenvectors = vecs.map((vector, i2) => ({
      value: values[i2],
      vector
    }));
    return {
      values,
      eigenvectors
    };
  }
  return main;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs.js
var name244 = "eigs";
var dependencies245 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = /* @__PURE__ */ factory(name244, dependencies245, (_ref) => {
  var {
    config: config4,
    typed: typed2,
    matrix,
    addScalar,
    subtract,
    equal,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar,
    divideScalar,
    inv,
    bignumber,
    multiply,
    add: add2,
    larger,
    column,
    flatten: flatten2,
    number,
    complex,
    sqrt: sqrt2,
    diag,
    size,
    reshape: reshape2,
    qr,
    usolve,
    usolveAll,
    im,
    re,
    smaller,
    matrixFromColumns,
    dot
  } = _ref;
  var doRealSymmetric = createRealSymmetric({
    config: config4,
    addScalar,
    subtract,
    column,
    flatten: flatten2,
    equal,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar,
    inv,
    bignumber,
    complex,
    multiply,
    add: add2
  });
  var doComplexEigs = createComplexEigs({
    config: config4,
    addScalar,
    subtract,
    multiply,
    multiplyScalar,
    flatten: flatten2,
    divideScalar,
    sqrt: sqrt2,
    abs: abs2,
    bignumber,
    diag,
    size,
    reshape: reshape2,
    qr,
    inv,
    usolve,
    usolveAll,
    equal,
    complex,
    larger,
    smaller,
    matrixFromColumns,
    dot
  });
  return typed2("eigs", {
    Array: function Array(x) {
      return doEigs(matrix(x));
    },
    "Array, number|BigNumber": function Array_numberBigNumber(x, prec) {
      return doEigs(matrix(x), {
        precision: prec
      });
    },
    "Array, Object"(x, opts) {
      return doEigs(matrix(x), opts);
    },
    Matrix: function Matrix(mat) {
      return doEigs(mat, {
        matricize: true
      });
    },
    "Matrix, number|BigNumber": function Matrix_numberBigNumber(mat, prec) {
      return doEigs(mat, {
        precision: prec,
        matricize: true
      });
    },
    "Matrix, Object": function Matrix_Object(mat, opts) {
      var useOpts = {
        matricize: true
      };
      _extends(useOpts, opts);
      return doEigs(mat, useOpts);
    }
  });
  function doEigs(mat) {
    var _opts$precision;
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var computeVectors = "eigenvectors" in opts ? opts.eigenvectors : true;
    var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== undefined ? _opts$precision : config4.relTol;
    var result = computeValuesAndVectors(mat, prec, computeVectors);
    if (opts.matricize) {
      result.values = matrix(result.values);
      if (computeVectors) {
        result.eigenvectors = result.eigenvectors.map((_ref2) => {
          var {
            value,
            vector
          } = _ref2;
          return {
            value,
            vector: matrix(vector)
          };
        });
      }
    }
    if (computeVectors) {
      Object.defineProperty(result, "vectors", {
        enumerable: false,
        get: () => {
          throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
        }
      });
    }
    return result;
  }
  function computeValuesAndVectors(mat, prec, computeVectors) {
    var arr = mat.toArray();
    var asize = mat.size();
    if (asize.length !== 2 || asize[0] !== asize[1]) {
      throw new RangeError("Matrix must be square (size: ".concat(format3(asize), ")"));
    }
    var N = asize[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymmetric(arr, N, prec, _type, computeVectors);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type, computeVectors);
  }
  function isSymmetric(arr, N, prec) {
    for (var i = 0;i < N; i++) {
      for (var j = i;j < N; j++) {
        if (larger(bignumber(abs2(subtract(arr[i][j], arr[j][i]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i = 0;i < N; i++) {
      for (var j = 0;j < N; j++) {
        if (larger(bignumber(abs2(im(arr[i][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i = 0;i < N; i++) {
      for (var j = 0;j < N; j++) {
        arr[i][j] = re(arr[i][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i = 0;i < N; i++) {
      for (var j = 0;j < N; j++) {
        var el = arr[i][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0;_i < N; _i++) {
        for (var _j = 0;_j < N; _j++) {
          arr[_i][_j] = complex(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0;_i2 < N; _i2++) {
        for (var _j2 = 0;_j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0;_i3 < N; _i3++) {
        for (var _j3 = 0;_j3 < N; _j3++) {
          arr[_i3][_j3] = number(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});
// node_modules/mathjs/lib/esm/function/matrix/expm.js
var name245 = "expm";
var dependencies246 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = /* @__PURE__ */ factory(name245, dependencies246, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    identity,
    inv,
    multiply
  } = _ref;
  return typed2(name245, {
    Matrix: function Matrix(A) {
      var size = A.size();
      if (size.length !== 2 || size[0] !== size[1]) {
        throw new RangeError("Matrix must be square " + "(size: " + format3(size) + ")");
      }
      var n = size[0];
      var eps = 0.000000000000001;
      var infNorm = infinityNorm(A);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply(A, Math.pow(2, -j));
      var N = identity(n);
      var D = identity(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i = 1;i <= q; i++) {
        if (i > 1) {
          AposToI = multiply(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
        N = add2(N, multiply(factor, AposToI));
        D = add2(D, multiply(factor * alternate, AposToI));
      }
      var R = multiply(inv(D), N);
      for (var _i = 0;_i < j; _i++) {
        R = multiply(R, R);
      }
      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A) {
    var n = A.size()[0];
    var infNorm = 0;
    for (var i = 0;i < n; i++) {
      var rowSum = 0;
      for (var j = 0;j < n; j++) {
        rowSum += abs2(A.get([i, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k = 0;k < maxSearchSize; k++) {
      for (var q = 0;q <= k; q++) {
        var j = k - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i = 2;i <= q; i++) {
      qfac *= i;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1;_i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});
// node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
var name246 = "sqrtm";
var dependencies247 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = /* @__PURE__ */ factory(name246, dependencies247, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply,
    map: map2,
    sqrt: sqrt2,
    subtract,
    inv,
    size,
    max: max2,
    identity
  } = _ref;
  var _maxIterations = 1000;
  var _tolerance = 0.000001;
  function _denmanBeavers(A) {
    var error;
    var iterations = 0;
    var Y = A;
    var Z = identity(size(A));
    do {
      var Yk = Y;
      Y = multiply(0.5, add2(Yk, inv(Z)));
      Z = multiply(0.5, add2(Z, inv(Yk)));
      error = max2(abs2(subtract(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed2(name246, {
    "Array | Matrix": function Array__Matrix(A) {
      var size2 = isMatrix(A) ? A.size() : arraySize(A);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            return map2(A, sqrt2);
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _denmanBeavers(A);
          } else {
            throw new RangeError("Matrix must be square " + "(size: " + format3(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional " + "(size: " + format3(size2) + ")");
      }
    }
  });
});
// node_modules/mathjs/lib/esm/function/algebra/sylvester.js
var name247 = "sylvester";
var dependencies248 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
var createSylvester = /* @__PURE__ */ factory(name247, dependencies248, (_ref) => {
  var {
    typed: typed2,
    schur,
    matrixFromColumns,
    matrix,
    multiply,
    range,
    concat: concat2,
    transpose,
    index,
    subset,
    add: add2,
    subtract,
    identity,
    lusolve,
    abs: abs2
  } = _ref;
  return typed2(name247, {
    "Matrix, Matrix, Matrix": _sylvester,
    "Array, Matrix, Matrix": function Array_Matrix_Matrix(A, B, C) {
      return _sylvester(matrix(A), B, C);
    },
    "Array, Array, Matrix": function Array_Array_Matrix(A, B, C) {
      return _sylvester(matrix(A), matrix(B), C);
    },
    "Array, Matrix, Array": function Array_Matrix_Array(A, B, C) {
      return _sylvester(matrix(A), B, matrix(C));
    },
    "Matrix, Array, Matrix": function Matrix_Array_Matrix(A, B, C) {
      return _sylvester(A, matrix(B), C);
    },
    "Matrix, Array, Array": function Matrix_Array_Array(A, B, C) {
      return _sylvester(A, matrix(B), matrix(C));
    },
    "Matrix, Matrix, Array": function Matrix_Matrix_Array(A, B, C) {
      return _sylvester(A, B, matrix(C));
    },
    "Array, Array, Array": function Array_Array_Array(A, B, C) {
      return _sylvester(matrix(A), matrix(B), matrix(C)).toArray();
    }
  });
  function _sylvester(A, B, C) {
    var n = B.size()[0];
    var m = A.size()[0];
    var sA = schur(A);
    var F = sA.T;
    var U = sA.U;
    var sB = schur(multiply(-1, B));
    var G = sB.T;
    var V = sB.U;
    var D = multiply(multiply(transpose(U), C), V);
    var all = range(0, m);
    var y = [];
    var hc = (a, b) => concat2(a, b, 1);
    var vc = (a, b) => concat2(a, b, 0);
    for (var k = 0;k < n; k++) {
      if (k < n - 1 && abs2(subset(G, index(k + 1, k))) > 0.00001) {
        var RHS = vc(subset(D, index(all, k)), subset(D, index(all, k + 1)));
        for (var j = 0;j < k; j++) {
          RHS = add2(RHS, vc(multiply(y[j], subset(G, index(j, k))), multiply(y[j], subset(G, index(j, k + 1)))));
        }
        var gkk = multiply(identity(m), multiply(-1, subset(G, index(k, k))));
        var gmk = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k))));
        var gkm = multiply(identity(m), multiply(-1, subset(G, index(k, k + 1))));
        var gmm = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k + 1))));
        var LHS = vc(hc(add2(F, gkk), gmk), hc(gkm, add2(F, gmm)));
        var yAux = lusolve(LHS, RHS);
        y[k] = yAux.subset(index(range(0, m), 0));
        y[k + 1] = yAux.subset(index(range(m, 2 * m), 0));
        k++;
      } else {
        var _RHS = subset(D, index(all, k));
        for (var _j = 0;_j < k; _j++) {
          _RHS = add2(_RHS, multiply(y[_j], subset(G, index(_j, k))));
        }
        var _gkk = subset(G, index(k, k));
        var _LHS = subtract(F, multiply(_gkk, identity(m)));
        y[k] = lusolve(_LHS, _RHS);
      }
    }
    var Y = matrix(matrixFromColumns(...y));
    var X = multiply(U, multiply(Y, transpose(V)));
    return X;
  }
});
// node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
var name248 = "schur";
var dependencies249 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
var createSchur = /* @__PURE__ */ factory(name248, dependencies249, (_ref) => {
  var {
    typed: typed2,
    matrix,
    identity,
    multiply,
    qr,
    norm,
    subtract
  } = _ref;
  return typed2(name248, {
    Array: function Array(X) {
      var r = _schur(matrix(X));
      return {
        U: r.U.valueOf(),
        T: r.T.valueOf()
      };
    },
    Matrix: function Matrix(X) {
      return _schur(X);
    }
  });
  function _schur(X) {
    var n = X.size()[0];
    var A = X;
    var U = identity(n);
    var k = 0;
    var A0;
    do {
      A0 = A;
      var QR = qr(A);
      var Q2 = QR.Q;
      var R = QR.R;
      A = multiply(R, Q2);
      U = multiply(U, Q2);
      if (k++ > 100) {
        break;
      }
    } while (norm(subtract(A, A0)) > 0.0001);
    return {
      U,
      T: A
    };
  }
});
// node_modules/mathjs/lib/esm/function/algebra/lyap.js
var name249 = "lyap";
var dependencies250 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = /* @__PURE__ */ factory(name249, dependencies250, (_ref) => {
  var {
    typed: typed2,
    matrix,
    sylvester,
    multiply,
    transpose
  } = _ref;
  return typed2(name249, {
    "Matrix, Matrix": function Matrix_Matrix(A, Q2) {
      return sylvester(A, transpose(A), multiply(-1, Q2));
    },
    "Array, Matrix": function Array_Matrix(A, Q2) {
      return sylvester(matrix(A), transpose(matrix(A)), multiply(-1, Q2));
    },
    "Matrix, Array": function Matrix_Array(A, Q2) {
      return sylvester(A, transpose(matrix(A)), matrix(multiply(-1, Q2)));
    },
    "Array, Array": function Array_Array(A, Q2) {
      return sylvester(matrix(A), transpose(matrix(A)), matrix(multiply(-1, Q2))).toArray();
    }
  });
});
// node_modules/mathjs/lib/esm/function/arithmetic/divide.js
var name250 = "divide";
var dependencies251 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = /* @__PURE__ */ factory(name250, dependencies251, (_ref) => {
  var {
    typed: typed2,
    matrix,
    multiply,
    equalScalar,
    divideScalar,
    inv
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2("divide", extend({
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(x, y) {
      return multiply(x, inv(y));
    },
    "DenseMatrix, any": function DenseMatrix_any(x, y) {
      return matAlgo14xDs(x, y, divideScalar, false);
    },
    "SparseMatrix, any": function SparseMatrix_any(x, y) {
      return matAlgo11xS0s(x, y, divideScalar, false);
    },
    "Array, any": function Array_any(x, y) {
      return matAlgo14xDs(matrix(x), y, divideScalar, false).valueOf();
    },
    "any, Array | Matrix": function any_Array__Matrix(x, y) {
      return multiply(x, inv(y));
    }
  }, divideScalar.signatures));
});
// node_modules/mathjs/lib/esm/function/geometry/distance.js
var name251 = "distance";
var dependencies252 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
var createDistance = /* @__PURE__ */ factory(name251, dependencies252, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    deepEqual,
    sqrt: sqrt2,
    abs: abs2
  } = _ref;
  return typed2(name251, {
    "Array, Array, Array": function Array_Array_Array(x, y, z) {
      if (x.length === 2 && y.length === 2 && z.length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        if (deepEqual(y, z)) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        var xCoeff = subtractScalar(z[1], y[1]);
        var yCoeff = subtractScalar(y[0], z[0]);
        var constant = subtractScalar(multiplyScalar(z[0], y[1]), multiplyScalar(y[0], z[1]));
        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function Object_Object_Object(x, y, z) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if (deepEqual(_objectToArray(y), _objectToArray(z))) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
          var xCoeff = subtractScalar(z.lineTwoPtY, y.lineOnePtY);
          var yCoeff = subtractScalar(y.lineOnePtX, z.lineTwoPtX);
          var constant = subtractScalar(multiplyScalar(z.lineTwoPtX, y.lineOnePtY), multiplyScalar(y.lineOnePtX, z.lineTwoPtY));
          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function Array_Array(x, y) {
      if (x.length === 2 && y.length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      } else if (x.length === 3 && y.length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      } else if (x.length === y.length && x.length > 0) {
        if (!_containsOnlyNumbers(x)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x, y);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function Object_Object(x, y) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a) {
    return typeof a === "number" || isBigNumber(a);
  }
  function _2d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]);
  }
  function _3d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
  }
  function _containsOnlyNumbers(a) {
    if (!Array.isArray(a)) {
      a = _objectToArray(a);
    }
    return a.every(_isNumber);
  }
  function _parametricLine(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
  }
  function _objectToArray(o) {
    var keys = Object.keys(o);
    var a = [];
    for (var i = 0;i < keys.length; i++) {
      a.push(o[keys[i]]);
    }
    return a;
  }
  function _pairwise(a) {
    if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
      if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
      if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x, y, a, b, c) {
    var num = abs2(addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c));
    var den = sqrt2(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
    return divideScalar(num, den);
  }
  function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
    var num = [subtractScalar(multiplyScalar(subtractScalar(y0, y), c), multiplyScalar(subtractScalar(z0, z), b)), subtractScalar(multiplyScalar(subtractScalar(z0, z), a), multiplyScalar(subtractScalar(x0, x), c)), subtractScalar(multiplyScalar(subtractScalar(x0, x), b), multiplyScalar(subtractScalar(y0, y), a))];
    num = sqrt2(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
    var den = sqrt2(addScalar(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)), multiplyScalar(c, c)));
    return divideScalar(num, den);
  }
  function _euclideanDistance(x, y) {
    var vectorSize = x.length;
    var result = 0;
    var diff = 0;
    for (var i = 0;i < vectorSize; i++) {
      diff = subtractScalar(x[i], y[i]);
      result = addScalar(multiplyScalar(diff, diff), result);
    }
    return sqrt2(result);
  }
  function _distancePairwise(a) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i = 0;i < a.length - 1; i++) {
      for (var j = i + 1;j < a.length; j++) {
        if (a[0].length === 2) {
          pointA = [a[i][0], a[i][1]];
          pointB = [a[j][0], a[j][1]];
        } else if (a[0].length === 3) {
          pointA = [a[i][0], a[i][1], a[i][2]];
          pointB = [a[j][0], a[j][1], a[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});
// node_modules/mathjs/lib/esm/function/geometry/intersect.js
var name252 = "intersect";
var dependencies253 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = /* @__PURE__ */ factory(name252, dependencies253, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    abs: abs2,
    add: add2,
    addScalar,
    matrix,
    multiply,
    multiplyScalar,
    divideScalar,
    subtract,
    smaller,
    equalScalar,
    flatten: flatten2,
    isZero,
    isNumeric
  } = _ref;
  return typed2("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function Matrix_Matrix_Matrix(x, y, plane) {
      var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
      return arr === null ? null : matrix(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function Matrix_Matrix_Matrix_Matrix(w, x, y, z) {
      var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
      return arr === null ? null : matrix(arr);
    }
  });
  function _AAA(x, y, plane) {
    x = _coerceArr(x);
    y = _coerceArr(y);
    plane = _coerceArr(plane);
    if (!_3d(x)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x, y, z) {
    w = _coerceArr(w);
    x = _coerceArr(x);
    y = _coerceArr(y);
    z = _coerceArr(z);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x, y, z);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1)
      return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1))
        return flatten2(arr);
    }
    return arr;
  }
  function _2d(x) {
    return x.length === 2 && isNumeric(x[0]) && isNumeric(x[1]);
  }
  function _3d(x) {
    return x.length === 3 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]);
  }
  function _4d(x) {
    return x.length === 4 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]) && isNumeric(x[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract(o1, p1b);
    var d2 = subtract(o2, p2b);
    var det = subtract(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));
    if (isZero(det))
      return null;
    if (smaller(abs2(det), config4.relTol)) {
      return null;
    }
    var d20o11 = multiplyScalar(d2[0], o1[1]);
    var d21o10 = multiplyScalar(d2[1], o1[0]);
    var d20o21 = multiplyScalar(d2[0], o2[1]);
    var d21o20 = multiplyScalar(d2[1], o2[0]);
    var t = divideScalar(addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
    return add2(multiply(d1, t), o1);
  }
  function _intersect3dHelper(a, b, c, d, e2, f, g, h, i, j, k, l) {
    var add1 = multiplyScalar(subtract(a, b), subtract(c, d));
    var add22 = multiplyScalar(subtract(e2, f), subtract(g, h));
    var add3 = multiplyScalar(subtract(i, j), subtract(k, l));
    return addScalar(addScalar(add1, add22), add3);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343));
    var denominator = subtract(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321));
    if (isZero(denominator))
      return null;
    var ta = divideScalar(numerator, denominator);
    var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
    var pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
    var pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
    var paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
    var pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
    var pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
    var pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));
    if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
    var x1x = multiplyScalar(x1, x);
    var x2x = multiplyScalar(x2, x);
    var y1y = multiplyScalar(y1, y);
    var y2y = multiplyScalar(y2, y);
    var z1z = multiplyScalar(z1, z);
    var z2z = multiplyScalar(z2, z);
    var numerator = subtract(subtract(subtract(c, x1x), y1y), z1z);
    var denominator = subtract(subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar(numerator, denominator);
    var px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
    var py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
    var pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
    return [px, py, pz];
  }
});
// node_modules/mathjs/lib/esm/function/statistics/sum.js
var name253 = "sum";
var dependencies254 = ["typed", "config", "add", "numeric"];
var createSum = /* @__PURE__ */ factory(name253, dependencies254, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    add: add2,
    numeric: numeric2
  } = _ref;
  return typed2(name253, {
    "Array | Matrix": _sum,
    "Array | Matrix, number | BigNumber": _nsumDim,
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function sum");
      }
      return _sum(args);
    }
  });
  function _sum(array) {
    var sum2;
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === undefined ? value : add2(sum2, value);
      } catch (err) {
        throw improveErrorMessage(err, "sum", value);
      }
    });
    if (sum2 === undefined) {
      sum2 = numeric2(0, config4.number);
    }
    if (typeof sum2 === "string") {
      sum2 = numeric2(sum2, safeNumberType(sum2, config4));
    }
    return sum2;
  }
  function _nsumDim(array, dim) {
    try {
      var sum2 = reduce(array, dim, add2);
      return sum2;
    } catch (err) {
      throw improveErrorMessage(err, "sum");
    }
  }
});
// node_modules/mathjs/lib/esm/function/statistics/cumsum.js
var name254 = "cumsum";
var dependencies255 = ["typed", "add", "unaryPlus"];
var createCumSum = /* @__PURE__ */ factory(name254, dependencies255, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    unaryPlus
  } = _ref;
  return typed2(name254, {
    Array: _cumsum,
    Matrix: function Matrix(matrix) {
      return matrix.create(_cumsum(matrix.valueOf(), matrix.datatype()));
    },
    "Array, number | BigNumber": _ncumSumDim,
    "Matrix, number | BigNumber": function Matrix_number__BigNumber(matrix, dim) {
      return matrix.create(_ncumSumDim(matrix.valueOf(), dim), matrix.datatype());
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("All values expected to be scalar in function cumsum");
      }
      return _cumsum(args);
    }
  });
  function _cumsum(array) {
    try {
      return _cumsummap(array);
    } catch (err) {
      throw improveErrorMessage(err, name254);
    }
  }
  function _cumsummap(array) {
    if (array.length === 0) {
      return [];
    }
    var sums = [unaryPlus(array[0])];
    for (var i = 1;i < array.length; ++i) {
      sums.push(add2(sums[i - 1], array[i]));
    }
    return sums;
  }
  function _ncumSumDim(array, dim) {
    var size = arraySize(array);
    if (dim < 0 || dim >= size.length) {
      throw new IndexError(dim, size.length);
    }
    try {
      return _cumsumDimensional(array, dim);
    } catch (err) {
      throw improveErrorMessage(err, name254);
    }
  }
  function _cumsumDimensional(mat, dim) {
    var i, ret, tran;
    if (dim <= 0) {
      var initialValue = mat[0][0];
      if (!Array.isArray(initialValue)) {
        return _cumsummap(mat);
      } else {
        tran = _switch(mat);
        ret = [];
        for (i = 0;i < tran.length; i++) {
          ret[i] = _cumsumDimensional(tran[i], dim - 1);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i = 0;i < mat.length; i++) {
        ret[i] = _cumsumDimensional(mat[i], dim - 1);
      }
      return ret;
    }
  }
});
// node_modules/mathjs/lib/esm/function/statistics/mean.js
var name255 = "mean";
var dependencies256 = ["typed", "add", "divide"];
var createMean = /* @__PURE__ */ factory(name255, dependencies256, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2
  } = _ref;
  return typed2(name255, {
    "Array | Matrix": _mean,
    "Array | Matrix, number | BigNumber": _nmeanDim,
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function mean");
      }
      return _mean(args);
    }
  });
  function _nmeanDim(array, dim) {
    try {
      var sum2 = reduce(array, dim, add2);
      var s = Array.isArray(array) ? arraySize(array) : array.size();
      return divide2(sum2, s[dim]);
    } catch (err) {
      throw improveErrorMessage(err, "mean");
    }
  }
  function _mean(array) {
    var sum2;
    var num = 0;
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === undefined ? value : add2(sum2, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "mean", value);
      }
    });
    if (num === 0) {
      throw new Error("Cannot calculate the mean of an empty array");
    }
    return divide2(sum2, num);
  }
});
// node_modules/mathjs/lib/esm/function/statistics/median.js
var name256 = "median";
var dependencies257 = ["typed", "add", "divide", "compare", "partitionSelect"];
var createMedian = /* @__PURE__ */ factory(name256, dependencies257, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2,
    compare,
    partitionSelect
  } = _ref;
  function _median(array) {
    try {
      array = flatten(array.valueOf());
      var num = array.length;
      if (num === 0) {
        throw new Error("Cannot calculate median of an empty array");
      }
      if (num % 2 === 0) {
        var mid = num / 2 - 1;
        var right = partitionSelect(array, mid + 1);
        var left = array[mid];
        for (var i = 0;i < mid; ++i) {
          if (compare(array[i], left) > 0) {
            left = array[i];
          }
        }
        return middle2(left, right);
      } else {
        var m = partitionSelect(array, (num - 1) / 2);
        return middle(m);
      }
    } catch (err) {
      throw improveErrorMessage(err, "median");
    }
  }
  var middle = typed2({
    "number | BigNumber | Complex | Unit": function number__BigNumber__Complex__Unit(value) {
      return value;
    }
  });
  var middle2 = typed2({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function number__BigNumber__Complex__Unit_number__BigNumber__Complex__Unit(left, right) {
      return divide2(add2(left, right), 2);
    }
  });
  return typed2(name256, {
    "Array | Matrix": _median,
    "Array | Matrix, number | BigNumber": function Array__Matrix_number__BigNumber(array, dim) {
      throw new Error("median(A, dim) is not yet supported");
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function median");
      }
      return _median(args);
    }
  });
});
// node_modules/mathjs/lib/esm/function/statistics/mad.js
var name257 = "mad";
var dependencies258 = ["typed", "abs", "map", "median", "subtract"];
var createMad = /* @__PURE__ */ factory(name257, dependencies258, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    map: map2,
    median,
    subtract
  } = _ref;
  return typed2(name257, {
    "Array | Matrix": _mad,
    "...": function _(args) {
      return _mad(args);
    }
  });
  function _mad(array) {
    array = flatten(array.valueOf());
    if (array.length === 0) {
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    }
    try {
      var med = median(array);
      return median(map2(array, function(value) {
        return abs2(subtract(value, med));
      }));
    } catch (err) {
      if (err instanceof TypeError && err.message.includes("median")) {
        throw new TypeError(err.message.replace("median", "mad"));
      } else {
        throw improveErrorMessage(err, "mad");
      }
    }
  }
});
// node_modules/mathjs/lib/esm/function/statistics/variance.js
var DEFAULT_NORMALIZATION = "unbiased";
var name258 = "variance";
var dependencies259 = ["typed", "add", "subtract", "multiply", "divide", "mapSlices", "isNaN"];
var createVariance = /* @__PURE__ */ factory(name258, dependencies259, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    mapSlices,
    isNaN: isNaN2
  } = _ref;
  return typed2(name258, {
    "Array | Matrix": function Array__Matrix(array) {
      return _var(array, DEFAULT_NORMALIZATION);
    },
    "Array | Matrix, string": _var,
    "Array | Matrix, number | BigNumber": function Array__Matrix_number__BigNumber(array, dim) {
      return _varDim(array, dim, DEFAULT_NORMALIZATION);
    },
    "Array | Matrix, number | BigNumber, string": _varDim,
    "...": function _(args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });
  function _var(array, normalization) {
    var sum2;
    var num = 0;
    if (array.length === 0) {
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    }
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === undefined ? value : add2(sum2, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "variance", value);
      }
    });
    if (num === 0)
      throw new Error("Cannot calculate variance of an empty array");
    var mean = divide2(sum2, num);
    sum2 = undefined;
    deepForEach(array, function(value) {
      var diff = subtract(value, mean);
      sum2 = sum2 === undefined ? multiply(diff, diff) : add2(sum2, multiply(diff, diff));
    });
    if (isNaN2(sum2)) {
      return sum2;
    }
    switch (normalization) {
      case "uncorrected":
        return divide2(sum2, num);
      case "biased":
        return divide2(sum2, num + 1);
      case "unbiased": {
        var zero = isBigNumber(sum2) ? sum2.mul(0) : 0;
        return num === 1 ? zero : divide2(sum2, num - 1);
      }
      default:
        throw new Error('Unknown normalization "' + normalization + '". ' + 'Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function _varDim(array, dim, normalization) {
    try {
      if (array.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      return mapSlices(array, dim, (x) => _var(x, normalization));
    } catch (err) {
      throw improveErrorMessage(err, "variance");
    }
  }
});
// node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
var name259 = "quantileSeq";
var dependencies260 = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger", "mapSlices"];
var createQuantileSeq = /* @__PURE__ */ factory(name259, dependencies260, (_ref) => {
  var {
    typed: typed2,
    bignumber,
    add: add2,
    subtract,
    divide: divide2,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger,
    mapSlices
  } = _ref;
  return typed2(name259, {
    "Array | Matrix, number | BigNumber": (data, p) => _quantileSeqProbNumber(data, p, false),
    "Array | Matrix, number | BigNumber, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),
    "Array | Matrix, number | BigNumber, boolean": _quantileSeqProbNumber,
    "Array | Matrix, number | BigNumber, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),
    "Array | Matrix, Array | Matrix": (data, p) => _quantileSeqProbCollection(data, p, false),
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),
    "Array | Matrix, Array | Matrix, boolean": _quantileSeqProbCollection,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)
  });
  function _quantileSeqDim(data, prob, sorted, dim, fn) {
    return mapSlices(data, dim, (x) => fn(x, prob, sorted));
  }
  function _quantileSeqProbNumber(data, probOrN, sorted) {
    var probArr;
    var dataArr = data.valueOf();
    if (smaller(probOrN, 0)) {
      throw new Error("N/prob must be non-negative");
    }
    if (smallerEq(probOrN, 1)) {
      return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber(_quantileSeq(dataArr, probOrN, sorted));
    }
    if (larger(probOrN, 1)) {
      if (!isInteger2(probOrN)) {
        throw new Error("N must be a positive integer");
      }
      if (larger(probOrN, 4294967295)) {
        throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
      }
      var nPlusOne = add2(probOrN, 1);
      probArr = [];
      for (var i = 0;smaller(i, probOrN); i++) {
        var prob = divide2(i + 1, nPlusOne);
        probArr.push(_quantileSeq(dataArr, prob, sorted));
      }
      return isNumber(probOrN) ? probArr : bignumber(probArr);
    }
  }
  function _quantileSeqProbCollection(data, probOrN, sorted) {
    var dataArr = data.valueOf();
    var probOrNArr = probOrN.valueOf();
    var probArr = [];
    for (var i = 0;i < probOrNArr.length; ++i) {
      probArr.push(_quantileSeq(dataArr, probOrNArr[i], sorted));
    }
    return probArr;
  }
  function _quantileSeq(array, prob, sorted) {
    var flat = flatten(array);
    var len = flat.length;
    if (len === 0) {
      throw new Error("Cannot calculate quantile of an empty sequence");
    }
    var index = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);
    var integerPart = isNumber(prob) ? Math.floor(index) : index.floor().toNumber();
    var fracPart = isNumber(prob) ? index % 1 : index.minus(integerPart);
    if (isInteger2(index)) {
      return sorted ? flat[index] : partitionSelect(flat, isNumber(prob) ? index : index.valueOf());
    }
    var left;
    var right;
    if (sorted) {
      left = flat[integerPart];
      right = flat[integerPart + 1];
    } else {
      right = partitionSelect(flat, integerPart + 1);
      left = flat[integerPart];
      for (var i = 0;i < integerPart; ++i) {
        if (compare(flat[i], left) > 0) {
          left = flat[i];
        }
      }
    }
    return add2(multiply(left, subtract(1, fracPart)), multiply(right, fracPart));
  }
});
// node_modules/mathjs/lib/esm/function/statistics/std.js
var name260 = "std";
var dependencies261 = ["typed", "map", "sqrt", "variance"];
var createStd = /* @__PURE__ */ factory(name260, dependencies261, (_ref) => {
  var {
    typed: typed2,
    map: map2,
    sqrt: sqrt2,
    variance
  } = _ref;
  return typed2(name260, {
    "Array | Matrix": _std,
    "Array | Matrix, string": _std,
    "Array | Matrix, number | BigNumber": _std,
    "Array | Matrix, number | BigNumber, string": _std,
    "...": function _(args) {
      return _std(args);
    }
  });
  function _std(array, normalization) {
    if (array.length === 0) {
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    }
    try {
      var v = variance.apply(null, arguments);
      if (isCollection(v)) {
        return map2(v, sqrt2);
      } else {
        return sqrt2(v);
      }
    } catch (err) {
      if (err instanceof TypeError && err.message.includes(" variance")) {
        throw new TypeError(err.message.replace(" variance", " std"));
      } else {
        throw err;
      }
    }
  }
});
// node_modules/mathjs/lib/esm/function/statistics/corr.js
var name261 = "corr";
var dependencies262 = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"];
var createCorr = /* @__PURE__ */ factory(name261, dependencies262, (_ref) => {
  var {
    typed: typed2,
    matrix,
    sqrt: sqrt2,
    sum: sum2,
    add: add2,
    subtract,
    multiply,
    pow: pow2,
    divide: divide2
  } = _ref;
  return typed2(name261, {
    "Array, Array": function Array_Array(A, B) {
      return _corr(A, B);
    },
    "Matrix, Matrix": function Matrix_Matrix(A, B) {
      var res = _corr(A.toArray(), B.toArray());
      return Array.isArray(res) ? matrix(res) : res;
    }
  });
  function _corr(A, B) {
    var correlations = [];
    if (Array.isArray(A[0]) && Array.isArray(B[0])) {
      if (A.length !== B.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
      }
      for (var i = 0;i < A.length; i++) {
        if (A[i].length !== B[i].length) {
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
        }
        correlations.push(correlation(A[i], B[i]));
      }
      return correlations;
    } else {
      if (A.length !== B.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
      }
      return correlation(A, B);
    }
  }
  function correlation(A, B) {
    var n = A.length;
    var sumX = sum2(A);
    var sumY = sum2(B);
    var sumXY = A.reduce((acc, x, index) => add2(acc, multiply(x, B[index])), 0);
    var sumXSquare = sum2(A.map((x) => pow2(x, 2)));
    var sumYSquare = sum2(B.map((y) => pow2(y, 2)));
    var numerator = subtract(multiply(n, sumXY), multiply(sumX, sumY));
    var denominator = sqrt2(multiply(subtract(multiply(n, sumXSquare), pow2(sumX, 2)), subtract(multiply(n, sumYSquare), pow2(sumY, 2))));
    return divide2(numerator, denominator);
  }
});
// node_modules/mathjs/lib/esm/function/probability/combinations.js
var name262 = "combinations";
var dependencies263 = ["typed"];
var createCombinations = /* @__PURE__ */ factory(name262, dependencies263, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name262, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumber_BigNumber(n, k) {
      var BigNumber = n.constructor;
      var result, i;
      var nMinusk = n.minus(k);
      var one = new BigNumber(1);
      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one;
      if (k.lt(nMinusk)) {
        for (i = one;i.lte(nMinusk); i = i.plus(one)) {
          result = result.times(k.plus(i)).dividedBy(i);
        }
      } else {
        for (i = one;i.lte(k); i = i.plus(one)) {
          result = result.times(nMinusk.plus(i)).dividedBy(i);
        }
      }
      return result;
    }
  });
});
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}
// node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
var name263 = "combinationsWithRep";
var dependencies264 = ["typed"];
var createCombinationsWithRep = /* @__PURE__ */ factory(name263, dependencies264, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name263, {
    "number, number": function number_number(n, k) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n < 1) {
        throw new TypeError("k must be less than or equal to n + k - 1");
      }
      if (k < n - 1) {
        var _prodrange = product2(n, n + k - 1);
        return _prodrange / product2(1, k);
      }
      var prodrange = product2(k + 1, n + k - 1);
      return prodrange / product2(1, n - 1);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(n, k) {
      var BigNumber = n.constructor;
      var result, i;
      var one = new BigNumber(1);
      var nMinusOne = n.minus(one);
      if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n.lt(one)) {
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      }
      result = one;
      if (k.lt(nMinusOne)) {
        for (i = one;i.lte(nMinusOne); i = i.plus(one)) {
          result = result.times(k.plus(i)).dividedBy(i);
        }
      } else {
        for (i = one;i.lte(k); i = i.plus(one)) {
          result = result.times(nMinusOne.plus(i)).dividedBy(i);
        }
      }
      return result;
    }
  });
});
function isPositiveInteger2(n) {
  return n.isInteger() && n.gte(0);
}
// node_modules/mathjs/lib/esm/function/probability/gamma.js
var name264 = "gamma";
var dependencies265 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = /* @__PURE__ */ factory(name264, dependencies265, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    multiplyScalar,
    pow: pow2,
    BigNumber: _BigNumber,
    Complex: Complex2
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex2(1 - n.re, -n.im);
      var r = new Complex2(Math.PI * n.re, Math.PI * n.im);
      return new Complex2(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex2(n.re - 1, n.im);
    var x = new Complex2(gammaP[0], 0);
    for (var i = 1;i < gammaP.length; ++i) {
      var gammaPval = new Complex2(gammaP[i], 0);
      x = x.add(gammaPval.div(n.add(i)));
    }
    var t = new Complex2(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed2(name264, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config4.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p = n;
    var prod = new Big(n);
    var sum2 = n.toNumber();
    while (p > 2) {
      p -= 2;
      sum2 += p;
      prod = prod.times(sum2);
    }
    return new _BigNumber(prod.toPrecision(_BigNumber.precision));
  }
});
// node_modules/mathjs/lib/esm/function/probability/lgamma.js
var name265 = "lgamma";
var dependencies266 = ["Complex", "typed"];
var createLgamma = /* @__PURE__ */ factory(name265, dependencies266, (_ref) => {
  var {
    Complex: Complex2,
    typed: typed2
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 0.0008417508417508417, -0.0005952380952380953, 0.0007936507936507937, -0.002777777777777778, 0.08333333333333333];
  return typed2(name265, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex2(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex2(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex2(1 - n.re, -n.im));
      return new Complex2(LOGPI, tmp).sub(a).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z) {
    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
    var rz = new Complex2(1, 0).div(z);
    var rzz = rz.div(z);
    var a = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i = 2;i < 8; i++) {
      var tmp = b;
      b = -s * a + coeffs[i];
      a = r * a + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z;
    z = z.add(1);
    while (z.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0)
        signflips++;
      sb = nsb;
      z = z.add(1);
    }
    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex2(0, signflips * 2 * Math.PI * 1));
  }
});
// node_modules/mathjs/lib/esm/function/probability/factorial.js
var name266 = "factorial";
var dependencies267 = ["typed", "gamma"];
var createFactorial = /* @__PURE__ */ factory(name266, dependencies267, (_ref) => {
  var {
    typed: typed2,
    gamma
  } = _ref;
  return typed2(name266, {
    number: function number(n) {
      if (n < 0) {
        throw new Error("Value must be non-negative");
      }
      return gamma(n + 1);
    },
    BigNumber: function BigNumber(n) {
      if (n.isNegative()) {
        throw new Error("Value must be non-negative");
      }
      return gamma(n.plus(1));
    },
    "Array | Matrix": typed2.referToSelf((self2) => (n) => deepMap(n, self2))
  });
});
// node_modules/mathjs/lib/esm/function/probability/kldivergence.js
var name267 = "kldivergence";
var dependencies268 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = /* @__PURE__ */ factory(name267, dependencies268, (_ref) => {
  var {
    typed: typed2,
    matrix,
    divide: divide2,
    sum: sum2,
    multiply,
    map: map2,
    dotDivide,
    log: log3,
    isNumeric
  } = _ref;
  return typed2(name267, {
    "Array, Array": function Array_Array(q, p) {
      return _kldiv(matrix(q), matrix(p));
    },
    "Matrix, Array": function Matrix_Array(q, p) {
      return _kldiv(q, matrix(p));
    },
    "Array, Matrix": function Array_Matrix(q, p) {
      return _kldiv(matrix(q), p);
    },
    "Matrix, Matrix": function Matrix_Matrix(q, p) {
      return _kldiv(q, p);
    }
  });
  function _kldiv(q, p) {
    var plength = p.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum2(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum2(p);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide2(q, sum2(q));
    var pnorm = divide2(p, sum2(p));
    var result = sum2(multiply(qnorm, map2(dotDivide(qnorm, pnorm), (x) => log3(x))));
    if (isNumeric(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});
// node_modules/mathjs/lib/esm/function/probability/multinomial.js
var name268 = "multinomial";
var dependencies269 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
var createMultinomial = /* @__PURE__ */ factory(name268, dependencies269, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2,
    multiply,
    factorial,
    isInteger: isInteger2,
    isPositive
  } = _ref;
  return typed2(name268, {
    "Array | Matrix": function Array__Matrix(a) {
      var sum2 = 0;
      var denom = 1;
      deepForEach(a, function(ai) {
        if (!isInteger2(ai) || !isPositive(ai)) {
          throw new TypeError("Positive integer value expected in function multinomial");
        }
        sum2 = add2(sum2, ai);
        denom = multiply(denom, factorial(ai));
      });
      return divide2(factorial(sum2), denom);
    }
  });
});
// node_modules/mathjs/lib/esm/function/probability/permutations.js
var name269 = "permutations";
var dependencies270 = ["typed", "factorial"];
var createPermutations = /* @__PURE__ */ factory(name269, dependencies270, (_ref) => {
  var {
    typed: typed2,
    factorial
  } = _ref;
  return typed2(name269, {
    "number | BigNumber": factorial,
    "number, number": function number_number(n, k) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k > n) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      return product2(n - k + 1, n);
    },
    "BigNumber, BigNumber": function BigNumber_BigNumber(n, k) {
      var result, i;
      if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k.gt(n)) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      var one = n.mul(0).add(1);
      result = one;
      for (i = n.minus(k).plus(1);i.lte(n); i = i.plus(1)) {
        result = result.times(i);
      }
      return result;
    }
  });
});
function isPositiveInteger3(n) {
  return n.isInteger() && n.gte(0);
}
// node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
var import_seedrandom = __toESM(require_seedrandom2(), 1);
var singletonRandom = /* @__PURE__ */ import_seedrandom.default(Date.now());
function createRng(randomSeed) {
  var random2;
  function setSeed(seed) {
    random2 = seed === null ? singletonRandom : import_seedrandom.default(String(seed));
  }
  setSeed(randomSeed);
  function rng() {
    return random2();
  }
  return rng;
}

// node_modules/mathjs/lib/esm/function/probability/pickRandom.js
var name270 = "pickRandom";
var dependencies271 = ["typed", "config", "?on"];
var createPickRandom = /* @__PURE__ */ factory(name270, dependencies271, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    on: on2
  } = _ref;
  var rng = createRng(config4.randomSeed);
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name270, {
    "Array | Matrix": function Array__Matrix(possibles) {
      return _pickRandom(possibles, {});
    },
    "Array | Matrix, Object": function Array__Matrix_Object(possibles, options) {
      return _pickRandom(possibles, options);
    },
    "Array | Matrix, number": function Array__Matrix_number(possibles, number) {
      return _pickRandom(possibles, {
        number
      });
    },
    "Array | Matrix, Array | Matrix": function Array__Matrix_Array__Matrix(possibles, weights) {
      return _pickRandom(possibles, {
        weights
      });
    },
    "Array | Matrix, Array | Matrix, number": function Array__Matrix_Array__Matrix_number(possibles, weights, number) {
      return _pickRandom(possibles, {
        number,
        weights
      });
    },
    "Array | Matrix, number, Array | Matrix": function Array__Matrix_number_Array__Matrix(possibles, number, weights) {
      return _pickRandom(possibles, {
        number,
        weights
      });
    }
  });
  function _pickRandom(possibles, _ref2) {
    var {
      number,
      weights,
      elementWise = true
    } = _ref2;
    var single = typeof number === "undefined";
    if (single) {
      number = 1;
    }
    var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
    possibles = possibles.valueOf();
    if (weights) {
      weights = weights.valueOf();
    }
    if (elementWise === true) {
      possibles = flatten(possibles);
      weights = flatten(weights);
    }
    var totalWeights = 0;
    if (typeof weights !== "undefined") {
      if (weights.length !== possibles.length) {
        throw new Error("Weights must have the same length as possibles");
      }
      for (var i = 0, len = weights.length;i < len; i++) {
        if (!isNumber(weights[i]) || weights[i] < 0) {
          throw new Error("Weights must be an array of positive numbers");
        }
        totalWeights += weights[i];
      }
    }
    var length = possibles.length;
    var result = [];
    var pick;
    while (result.length < number) {
      if (typeof weights === "undefined") {
        pick = possibles[Math.floor(rng() * length)];
      } else {
        var randKey = rng() * totalWeights;
        for (var _i = 0, _len = possibles.length;_i < _len; _i++) {
          randKey -= weights[_i];
          if (randKey < 0) {
            pick = possibles[_i];
            break;
          }
        }
      }
      result.push(pick);
    }
    return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
  }
});
// node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
function randomMatrix(size, random2) {
  var data = [];
  size = size.slice(0);
  if (size.length > 1) {
    for (var i = 0, length = size.shift();i < length; i++) {
      data.push(randomMatrix(size, random2));
    }
  } else {
    for (var _i = 0, _length = size.shift();_i < _length; _i++) {
      data.push(random2());
    }
  }
  return data;
}

// node_modules/mathjs/lib/esm/function/probability/random.js
var name271 = "random";
var dependencies272 = ["typed", "config", "?on"];
var createRandom = /* @__PURE__ */ factory(name271, dependencies272, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    on: on2
  } = _ref;
  var rng = createRng(config4.randomSeed);
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name271, {
    "": () => _random(0, 1),
    number: (max2) => _random(0, max2),
    "number, number": (min2, max2) => _random(min2, max2),
    "Array | Matrix": (size) => _randomMatrix(size, 0, 1),
    "Array | Matrix, number": (size, max2) => _randomMatrix(size, 0, max2),
    "Array | Matrix, number, number": (size, min2, max2) => _randomMatrix(size, min2, max2)
  });
  function _randomMatrix(size, min2, max2) {
    var res = randomMatrix(size.valueOf(), () => _random(min2, max2));
    return isMatrix(size) ? size.create(res, "number") : res;
  }
  function _random(min2, max2) {
    return min2 + rng() * (max2 - min2);
  }
});
// node_modules/mathjs/lib/esm/function/probability/randomInt.js
var name272 = "randomInt";
var dependencies273 = ["typed", "config", "log2", "?on"];
var simpleCutoff = 2n ** 30n;
var createRandomInt = /* @__PURE__ */ factory(name272, dependencies273, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    log2: log24,
    on: on2
  } = _ref;
  var rng = createRng(config4.randomSeed);
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name272, {
    "": () => _randomInt(0, 2),
    number: (max2) => _randomInt(0, max2),
    "number, number": (min2, max2) => _randomInt(min2, max2),
    bigint: (max2) => _randomBigint(0n, max2),
    "bigint, bigint": _randomBigint,
    "Array | Matrix": (size) => _randomIntMatrix(size, 0, 1),
    "Array | Matrix, number": (size, max2) => _randomIntMatrix(size, 0, max2),
    "Array | Matrix, number, number": (size, min2, max2) => _randomIntMatrix(size, min2, max2)
  });
  function _randomIntMatrix(size, min2, max2) {
    var res = randomMatrix(size.valueOf(), () => _randomInt(min2, max2));
    return isMatrix(size) ? size.create(res, "number") : res;
  }
  function _randomInt(min2, max2) {
    return Math.floor(min2 + rng() * (max2 - min2));
  }
  function _randomBigint(min2, max2) {
    var width = max2 - min2;
    if (width <= simpleCutoff) {
      return min2 + BigInt(_randomInt(0, Number(width)));
    }
    var bits = log24(width);
    var picked = width;
    while (picked >= width) {
      picked = 0n;
      for (var i = 0;i < bits; ++i) {
        picked = 2n * picked + (rng() < 0.5 ? 0n : 1n);
      }
    }
    return min2 + picked;
  }
});
// node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
var name273 = "stirlingS2";
var dependencies274 = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
var createStirlingS2 = /* @__PURE__ */ factory(name273, dependencies274, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    subtractScalar,
    multiplyScalar,
    divideScalar,
    pow: pow2,
    factorial,
    combinations,
    isNegative,
    isInteger: isInteger2,
    number,
    bignumber,
    larger
  } = _ref;
  var smallCache = [];
  var bigCache = [];
  return typed2(name273, {
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, k) {
      if (!isInteger2(n) || isNegative(n) || !isInteger2(k) || isNegative(k)) {
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      } else if (larger(k, n)) {
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      }
      var big = !(isNumber(n) && isNumber(k));
      var cache = big ? bigCache : smallCache;
      var make = big ? bignumber : number;
      var nn = number(n);
      var nk = number(k);
      if (cache[nn] && cache[nn].length > nk) {
        return cache[nn][nk];
      }
      for (var m = 0;m <= nn; ++m) {
        if (!cache[m]) {
          cache[m] = [m === 0 ? make(1) : make(0)];
        }
        if (m === 0)
          continue;
        var row = cache[m];
        var prev = cache[m - 1];
        for (var i = row.length;i <= m && i <= nk; ++i) {
          if (i === m) {
            row[i] = 1;
          } else {
            row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);
          }
        }
      }
      return cache[nn][nk];
    }
  });
});
// node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
var name274 = "bellNumbers";
var dependencies275 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
var createBellNumbers = /* @__PURE__ */ factory(name274, dependencies275, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    isNegative,
    isInteger: isInteger2,
    stirlingS2
  } = _ref;
  return typed2(name274, {
    "number | BigNumber": function number__BigNumber(n) {
      if (!isInteger2(n) || isNegative(n)) {
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      }
      var result = 0;
      for (var i = 0;i <= n; i++) {
        result = addScalar(result, stirlingS2(n, i));
      }
      return result;
    }
  });
});
// node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
var name275 = "catalan";
var dependencies276 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
var createCatalan = /* @__PURE__ */ factory(name275, dependencies276, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    divideScalar,
    multiplyScalar,
    combinations,
    isNegative,
    isInteger: isInteger2
  } = _ref;
  return typed2(name275, {
    "number | BigNumber": function number__BigNumber(n) {
      if (!isInteger2(n) || isNegative(n)) {
        throw new TypeError("Non-negative integer value expected in function catalan");
      }
      return divideScalar(combinations(multiplyScalar(n, 2), n), addScalar(n, 1));
    }
  });
});
// node_modules/mathjs/lib/esm/function/combinatorics/composition.js
var name276 = "composition";
var dependencies277 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
var createComposition = /* @__PURE__ */ factory(name276, dependencies277, (_ref) => {
  var {
    typed: typed2,
    addScalar,
    combinations,
    isPositive,
    isNegative,
    isInteger: isInteger2,
    larger
  } = _ref;
  return typed2(name276, {
    "number | BigNumber, number | BigNumber": function number__BigNumber_number__BigNumber(n, k) {
      if (!isInteger2(n) || !isPositive(n) || !isInteger2(k) || !isPositive(k)) {
        throw new TypeError("Positive integer value expected in function composition");
      } else if (larger(k, n)) {
        throw new TypeError("k must be less than or equal to n in function composition");
      }
      return combinations(addScalar(n, -1), addScalar(k, -1));
    }
  });
});
// node_modules/mathjs/lib/esm/function/algebra/leafCount.js
var name277 = "leafCount";
var dependencies278 = ["parse", "typed"];
var createLeafCount = /* @__PURE__ */ factory(name277, dependencies278, (_ref) => {
  var {
    parse: parse3,
    typed: typed2
  } = _ref;
  function countLeaves(node) {
    var count = 0;
    node.forEach((n) => {
      count += countLeaves(n);
    });
    return count || 1;
  }
  return typed2(name277, {
    Node: function Node(expr) {
      return countLeaves(expr);
    }
  });
});
// node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js
function isNumericNode(x) {
  return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);
}
function isConstantExpression(x) {
  if (isConstantNode(x)) {
    return true;
  }
  if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {
    return true;
  }
  if (isParenthesisNode(x) && isConstantExpression(x.content)) {
    return true;
  }
  return false;
}

// node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
function ownKeys3(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e2) {
  for (var r = 1;r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name278 = "simplifyUtil";
var dependencies279 = ["FunctionNode", "OperatorNode", "SymbolNode"];
var createUtil = /* @__PURE__ */ factory(name278, dependencies279, (_ref) => {
  var {
    FunctionNode,
    OperatorNode,
    SymbolNode
  } = _ref;
  var T2 = true;
  var F = false;
  var defaultName = "defaultF";
  var defaultContext = {
    add: {
      trivial: T2,
      total: T2,
      commutative: T2,
      associative: T2
    },
    unaryPlus: {
      trivial: T2,
      total: T2,
      commutative: T2,
      associative: T2
    },
    subtract: {
      trivial: F,
      total: T2,
      commutative: F,
      associative: F
    },
    multiply: {
      trivial: T2,
      total: T2,
      commutative: T2,
      associative: T2
    },
    divide: {
      trivial: F,
      total: T2,
      commutative: F,
      associative: F
    },
    paren: {
      trivial: T2,
      total: T2,
      commutative: T2,
      associative: F
    },
    defaultF: {
      trivial: F,
      total: T2,
      commutative: F,
      associative: F
    }
  };
  var realContext = {
    divide: {
      total: F
    },
    log: {
      total: F
    }
  };
  var positiveContext = {
    subtract: {
      total: F
    },
    abs: {
      trivial: T2
    },
    log: {
      total: T2
    }
  };
  function hasProperty(nodeOrName, property) {
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;
    var name279 = defaultName;
    if (typeof nodeOrName === "string") {
      name279 = nodeOrName;
    } else if (isOperatorNode(nodeOrName)) {
      name279 = nodeOrName.fn.toString();
    } else if (isFunctionNode(nodeOrName)) {
      name279 = nodeOrName.name;
    } else if (isParenthesisNode(nodeOrName)) {
      name279 = "paren";
    }
    if (hasOwnProperty(context, name279)) {
      var properties2 = context[name279];
      if (hasOwnProperty(properties2, property)) {
        return properties2[property];
      }
      if (hasOwnProperty(defaultContext, name279)) {
        return defaultContext[name279][property];
      }
    }
    if (hasOwnProperty(context, defaultName)) {
      var _properties = context[defaultName];
      if (hasOwnProperty(_properties, property)) {
        return _properties[property];
      }
      return defaultContext[defaultName][property];
    }
    if (hasOwnProperty(defaultContext, name279)) {
      var _properties2 = defaultContext[name279];
      if (hasOwnProperty(_properties2, property)) {
        return _properties2[property];
      }
    }
    return defaultContext[defaultName][property];
  }
  function isCommutative(node) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
    return hasProperty(node, "commutative", context);
  }
  function isAssociative(node) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
    return hasProperty(node, "associative", context);
  }
  function mergeContext(primary, secondary) {
    var merged = _objectSpread3({}, primary);
    for (var prop in secondary) {
      if (hasOwnProperty(primary, prop)) {
        merged[prop] = _objectSpread3(_objectSpread3({}, secondary[prop]), primary[prop]);
      } else {
        merged[prop] = secondary[prop];
      }
    }
    return merged;
  }
  function flatten2(node, context) {
    if (!node.args || node.args.length === 0) {
      return node;
    }
    node.args = allChildren(node, context);
    for (var i = 0;i < node.args.length; i++) {
      flatten2(node.args[i], context);
    }
  }
  function allChildren(node, context) {
    var op;
    var children = [];
    var _findChildren = function findChildren(node2) {
      for (var i = 0;i < node2.args.length; i++) {
        var child = node2.args[i];
        if (isOperatorNode(child) && op === child.op) {
          _findChildren(child);
        } else {
          children.push(child);
        }
      }
    };
    if (isAssociative(node, context)) {
      op = node.op;
      _findChildren(node);
      return children;
    } else {
      return node.args;
    }
  }
  function unflattenr(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i = 0;i < l; i++) {
      unflattenr(node.args[i], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.pop();
      while (node.args.length > 0) {
        curnode = makeNode([node.args.pop(), curnode]);
      }
      node.args = curnode.args;
    }
  }
  function unflattenl(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i = 0;i < l; i++) {
      unflattenl(node.args[i], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.shift();
      while (node.args.length > 0) {
        curnode = makeNode([curnode, node.args.shift()]);
      }
      node.args = curnode.args;
    }
  }
  function createMakeNodeFunction(node) {
    if (isOperatorNode(node)) {
      return function(args) {
        try {
          return new OperatorNode(node.op, node.fn, args, node.implicit);
        } catch (err) {
          console.error(err);
          return [];
        }
      };
    } else {
      return function(args) {
        return new FunctionNode(new SymbolNode(node.name), args);
      };
    }
  }
  return {
    createMakeNodeFunction,
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten2,
    allChildren,
    unflattenr,
    unflattenl,
    defaultContext,
    realContext,
    positiveContext
  };
});

// node_modules/mathjs/lib/esm/function/algebra/simplify.js
var name279 = "simplify";
var dependencies280 = ["typed", "parse", "equal", "resolve", "simplifyConstant", "simplifyCore", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode", "replacer"];
var createSimplify = /* @__PURE__ */ factory(name279, dependencies280, (_ref) => {
  var {
    typed: typed2,
    parse: parse3,
    equal,
    resolve,
    simplifyConstant,
    simplifyCore,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode,
    replacer
  } = _ref;
  var {
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten2,
    unflattenr,
    unflattenl,
    createMakeNodeFunction,
    defaultContext,
    realContext,
    positiveContext
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  typed2.addConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  var simplify = typed2("simplify", {
    Node: _simplify,
    "Node, Map": (expr, scope) => _simplify(expr, false, scope),
    "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
    "Node, Array": _simplify,
    "Node, Array, Map": _simplify,
    "Node, Array, Map, Object": _simplify
  });
  typed2.removeConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  simplify.defaultContext = defaultContext;
  simplify.realContext = realContext;
  simplify.positiveContext = positiveContext;
  function removeParens(node) {
    return node.transform(function(node2) {
      return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
    });
  }
  var SUPPORTED_CONSTANTS = {
    true: true,
    false: true,
    e: true,
    i: true,
    Infinity: true,
    LN2: true,
    LN10: true,
    LOG2E: true,
    LOG10E: true,
    NaN: true,
    phi: true,
    pi: true,
    SQRT1_2: true,
    SQRT2: true,
    tau: true
  };
  simplify.rules = [
    simplifyCore,
    {
      l: "log(e)",
      r: "1"
    },
    {
      s: "n-n1 -> n+-n1",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n-n -> 0",
      assuming: {
        subtract: {
          total: false
        }
      }
    },
    {
      s: "-(cl*v) -> v * (-cl)",
      assuming: {
        multiply: {
          commutative: true
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(cl*v) -> (-cl) * v",
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(v*cl) -> v * (-cl)",
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: true
    },
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: " vd   * ( vd   * n1 + n2)",
      r: "vd^2       * n1 +  vd   * n2"
    },
    {
      s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    simplifyConstant,
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: true
        }
      }
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "vd*n + vd",
      r: "vd*(n+1)"
    },
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    {
      s: "n*vd + vd -> (n+1)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "vd + n*vd -> (1+n)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n^n1 * n -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n*cd + cd",
      r: "(n+1)*cd"
    },
    {
      s: "cd*n + cd -> cd*(n+1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "cd + cd*n -> cd*(1+n)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    simplifyConstant,
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      assuming: {
        subtract: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "ce+ve -> ve+ce",
      assuming: {
        add: {
          commutative: true
        }
      },
      imposeContext: {
        add: {
          commutative: false
        }
      }
    },
    {
      s: "vd*cd -> cd*vd",
      assuming: {
        multiply: {
          commutative: true
        }
      },
      imposeContext: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n+-n1",
      r: "n-n1"
    },
    {
      l: "n+-(n1)",
      r: "n-(n1)"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      l: "n^1",
      r: "n"
    },
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      assuming: {
        addition: {
          associative: true,
          commutative: true
        }
      }
    },
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function _canonicalizeRule(ruleObject, context) {
    var newRule = {};
    if (ruleObject.s) {
      var lr = ruleObject.s.split("->");
      if (lr.length === 2) {
        newRule.l = lr[0];
        newRule.r = lr[1];
      } else {
        throw SyntaxError("Could not parse rule: " + ruleObject.s);
      }
    } else {
      newRule.l = ruleObject.l;
      newRule.r = ruleObject.r;
    }
    newRule.l = removeParens(parse3(newRule.l));
    newRule.r = removeParens(parse3(newRule.r));
    for (var prop of ["imposeContext", "repeat", "assuming"]) {
      if (prop in ruleObject) {
        newRule[prop] = ruleObject[prop];
      }
    }
    if (ruleObject.evaluate) {
      newRule.evaluate = parse3(ruleObject.evaluate);
    }
    if (isAssociative(newRule.l, context)) {
      var nonCommutative = !isCommutative(newRule.l, context);
      var leftExpandsym;
      if (nonCommutative)
        leftExpandsym = _getExpandPlaceholderSymbol();
      var makeNode = createMakeNodeFunction(newRule.l);
      var expandsym = _getExpandPlaceholderSymbol();
      newRule.expanded = {};
      newRule.expanded.l = makeNode([newRule.l, expandsym]);
      flatten2(newRule.expanded.l, context);
      unflattenr(newRule.expanded.l, context);
      newRule.expanded.r = makeNode([newRule.r, expandsym]);
      if (nonCommutative) {
        newRule.expandedNC1 = {};
        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
        newRule.expandedNC2 = {};
        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
      }
    }
    return newRule;
  }
  function _buildRules(rules, context) {
    var ruleSet = [];
    for (var i = 0;i < rules.length; i++) {
      var rule = rules[i];
      var newRule = undefined;
      var ruleType = typeof rule;
      switch (ruleType) {
        case "string":
          rule = {
            s: rule
          };
        case "object":
          newRule = _canonicalizeRule(rule, context);
          break;
        case "function":
          newRule = rule;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + ruleType);
      }
      ruleSet.push(newRule);
    }
    return ruleSet;
  }
  var _lastsym = 0;
  function _getExpandPlaceholderSymbol() {
    return new SymbolNode("_p" + _lastsym++);
  }
  function _simplify(expr, rules) {
    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createEmptyMap();
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var debug = options.consoleDebug;
    rules = _buildRules(rules || simplify.rules, options.context);
    var res = resolve(expr, scope);
    res = removeParens(res);
    var visited = {};
    var str = res.toString({
      parenthesis: "all"
    });
    while (!visited[str]) {
      visited[str] = true;
      _lastsym = 0;
      var laststr = str;
      if (debug)
        console.log("Working on: ", str);
      for (var i = 0;i < rules.length; i++) {
        var rulestr = "";
        if (typeof rules[i] === "function") {
          res = rules[i](res, options);
          if (debug)
            rulestr = rules[i].name;
        } else {
          flatten2(res, options.context);
          res = applyRule(res, rules[i], options.context);
          if (debug) {
            rulestr = "".concat(rules[i].l.toString(), " -> ").concat(rules[i].r.toString());
          }
        }
        if (debug) {
          var newstr = res.toString({
            parenthesis: "all"
          });
          if (newstr !== laststr) {
            console.log("Applying", rulestr, "produced", newstr);
            laststr = newstr;
          }
        }
        unflattenl(res, options.context);
      }
      str = res.toString({
        parenthesis: "all"
      });
    }
    return res;
  }
  function mapRule(nodes, rule, context) {
    var resNodes = nodes;
    if (nodes) {
      for (var i = 0;i < nodes.length; ++i) {
        var newNode = applyRule(nodes[i], rule, context);
        if (newNode !== nodes[i]) {
          if (resNodes === nodes) {
            resNodes = nodes.slice();
          }
          resNodes[i] = newNode;
        }
      }
    }
    return resNodes;
  }
  function applyRule(node, rule, context) {
    if (rule.assuming) {
      for (var symbol in rule.assuming) {
        for (var property in rule.assuming[symbol]) {
          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
            return node;
          }
        }
      }
    }
    var mergedContext = mergeContext(rule.imposeContext, context);
    var res = node;
    if (res instanceof OperatorNode || res instanceof FunctionNode) {
      var newArgs = mapRule(res.args, rule, context);
      if (newArgs !== res.args) {
        res = res.clone();
        res.args = newArgs;
      }
    } else if (res instanceof ParenthesisNode) {
      if (res.content) {
        var newContent = applyRule(res.content, rule, context);
        if (newContent !== res.content) {
          res = new ParenthesisNode(newContent);
        }
      }
    } else if (res instanceof ArrayNode) {
      var newItems = mapRule(res.items, rule, context);
      if (newItems !== res.items) {
        res = new ArrayNode(newItems);
      }
    } else if (res instanceof AccessorNode) {
      var newObj = res.object;
      if (res.object) {
        newObj = applyRule(res.object, rule, context);
      }
      var newIndex = res.index;
      if (res.index) {
        newIndex = applyRule(res.index, rule, context);
      }
      if (newObj !== res.object || newIndex !== res.index) {
        res = new AccessorNode(newObj, newIndex);
      }
    } else if (res instanceof IndexNode) {
      var newDims = mapRule(res.dimensions, rule, context);
      if (newDims !== res.dimensions) {
        res = new IndexNode(newDims);
      }
    } else if (res instanceof ObjectNode) {
      var changed = false;
      var newProps = {};
      for (var prop in res.properties) {
        newProps[prop] = applyRule(res.properties[prop], rule, context);
        if (newProps[prop] !== res.properties[prop]) {
          changed = true;
        }
      }
      if (changed) {
        res = new ObjectNode(newProps);
      }
    }
    var repl = rule.r;
    var matches = _ruleMatch(rule.l, res, mergedContext)[0];
    if (!matches && rule.expanded) {
      repl = rule.expanded.r;
      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
    }
    if (!matches && rule.expandedNC1) {
      repl = rule.expandedNC1.r;
      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
      if (!matches) {
        repl = rule.expandedNC2.r;
        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
      }
    }
    if (matches) {
      var implicit = res.implicit;
      res = repl.clone();
      if (implicit && "implicit" in repl) {
        res.implicit = true;
      }
      res = res.transform(function(node2) {
        if (node2.isSymbolNode && hasOwnProperty(matches.placeholders, node2.name)) {
          return matches.placeholders[node2.name].clone();
        } else {
          return node2;
        }
      });
    }
    if (rule.repeat && res !== node) {
      res = applyRule(res, rule, context);
    }
    return res;
  }
  function getSplits(node, context) {
    var res = [];
    var right, rightArgs;
    var makeNode = createMakeNodeFunction(node);
    if (isCommutative(node, context)) {
      for (var i = 0;i < node.args.length; i++) {
        rightArgs = node.args.slice(0);
        rightArgs.splice(i, 1);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[i], right]));
      }
    } else {
      for (var _i = 1;_i < node.args.length; _i++) {
        var left = node.args[0];
        if (_i > 1) {
          left = makeNode(node.args.slice(0, _i));
        }
        rightArgs = node.args.slice(_i);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([left, right]));
      }
    }
    return res;
  }
  function mergeMatch(match1, match2) {
    var res = {
      placeholders: {}
    };
    if (!match1.placeholders && !match2.placeholders) {
      return res;
    } else if (!match1.placeholders) {
      return match2;
    } else if (!match2.placeholders) {
      return match1;
    }
    for (var key in match1.placeholders) {
      if (hasOwnProperty(match1.placeholders, key)) {
        res.placeholders[key] = match1.placeholders[key];
        if (hasOwnProperty(match2.placeholders, key)) {
          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
            return null;
          }
        }
      }
    }
    for (var _key in match2.placeholders) {
      if (hasOwnProperty(match2.placeholders, _key)) {
        res.placeholders[_key] = match2.placeholders[_key];
      }
    }
    return res;
  }
  function combineChildMatches(list1, list2) {
    var res = [];
    if (list1.length === 0 || list2.length === 0) {
      return res;
    }
    var merged;
    for (var i1 = 0;i1 < list1.length; i1++) {
      for (var i22 = 0;i22 < list2.length; i22++) {
        merged = mergeMatch(list1[i1], list2[i22]);
        if (merged) {
          res.push(merged);
        }
      }
    }
    return res;
  }
  function mergeChildMatches(childMatches) {
    if (childMatches.length === 0) {
      return childMatches;
    }
    var sets = childMatches.reduce(combineChildMatches);
    var uniqueSets = [];
    var unique = {};
    for (var i = 0;i < sets.length; i++) {
      var s = JSON.stringify(sets[i], replacer);
      if (!unique[s]) {
        unique[s] = true;
        uniqueSets.push(sets[i]);
      }
    }
    return uniqueSets;
  }
  function _ruleMatch(rule, node, context, isSplit) {
    var res = [{
      placeholders: {}
    }];
    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
      if (rule instanceof OperatorNode) {
        if (rule.op !== node.op || rule.fn !== node.fn) {
          return [];
        }
      } else if (rule instanceof FunctionNode) {
        if (rule.name !== node.name) {
          return [];
        }
      }
      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
        var childMatches = [];
        for (var i = 0;i < rule.args.length; i++) {
          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);
          if (childMatch.length === 0) {
            break;
          }
          childMatches.push(childMatch);
        }
        if (childMatches.length !== rule.args.length) {
          if (!isCommutative(node, context) || rule.args.length === 1) {
            return [];
          }
          if (rule.args.length > 2) {
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          }
          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
          if (leftMatch.length === 0) {
            return [];
          }
          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
          if (rightMatch.length === 0) {
            return [];
          }
          childMatches = [leftMatch, rightMatch];
        }
        res = mergeChildMatches(childMatches);
      } else if (node.args.length >= 2 && rule.args.length === 2) {
        var splits = getSplits(node, context);
        var splitMatches = [];
        for (var _i2 = 0;_i2 < splits.length; _i2++) {
          var matchSet = _ruleMatch(rule, splits[_i2], context, true);
          splitMatches = splitMatches.concat(matchSet);
        }
        return splitMatches;
      } else if (rule.args.length > 2) {
        throw Error("Unexpected non-binary associative function: " + rule.toString());
      } else {
        return [];
      }
    } else if (rule instanceof SymbolNode) {
      if (rule.name.length === 0) {
        throw new Error("Symbol in rule has 0 length...!?");
      }
      if (SUPPORTED_CONSTANTS[rule.name]) {
        if (rule.name !== node.name) {
          return [];
        }
      } else {
        switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
          case "n":
          case "_p":
            res[0].placeholders[rule.name] = node;
            break;
          case "c":
          case "cl":
            if (isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "v":
            if (!isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vl":
            if (isSymbolNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "cd":
            if (isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vd":
            if (!isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ce":
            if (isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ve":
            if (!isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          default:
            throw new Error("Invalid symbol in rule: " + rule.name);
        }
      }
    } else if (rule instanceof ConstantNode) {
      if (!equal(rule.value, node.value)) {
        return [];
      }
    } else {
      return [];
    }
    return res;
  }
  function _exactMatch(p, q) {
    if (p instanceof ConstantNode && q instanceof ConstantNode) {
      if (!equal(p.value, q.value)) {
        return false;
      }
    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
      if (p.name !== q.name) {
        return false;
      }
    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
      if (p instanceof OperatorNode) {
        if (p.op !== q.op || p.fn !== q.fn) {
          return false;
        }
      } else if (p instanceof FunctionNode) {
        if (p.name !== q.name) {
          return false;
        }
      }
      if (p.args.length !== q.args.length) {
        return false;
      }
      for (var i = 0;i < p.args.length; i++) {
        if (!_exactMatch(p.args[i], q.args[i])) {
          return false;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  return simplify;
});
// node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js
var name280 = "simplifyConstant";
var dependencies281 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
var createSimplifyConstant = /* @__PURE__ */ factory(name280, dependencies281, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    mathWithTransform,
    matrix,
    fraction,
    bignumber,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode
  } = _ref;
  var {
    isCommutative,
    isAssociative,
    allChildren,
    createMakeNodeFunction
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  var simplifyConstant = typed2("simplifyConstant", {
    Node: (node) => _ensureNode(foldFraction(node, {})),
    "Node, Object": function Node_Object(expr, options) {
      return _ensureNode(foldFraction(expr, options));
    }
  });
  function _removeFractions(thing) {
    if (isFraction(thing)) {
      return thing.valueOf();
    }
    if (thing instanceof Array) {
      return thing.map(_removeFractions);
    }
    if (isMatrix(thing)) {
      return matrix(_removeFractions(thing.valueOf()));
    }
    return thing;
  }
  function _eval(fnname, args, options) {
    try {
      return mathWithTransform[fnname].apply(null, args);
    } catch (ignore) {
      args = args.map(_removeFractions);
      return _toNumber(mathWithTransform[fnname].apply(null, args), options);
    }
  }
  var _toNode = typed2({
    Fraction: _fractionToNode,
    number: function number(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode(-n));
      }
      return new ConstantNode(n);
    },
    BigNumber: function BigNumber(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode(-n));
      }
      return new ConstantNode(n);
    },
    bigint: function bigint(n) {
      if (n < 0n) {
        return unaryMinusNode(new ConstantNode(-n));
      }
      return new ConstantNode(n);
    },
    Complex: function Complex(s) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function string(s) {
      return new ConstantNode(s);
    },
    Matrix: function Matrix(m) {
      return new ArrayNode(m.valueOf().map((e2) => _toNode(e2)));
    }
  });
  function _ensureNode(thing) {
    if (isNode(thing)) {
      return thing;
    }
    return _toNode(thing);
  }
  function _exactFraction(n, options) {
    var exactFractions = options && options.exactFractions !== false;
    if (exactFractions && isFinite(n) && fraction) {
      var f = fraction(n);
      var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
        return f;
      }
    }
    return n;
  }
  var _toNumber = typed2({
    "string, Object": function string_Object(s, options) {
      var numericType = safeNumberType(s, config4);
      if (numericType === "BigNumber") {
        if (bignumber === undefined) {
          noBignumber();
        }
        return bignumber(s);
      } else if (numericType === "bigint") {
        return BigInt(s);
      } else if (numericType === "Fraction") {
        if (fraction === undefined) {
          noFraction();
        }
        return fraction(s);
      } else {
        var n = parseFloat(s);
        return _exactFraction(n, options);
      }
    },
    "Fraction, Object": function Fraction_Object(s, options) {
      return s;
    },
    "BigNumber, Object": function BigNumber_Object(s, options) {
      return s;
    },
    "number, Object": function number_Object(s, options) {
      return _exactFraction(s, options);
    },
    "bigint, Object": function bigint_Object(s, options) {
      return s;
    },
    "Complex, Object": function Complex_Object(s, options) {
      if (s.im !== 0) {
        return s;
      }
      return _exactFraction(s.re, options);
    },
    "Matrix, Object": function Matrix_Object(s, options) {
      return matrix(_exactFraction(s.valueOf()));
    },
    "Array, Object": function Array_Object(s, options) {
      return s.map(_exactFraction);
    }
  });
  function unaryMinusNode(n) {
    return new OperatorNode("-", "unaryMinus", [n]);
  }
  function _fractionToNode(f) {
    var fromBigInt = (value) => config4.number === "BigNumber" && bignumber ? bignumber(value) : Number(value);
    var numeratorValue = f.s * f.n;
    var numeratorNode = numeratorValue < 0n ? new OperatorNode("-", "unaryMinus", [new ConstantNode(-fromBigInt(numeratorValue))]) : new ConstantNode(fromBigInt(numeratorValue));
    return f.d === 1n ? numeratorNode : new OperatorNode("/", "divide", [numeratorNode, new ConstantNode(fromBigInt(f.d))]);
  }
  function _foldAccessor(obj, index, options) {
    if (!isIndexNode(index)) {
      return new AccessorNode(_ensureNode(obj), _ensureNode(index));
    }
    if (isArrayNode(obj) || isMatrix(obj)) {
      var remainingDims = Array.from(index.dimensions);
      while (remainingDims.length > 0) {
        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
          var first = _toNumber(remainingDims.shift().value, options);
          if (isArrayNode(obj)) {
            obj = obj.items[first - 1];
          } else {
            obj = obj.valueOf()[first - 1];
            if (obj instanceof Array) {
              obj = matrix(obj);
            }
          }
        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
          var second = _toNumber(remainingDims[1].value, options);
          var tryItems = [];
          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
          for (var item of fromItems) {
            if (isArrayNode(item)) {
              tryItems.push(item.items[second - 1]);
            } else if (isMatrix(obj)) {
              tryItems.push(item[second - 1]);
            } else {
              break;
            }
          }
          if (tryItems.length === fromItems.length) {
            if (isArrayNode(obj)) {
              obj = new ArrayNode(tryItems);
            } else {
              obj = matrix(tryItems);
            }
            remainingDims.splice(1, 1);
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (remainingDims.length === index.dimensions.length) {
        return new AccessorNode(_ensureNode(obj), index);
      }
      if (remainingDims.length > 0) {
        index = new IndexNode(remainingDims);
        return new AccessorNode(_ensureNode(obj), index);
      }
      return obj;
    }
    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {
      var key = index.dimensions[0].value;
      if (key in obj.properties) {
        return obj.properties[key];
      }
      return new ConstantNode;
    }
    return new AccessorNode(_ensureNode(obj), index);
  }
  function foldOp(fn, args, makeNode, options) {
    var first = args.shift();
    var reduction = args.reduce((sofar, next) => {
      if (!isNode(next)) {
        var last = sofar.pop();
        if (isNode(last)) {
          return [last, next];
        }
        try {
          sofar.push(_eval(fn, [last, next], options));
          return sofar;
        } catch (ignoreandcontinue) {
          sofar.push(last);
        }
      }
      sofar.push(_ensureNode(sofar.pop()));
      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
      return [makeNode([newtree, _ensureNode(next)])];
    }, [first]);
    if (reduction.length === 1) {
      return reduction[0];
    }
    return makeNode([reduction[0], _toNode(reduction[1])]);
  }
  function foldFraction(node, options) {
    switch (node.type) {
      case "SymbolNode":
        return node;
      case "ConstantNode":
        switch (typeof node.value) {
          case "number":
            return _toNumber(node.value, options);
          case "bigint":
            return _toNumber(node.value, options);
          case "string":
            return node.value;
          default:
            if (!isNaN(node.value))
              return _toNumber(node.value, options);
        }
        return node;
      case "FunctionNode":
        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
          return node;
        }
        {
          var operatorFunctions = ["add", "multiply"];
          if (!operatorFunctions.includes(node.name)) {
            var args = node.args.map((arg) => foldFraction(arg, options));
            if (!args.some(isNode)) {
              try {
                return _eval(node.name, args, options);
              } catch (ignoreandcontinue) {
              }
            }
            if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
              var sz = [];
              var section = args[0];
              while (isArrayNode(section)) {
                sz.push(section.items.length);
                section = section.items[0];
              }
              return matrix(sz);
            }
            return new FunctionNode(node.name, args.map(_ensureNode));
          } else {
          }
        }
      case "OperatorNode": {
        var fn = node.fn.toString();
        var _args;
        var res;
        var makeNode = createMakeNodeFunction(node);
        if (isOperatorNode(node) && node.isUnary()) {
          _args = [foldFraction(node.args[0], options)];
          if (!isNode(_args[0])) {
            res = _eval(fn, _args, options);
          } else {
            res = makeNode(_args);
          }
        } else if (isAssociative(node, options.context)) {
          _args = allChildren(node, options.context);
          _args = _args.map((arg) => foldFraction(arg, options));
          if (isCommutative(fn, options.context)) {
            var consts = [];
            var vars = [];
            for (var i = 0;i < _args.length; i++) {
              if (!isNode(_args[i])) {
                consts.push(_args[i]);
              } else {
                vars.push(_args[i]);
              }
            }
            if (consts.length > 1) {
              res = foldOp(fn, consts, makeNode, options);
              vars.unshift(res);
              res = foldOp(fn, vars, makeNode, options);
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            res = foldOp(fn, _args, makeNode, options);
          }
        } else {
          _args = node.args.map((arg) => foldFraction(arg, options));
          res = foldOp(fn, _args, makeNode, options);
        }
        return res;
      }
      case "ParenthesisNode":
        return foldFraction(node.content, options);
      case "AccessorNode":
        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
      case "ArrayNode": {
        var foldItems = node.items.map((item) => foldFraction(item, options));
        if (foldItems.some(isNode)) {
          return new ArrayNode(foldItems.map(_ensureNode));
        }
        return matrix(foldItems);
      }
      case "IndexNode": {
        return new IndexNode(node.dimensions.map((n) => simplifyConstant(n, options)));
      }
      case "ObjectNode": {
        var foldProps = {};
        for (var prop in node.properties) {
          foldProps[prop] = simplifyConstant(node.properties[prop], options);
        }
        return new ObjectNode(foldProps);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
    }
  }
  return simplifyConstant;
});
// node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
var name281 = "simplifyCore";
var dependencies282 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplifyCore = /* @__PURE__ */ factory(name281, dependencies282, (_ref) => {
  var {
    typed: typed2,
    parse: parse3,
    equal,
    isZero,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    pow: pow2,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  var node0 = new ConstantNode(0);
  var node1 = new ConstantNode(1);
  var nodeT = new ConstantNode(true);
  var nodeF = new ConstantNode(false);
  function isAlwaysBoolean(node) {
    return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
  }
  var {
    hasProperty,
    isCommutative
  } = createUtil({
    FunctionNode,
    OperatorNode,
    SymbolNode
  });
  function _simplifyCore(nodeToSimplify) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var context = options ? options.context : undefined;
    if (hasProperty(nodeToSimplify, "trivial", context)) {
      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
        return _simplifyCore(nodeToSimplify.args[0], options);
      }
      var simpChild = false;
      var childCount = 0;
      nodeToSimplify.forEach((c) => {
        ++childCount;
        if (childCount === 1) {
          simpChild = _simplifyCore(c, options);
        }
      });
      if (childCount === 1) {
        return simpChild;
      }
    }
    var node = nodeToSimplify;
    if (isFunctionNode(node)) {
      var op = getOperator(node.name);
      if (op) {
        if (node.args.length > 2 && hasProperty(node, "associative", context)) {
          while (node.args.length > 2) {
            var last = node.args.pop();
            var seclast = node.args.pop();
            node.args.push(new OperatorNode(op, node.name, [last, seclast]));
          }
        }
        node = new OperatorNode(op, node.name, node.args);
      } else {
        return new FunctionNode(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options)));
      }
    }
    if (isOperatorNode(node) && node.isUnary()) {
      var a0 = _simplifyCore(node.args[0], options);
      if (node.op === "~") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
          return a0.args[0];
        }
      }
      if (node.op === "not") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
          if (isAlwaysBoolean(a0.args[0])) {
            return a0.args[0];
          }
        }
      }
      var finish = true;
      if (node.op === "-") {
        if (isOperatorNode(a0)) {
          if (a0.isBinary() && a0.fn === "subtract") {
            node = new OperatorNode("-", "subtract", [a0.args[1], a0.args[0]]);
            finish = false;
          }
          if (a0.isUnary() && a0.op === "-") {
            return a0.args[0];
          }
        }
      }
      if (finish)
        return new OperatorNode(node.op, node.fn, [a0]);
    }
    if (isOperatorNode(node) && node.isBinary()) {
      var _a = _simplifyCore(node.args[0], options);
      var a1 = _simplifyCore(node.args[1], options);
      if (node.op === "+") {
        if (isConstantNode(_a) && isZero(_a.value)) {
          return a1;
        }
        if (isConstantNode(a1) && isZero(a1.value)) {
          return _a;
        }
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          a1 = a1.args[0];
          node = new OperatorNode("-", "subtract", [_a, a1]);
        }
      }
      if (node.op === "-") {
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          return _simplifyCore(new OperatorNode("+", "add", [_a, a1.args[0]]), options);
        }
        if (isConstantNode(_a) && isZero(_a.value)) {
          return _simplifyCore(new OperatorNode("-", "unaryMinus", [a1]));
        }
        if (isConstantNode(a1) && isZero(a1.value)) {
          return _a;
        }
        return new OperatorNode(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "*") {
        if (isConstantNode(_a)) {
          if (isZero(_a.value)) {
            return node0;
          } else if (equal(_a.value, 1)) {
            return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (isZero(a1.value)) {
            return node0;
          } else if (equal(a1.value, 1)) {
            return _a;
          }
          if (isCommutative(node, context)) {
            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit);
          }
        }
        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
      }
      if (node.op === "/") {
        if (isConstantNode(_a) && isZero(_a.value)) {
          return node0;
        }
        if (isConstantNode(a1) && equal(a1.value, 1)) {
          return _a;
        }
        return new OperatorNode(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "^") {
        if (isConstantNode(a1)) {
          if (isZero(a1.value)) {
            return node1;
          } else if (equal(a1.value, 1)) {
            return _a;
          }
        }
      }
      if (node.op === "and") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            if (isAlwaysBoolean(a1))
              return a1;
            if (isConstantNode(a1)) {
              return a1.value ? nodeT : nodeF;
            }
          } else {
            return nodeF;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            if (isAlwaysBoolean(_a))
              return _a;
          } else {
            return nodeF;
          }
        }
      }
      if (node.op === "or") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(a1))
              return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(_a))
              return _a;
          }
        }
      }
      return new OperatorNode(node.op, node.fn, [_a, a1]);
    }
    if (isOperatorNode(node)) {
      return new OperatorNode(node.op, node.fn, node.args.map((a) => _simplifyCore(a, options)));
    }
    if (isArrayNode(node)) {
      return new ArrayNode(node.items.map((n) => _simplifyCore(n, options)));
    }
    if (isAccessorNode(node)) {
      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
    }
    if (isIndexNode(node)) {
      return new IndexNode(node.dimensions.map((n) => _simplifyCore(n, options)));
    }
    if (isObjectNode(node)) {
      var newProps = {};
      for (var prop in node.properties) {
        newProps[prop] = _simplifyCore(node.properties[prop], options);
      }
      return new ObjectNode(newProps);
    }
    return node;
  }
  return typed2(name281, {
    Node: _simplifyCore,
    "Node,Object": _simplifyCore
  });
});
// node_modules/mathjs/lib/esm/function/algebra/resolve.js
var name282 = "resolve";
var dependencies283 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
var createResolve = /* @__PURE__ */ factory(name282, dependencies283, (_ref) => {
  var {
    typed: typed2,
    parse: parse3,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode
  } = _ref;
  function _resolve(node, scope) {
    var within = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set;
    if (!scope) {
      return node;
    }
    if (isSymbolNode(node)) {
      if (within.has(node.name)) {
        var variables = Array.from(within).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
      }
      var value = scope.get(node.name);
      if (isNode(value)) {
        var nextWithin = new Set(within);
        nextWithin.add(node.name);
        return _resolve(value, scope, nextWithin);
      } else if (typeof value === "number") {
        return parse3(String(value));
      } else if (value !== undefined) {
        return new ConstantNode(value);
      } else {
        return node;
      }
    } else if (isOperatorNode(node)) {
      var args = node.args.map(function(arg) {
        return _resolve(arg, scope, within);
      });
      return new OperatorNode(node.op, node.fn, args, node.implicit);
    } else if (isParenthesisNode(node)) {
      return new ParenthesisNode(_resolve(node.content, scope, within));
    } else if (isFunctionNode(node)) {
      var _args = node.args.map(function(arg) {
        return _resolve(arg, scope, within);
      });
      return new FunctionNode(node.name, _args);
    }
    return node.map((child) => _resolve(child, scope, within));
  }
  return typed2("resolve", {
    Node: _resolve,
    "Node, Map | null | undefined": _resolve,
    "Node, Object": (n, scope) => _resolve(n, createMap(scope)),
    "Array | Matrix": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array | Matrix, null | undefined": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array, Object": typed2.referTo("Array,Map", (selfAM) => (A, scope) => selfAM(A, createMap(scope))),
    "Matrix, Object": typed2.referTo("Matrix,Map", (selfMM) => (A, scope) => selfMM(A, createMap(scope))),
    "Array | Matrix, Map": typed2.referToSelf((self2) => (A, scope) => A.map((n) => self2(n, scope)))
  });
});
// node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
var name283 = "symbolicEqual";
var dependencies284 = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = /* @__PURE__ */ factory(name283, dependencies284, (_ref) => {
  var {
    parse: parse3,
    simplify,
    typed: typed2,
    OperatorNode
  } = _ref;
  function _symbolicEqual(e1, e2) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var diff = new OperatorNode("-", "subtract", [e1, e2]);
    var simplified = simplify(diff, {}, options);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed2(name283, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});
// node_modules/mathjs/lib/esm/function/algebra/derivative.js
var name284 = "derivative";
var dependencies285 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createDerivative = /* @__PURE__ */ factory(name284, dependencies285, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    parse: parse3,
    simplify,
    equal,
    isZero,
    numeric: numeric2,
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode
  } = _ref;
  function plainDerivative(expr, variable) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      simplify: true
    };
    var cache = new Map;
    var variableName = variable.name;
    function isConstCached(node) {
      var cached = cache.get(node);
      if (cached !== undefined) {
        return cached;
      }
      var res2 = _isConst(isConstCached, node, variableName);
      cache.set(node, res2);
      return res2;
    }
    var res = _derivative(expr, isConstCached);
    return options.simplify ? simplify(res) : res;
  }
  function parseIdentifier(string) {
    var symbol = parse3(string);
    if (!symbol.isSymbolNode) {
      throw new TypeError("Invalid variable. " + "Cannot parse ".concat(JSON.stringify(string), " into a variable in function derivative"));
    }
    return symbol;
  }
  var derivative = typed2(name284, {
    "Node, SymbolNode": plainDerivative,
    "Node, SymbolNode, Object": plainDerivative,
    "Node, string": (node, symbol) => plainDerivative(node, parseIdentifier(symbol)),
    "Node, string, Object": (node, symbol, options) => plainDerivative(node, parseIdentifier(symbol), options)
  });
  derivative._simplify = true;
  derivative.toTex = function(deriv) {
    return _derivTex.apply(null, deriv.args);
  };
  var _derivTex = typed2("_derivTex", {
    "Node, SymbolNode": function Node_SymbolNode(expr, x) {
      if (isConstantNode(expr) && typeOf(expr.value) === "string") {
        return _derivTex(parse3(expr.value).toString(), x.toString(), 1);
      } else {
        return _derivTex(expr.toTex(), x.toString(), 1);
      }
    },
    "Node, ConstantNode": function Node_ConstantNode(expr, x) {
      if (typeOf(x.value) === "string") {
        return _derivTex(expr, parse3(x.value));
      } else {
        throw new Error("The second parameter to 'derivative' is a non-string constant");
      }
    },
    "Node, SymbolNode, ConstantNode": function Node_SymbolNode_ConstantNode(expr, x, order) {
      return _derivTex(expr.toString(), x.name, order.value);
    },
    "string, string, number": function string_string_number(expr, x, order) {
      var d;
      if (order === 1) {
        d = "{d\\over d" + x + "}";
      } else {
        d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
      }
      return d + "\\left[".concat(expr, "\\right]");
    }
  });
  var _isConst = typed2("_isConst", {
    "function, ConstantNode, string": function function_ConstantNode_string() {
      return true;
    },
    "function, SymbolNode, string": function function_SymbolNode_string(isConst, node, varName) {
      return node.name !== varName;
    },
    "function, ParenthesisNode, string": function function_ParenthesisNode_string(isConst, node, varName) {
      return isConst(node.content, varName);
    },
    "function, FunctionAssignmentNode, string": function function_FunctionAssignmentNode_string(isConst, node, varName) {
      if (!node.params.includes(varName)) {
        return true;
      }
      return isConst(node.expr, varName);
    },
    "function, FunctionNode | OperatorNode, string": function function_FunctionNode__OperatorNode_string(isConst, node, varName) {
      return node.args.every((arg) => isConst(arg, varName));
    }
  });
  var _derivative = typed2("_derivative", {
    "ConstantNode, function": function ConstantNode_function() {
      return createConstantNode2(0);
    },
    "SymbolNode, function": function SymbolNode_function(node, isConst) {
      if (isConst(node)) {
        return createConstantNode2(0);
      }
      return createConstantNode2(1);
    },
    "ParenthesisNode, function": function ParenthesisNode_function(node, isConst) {
      return new ParenthesisNode(_derivative(node.content, isConst));
    },
    "FunctionAssignmentNode, function": function FunctionAssignmentNode_function(node, isConst) {
      if (isConst(node)) {
        return createConstantNode2(0);
      }
      return _derivative(node.expr, isConst);
    },
    "FunctionNode, function": function FunctionNode_function(node, isConst) {
      if (isConst(node)) {
        return createConstantNode2(0);
      }
      var arg0 = node.args[0];
      var arg1;
      var div2 = false;
      var negative = false;
      var funcDerivative;
      switch (node.name) {
        case "cbrt":
          div2 = true;
          funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(3), new OperatorNode("^", "pow", [arg0, new OperatorNode("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (node.args.length === 1) {
            div2 = true;
            funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(2), new FunctionNode("sqrt", [arg0])]);
          } else if (node.args.length === 2) {
            arg1 = new OperatorNode("/", "divide", [createConstantNode2(1), node.args[1]]);
            return _derivative(new OperatorNode("^", "pow", [arg0, arg1]), isConst);
          }
          break;
        case "log10":
          arg1 = createConstantNode2(10);
        case "log":
          if (!arg1 && node.args.length === 1) {
            funcDerivative = arg0.clone();
            div2 = true;
          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && isConst(node.args[1])) {
            funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("log", [arg1 || node.args[1]])]);
            div2 = true;
          } else if (node.args.length === 2) {
            return _derivative(new OperatorNode("/", "divide", [new FunctionNode("log", [arg0]), new FunctionNode("log", [node.args[1]])]), isConst);
          }
          break;
        case "pow":
          if (node.args.length === 2) {
            return _derivative(new OperatorNode("^", "pow", [arg0, node.args[1]]), isConst);
          }
          break;
        case "exp":
          funcDerivative = new FunctionNode("exp", [arg0.clone()]);
          break;
        case "sin":
          funcDerivative = new FunctionNode("cos", [arg0.clone()]);
          break;
        case "cos":
          funcDerivative = new OperatorNode("-", "unaryMinus", [new FunctionNode("sin", [arg0.clone()])]);
          break;
        case "tan":
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sec", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sec":
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tan", [arg0.clone()])]);
          break;
        case "csc":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("cot", [arg0.clone()])]);
          break;
        case "cot":
          negative = true;
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csc", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asin":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "acos":
          div2 = true;
          negative = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "atan":
          div2 = true;
          funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "asec":
          div2 = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acsc":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acot":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "sinh":
          funcDerivative = new FunctionNode("cosh", [arg0.clone()]);
          break;
        case "cosh":
          funcDerivative = new FunctionNode("sinh", [arg0.clone()]);
          break;
        case "tanh":
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sech", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sech":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tanh", [arg0.clone()])]);
          break;
        case "csch":
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("coth", [arg0.clone()])]);
          break;
        case "coth":
          negative = true;
          funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csch", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asinh":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "acosh":
          div2 = true;
          funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "atanh":
          div2 = true;
          funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "asech":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
          break;
        case "acsch":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acoth":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "abs":
          funcDerivative = new OperatorNode("/", "divide", [new FunctionNode(new SymbolNode("abs"), [arg0.clone()]), arg0.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Cannot process function "' + node.name + '" in derivative: ' + "the function is not supported, undefined, or the number of arguments passed to it are not supported");
      }
      var op, func;
      if (div2) {
        op = "/";
        func = "divide";
      } else {
        op = "*";
        func = "multiply";
      }
      var chainDerivative = _derivative(arg0, isConst);
      if (negative) {
        chainDerivative = new OperatorNode("-", "unaryMinus", [chainDerivative]);
      }
      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
    },
    "OperatorNode, function": function OperatorNode_function(node, isConst) {
      if (isConst(node)) {
        return createConstantNode2(0);
      }
      if (node.op === "+") {
        return new OperatorNode(node.op, node.fn, node.args.map(function(arg) {
          return _derivative(arg, isConst);
        }));
      }
      if (node.op === "-") {
        if (node.isUnary()) {
          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], isConst)]);
        }
        if (node.isBinary()) {
          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], isConst), _derivative(node.args[1], isConst)]);
        }
      }
      if (node.op === "*") {
        var constantTerms = node.args.filter(function(arg) {
          return isConst(arg);
        });
        if (constantTerms.length > 0) {
          var nonConstantTerms = node.args.filter(function(arg) {
            return !isConst(arg);
          });
          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode("*", "multiply", nonConstantTerms);
          var newArgs = constantTerms.concat(_derivative(nonConstantNode, isConst));
          return new OperatorNode("*", "multiply", newArgs);
        }
        return new OperatorNode("+", "add", node.args.map(function(argOuter) {
          return new OperatorNode("*", "multiply", node.args.map(function(argInner) {
            return argInner === argOuter ? _derivative(argInner, isConst) : argInner.clone();
          }));
        }));
      }
      if (node.op === "/" && node.isBinary()) {
        var arg0 = node.args[0];
        var arg1 = node.args[1];
        if (isConst(arg1)) {
          return new OperatorNode("/", "divide", [_derivative(arg0, isConst), arg1]);
        }
        if (isConst(arg0)) {
          return new OperatorNode("*", "multiply", [new OperatorNode("-", "unaryMinus", [arg0]), new OperatorNode("/", "divide", [_derivative(arg1, isConst), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
        }
        return new OperatorNode("/", "divide", [new OperatorNode("-", "subtract", [new OperatorNode("*", "multiply", [_derivative(arg0, isConst), arg1.clone()]), new OperatorNode("*", "multiply", [arg0.clone(), _derivative(arg1, isConst)])]), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
      }
      if (node.op === "^" && node.isBinary()) {
        var _arg = node.args[0];
        var _arg2 = node.args[1];
        if (isConst(_arg)) {
          if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
            return createConstantNode2(0);
          }
          return new OperatorNode("*", "multiply", [node, new OperatorNode("*", "multiply", [new FunctionNode("log", [_arg.clone()]), _derivative(_arg2.clone(), isConst)])]);
        }
        if (isConst(_arg2)) {
          if (isConstantNode(_arg2)) {
            if (isZero(_arg2.value)) {
              return createConstantNode2(0);
            }
            if (equal(_arg2.value, 1)) {
              return _derivative(_arg, isConst);
            }
          }
          var powMinusOne = new OperatorNode("^", "pow", [_arg.clone(), new OperatorNode("-", "subtract", [_arg2, createConstantNode2(1)])]);
          return new OperatorNode("*", "multiply", [_arg2.clone(), new OperatorNode("*", "multiply", [_derivative(_arg, isConst), powMinusOne])]);
        }
        return new OperatorNode("*", "multiply", [new OperatorNode("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode("+", "add", [new OperatorNode("*", "multiply", [_derivative(_arg, isConst), new OperatorNode("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode("*", "multiply", [_derivative(_arg2, isConst), new FunctionNode("log", [_arg.clone()])])])]);
      }
      throw new Error('Cannot process operator "' + node.op + '" in derivative: ' + "the operator is not supported, undefined, or the number of arguments passed to it are not supported");
    }
  });
  function createConstantNode2(value, valueType) {
    return new ConstantNode(numeric2(value, valueType || safeNumberType(String(value), config4)));
  }
  return derivative;
});
// node_modules/mathjs/lib/esm/function/algebra/rationalize.js
var name285 = "rationalize";
var dependencies286 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
var createRationalize = /* @__PURE__ */ factory(name285, dependencies286, (_ref) => {
  var {
    config: config4,
    typed: typed2,
    equal,
    isZero,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    pow: pow2,
    parse: parse3,
    simplifyConstant,
    simplifyCore,
    simplify,
    fraction,
    bignumber,
    mathWithTransform,
    matrix,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode,
    ParenthesisNode
  } = _ref;
  function _rationalize(expr) {
    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var detailed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var setRules = rulesRationalize();
    var polyRet = polynomial(expr, scope, true, setRules.firstRules);
    var nVars = polyRet.variables.length;
    var noExactFractions = {
      exactFractions: false
    };
    var withExactFractions = {
      exactFractions: true
    };
    expr = polyRet.expression;
    if (nVars >= 1) {
      expr = expandPower(expr);
      var sBefore;
      var rules;
      var eDistrDiv = true;
      var redoInic = false;
      expr = simplify(expr, setRules.firstRules, {}, noExactFractions);
      var s;
      while (true) {
        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
        expr = simplify(expr, rules, {}, withExactFractions);
        eDistrDiv = !eDistrDiv;
        s = expr.toString();
        if (s === sBefore) {
          break;
        }
        redoInic = true;
        sBefore = s;
      }
      if (redoInic) {
        expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);
      }
      expr = simplify(expr, setRules.finalRules, {}, noExactFractions);
    }
    var coefficients = [];
    var retRationalize = {};
    if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
      if (nVars === 1) {
        expr.args[0] = polyToCanonical(expr.args[0], coefficients);
        expr.args[1] = polyToCanonical(expr.args[1]);
      }
      if (detailed) {
        retRationalize.numerator = expr.args[0];
        retRationalize.denominator = expr.args[1];
      }
    } else {
      if (nVars === 1) {
        expr = polyToCanonical(expr, coefficients);
      }
      if (detailed) {
        retRationalize.numerator = expr;
        retRationalize.denominator = null;
      }
    }
    if (!detailed)
      return expr;
    retRationalize.coefficients = coefficients;
    retRationalize.variables = polyRet.variables;
    retRationalize.expression = expr;
    return retRationalize;
  }
  return typed2(name285, {
    Node: _rationalize,
    "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
    "Node, Object": _rationalize,
    "Node, Object, boolean": _rationalize
  });
  function polynomial(expr, scope, extended, rules) {
    var variables = [];
    var node = simplify(expr, rules, scope, {
      exactFractions: false
    });
    extended = !!extended;
    var oper = "+-*" + (extended ? "/" : "");
    recPoly(node);
    var retFunc = {};
    retFunc.expression = node;
    retFunc.variables = variables;
    return retFunc;
    function recPoly(node2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (node2.op === "^") {
          if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
            throw new Error("There is a non-integer exponent");
          } else {
            recPoly(node2.args[0]);
          }
        } else {
          if (!oper.includes(node2.op)) {
            throw new Error("Operator " + node2.op + " invalid in polynomial expression");
          }
          for (var i = 0;i < node2.args.length; i++) {
            recPoly(node2.args[i]);
          }
        }
      } else if (tp === "SymbolNode") {
        var _name = node2.name;
        var pos = variables.indexOf(_name);
        if (pos === -1) {
          variables.push(_name);
        }
      } else if (tp === "ParenthesisNode") {
        recPoly(node2.content);
      } else if (tp !== "ConstantNode") {
        throw new Error("type " + tp + " is not allowed in polynomial expression");
      }
    }
  }
  function rulesRationalize() {
    var oldRules = [
      simplifyCore,
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      simplifyConstant,
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ];
    var rulesFirst = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      {
        l: "-v*-c",
        r: "c*v"
      },
      {
        l: "-v*c",
        r: "-c*v"
      },
      {
        l: "v*-c",
        r: "-c*v"
      },
      {
        l: "v*c",
        r: "c*v"
      },
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ];
    var rulesDistrDiv = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ];
    var rulesSucDiv = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ];
    var setRules = {};
    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
    setRules.distrDivRules = rulesDistrDiv;
    setRules.sucDivRules = rulesSucDiv;
    setRules.firstRulesAgain = oldRules.concat(rulesFirst);
    setRules.finalRules = [
      simplifyCore,
      {
        l: "n*-n",
        r: "-n^2"
      },
      {
        l: "n*n",
        r: "n^2"
      },
      simplifyConstant,
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      {
        l: "v*c",
        r: "c*v"
      },
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
    ];
    return setRules;
  }
  function expandPower(node, parent, indParent) {
    var tp = node.type;
    var internal = arguments.length > 1;
    if (tp === "OperatorNode" && node.isBinary()) {
      var does = false;
      var val;
      if (node.op === "^") {
        if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
          val = parseFloat(node.args[1].value);
          does = val >= 2 && isInteger(val);
        }
      }
      if (does) {
        if (val > 2) {
          var nEsqTopo = node.args[0];
          var nDirTopo = new OperatorNode("^", "pow", [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
          node = new OperatorNode("*", "multiply", [nEsqTopo, nDirTopo]);
        } else {
          node = new OperatorNode("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
        }
        if (internal) {
          if (indParent === "content") {
            parent.content = node;
          } else {
            parent.args[indParent] = node;
          }
        }
      }
    }
    if (tp === "ParenthesisNode") {
      expandPower(node.content, node, "content");
    } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
      for (var i = 0;i < node.args.length; i++) {
        expandPower(node.args[i], node, i);
      }
    }
    if (!internal) {
      return node;
    }
  }
  function polyToCanonical(node, coefficients) {
    if (coefficients === undefined) {
      coefficients = [];
    }
    coefficients[0] = 0;
    var o = {};
    o.cte = 1;
    o.oper = "+";
    o.fire = "";
    var maxExpo = 0;
    var varname = "";
    recurPol(node, null, o);
    maxExpo = coefficients.length - 1;
    var first = true;
    var no;
    for (var i = maxExpo;i >= 0; i--) {
      if (coefficients[i] === 0)
        continue;
      var n16 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
      var op = coefficients[i] < 0 ? "-" : "+";
      if (i > 0) {
        var n25 = new SymbolNode(varname);
        if (i > 1) {
          var n32 = new ConstantNode(i);
          n25 = new OperatorNode("^", "pow", [n25, n32]);
        }
        if (coefficients[i] === -1 && first) {
          n16 = new OperatorNode("-", "unaryMinus", [n25]);
        } else if (Math.abs(coefficients[i]) === 1) {
          n16 = n25;
        } else {
          n16 = new OperatorNode("*", "multiply", [n16, n25]);
        }
      }
      if (first) {
        no = n16;
      } else if (op === "+") {
        no = new OperatorNode("+", "add", [no, n16]);
      } else {
        no = new OperatorNode("-", "subtract", [no, n16]);
      }
      first = false;
    }
    if (first) {
      return new ConstantNode(0);
    } else {
      return no;
    }
    function recurPol(node2, noPai, o2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (!"+-*^".includes(node2.op))
          throw new Error("Operator " + node2.op + " invalid");
        if (noPai !== null) {
          if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
            throw new Error("Invalid " + node2.op + " placing");
          }
        }
        if (node2.op === "^" || node2.op === "*") {
          o2.fire = node2.op;
        }
        for (var _i = 0;_i < node2.args.length; _i++) {
          if (node2.fn === "unaryMinus")
            o2.oper = "-";
          if (node2.op === "+" || node2.fn === "subtract") {
            o2.fire = "";
            o2.cte = 1;
            o2.oper = _i === 0 ? "+" : node2.op;
          }
          o2.noFil = _i;
          recurPol(node2.args[_i], node2, o2);
        }
      } else if (tp === "SymbolNode") {
        if (node2.name !== varname && varname !== "") {
          throw new Error("There is more than one variable");
        }
        varname = node2.name;
        if (noPai === null) {
          coefficients[1] = 1;
          return;
        }
        if (noPai.op === "^" && o2.noFil !== 0) {
          throw new Error("In power the variable should be the first parameter");
        }
        if (noPai.op === "*" && o2.noFil !== 1) {
          throw new Error("In multiply the variable should be the second parameter");
        }
        if (o2.fire === "" || o2.fire === "*") {
          if (maxExpo < 1)
            coefficients[1] = 0;
          coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(1, maxExpo);
        }
      } else if (tp === "ConstantNode") {
        var valor = parseFloat(node2.value);
        if (noPai === null) {
          coefficients[0] = valor;
          return;
        }
        if (noPai.op === "^") {
          if (o2.noFil !== 1)
            throw new Error("Constant cannot be powered");
          if (!isInteger(valor) || valor <= 0) {
            throw new Error("Non-integer exponent is not allowed");
          }
          for (var _i2 = maxExpo + 1;_i2 < valor; _i2++)
            coefficients[_i2] = 0;
          if (valor > maxExpo)
            coefficients[valor] = 0;
          coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(valor, maxExpo);
          return;
        }
        o2.cte = valor;
        if (o2.fire === "") {
          coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
        }
      } else {
        throw new Error("Type " + tp + " is not allowed");
      }
    }
  }
});
// node_modules/mathjs/lib/esm/function/signal/zpk2tf.js
var name286 = "zpk2tf";
var dependencies287 = ["typed", "add", "multiply", "Complex", "number"];
var createZpk2tf = /* @__PURE__ */ factory(name286, dependencies287, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    multiply,
    Complex: Complex2,
    number
  } = _ref;
  return typed2(name286, {
    "Array,Array,number": function ArrayArrayNumber(z, p, k) {
      return _zpk2tf(z, p, k);
    },
    "Array,Array": function ArrayArray(z, p) {
      return _zpk2tf(z, p, 1);
    },
    "Matrix,Matrix,number": function MatrixMatrixNumber(z, p, k) {
      return _zpk2tf(z.valueOf(), p.valueOf(), k);
    },
    "Matrix,Matrix": function MatrixMatrix(z, p) {
      return _zpk2tf(z.valueOf(), p.valueOf(), 1);
    }
  });
  function _zpk2tf(z, p, k) {
    if (z.some((el) => el.type === "BigNumber")) {
      z = z.map((el) => number(el));
    }
    if (p.some((el) => el.type === "BigNumber")) {
      p = p.map((el) => number(el));
    }
    var num = [Complex2(1, 0)];
    var den = [Complex2(1, 0)];
    for (var i = 0;i < z.length; i++) {
      var zero = z[i];
      if (typeof zero === "number")
        zero = Complex2(zero, 0);
      num = _multiply(num, [Complex2(1, 0), Complex2(-zero.re, -zero.im)]);
    }
    for (var _i = 0;_i < p.length; _i++) {
      var pole = p[_i];
      if (typeof pole === "number")
        pole = Complex2(pole, 0);
      den = _multiply(den, [Complex2(1, 0), Complex2(-pole.re, -pole.im)]);
    }
    for (var _i2 = 0;_i2 < num.length; _i2++) {
      num[_i2] = multiply(num[_i2], k);
    }
    return [num, den];
  }
  function _multiply(a, b) {
    var c = [];
    for (var i = 0;i < a.length + b.length - 1; i++) {
      c[i] = Complex2(0, 0);
      for (var j = 0;j < a.length; j++) {
        if (i - j >= 0 && i - j < b.length) {
          c[i] = add2(c[i], multiply(a[j], b[i - j]));
        }
      }
    }
    return c;
  }
});
// node_modules/mathjs/lib/esm/function/signal/freqz.js
var name287 = "freqz";
var dependencies288 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
var createFreqz = /* @__PURE__ */ factory(name287, dependencies288, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    multiply,
    Complex: Complex2,
    divide: divide2,
    matrix
  } = _ref;
  return typed2(name287, {
    "Array, Array": function Array_Array(b, a) {
      var w = createBins(512);
      return _freqz(b, a, w);
    },
    "Array, Array, Array": function Array_Array_Array(b, a, w) {
      return _freqz(b, a, w);
    },
    "Array, Array, number": function Array_Array_number(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var w2 = createBins(w);
      return _freqz(b, a, w2);
    },
    "Matrix, Matrix": function Matrix_Matrix(b, a) {
      var _w = createBins(512);
      var {
        w,
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        w: matrix(w),
        h: matrix(h)
      };
    },
    "Matrix, Matrix, Matrix": function Matrix_Matrix_Matrix(b, a, w) {
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), w.valueOf());
      return {
        h: matrix(h),
        w: matrix(w)
      };
    },
    "Matrix, Matrix, number": function Matrix_Matrix_number(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var _w = createBins(w);
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        h: matrix(h),
        w: matrix(_w)
      };
    }
  });
  function _freqz(b, a, w) {
    var num = [];
    var den = [];
    for (var i = 0;i < w.length; i++) {
      var sumNum = Complex2(0, 0);
      var sumDen = Complex2(0, 0);
      for (var j = 0;j < b.length; j++) {
        sumNum = add2(sumNum, multiply(b[j], Complex2(Math.cos(-j * w[i]), Math.sin(-j * w[i]))));
      }
      for (var _j = 0;_j < a.length; _j++) {
        sumDen = add2(sumDen, multiply(a[_j], Complex2(Math.cos(-_j * w[i]), Math.sin(-_j * w[i]))));
      }
      num.push(sumNum);
      den.push(sumDen);
    }
    var h = [];
    for (var _i = 0;_i < num.length; _i++) {
      h.push(divide2(num[_i], den[_i]));
    }
    return {
      h,
      w
    };
  }
  function createBins(n) {
    var bins = [];
    for (var i = 0;i < n; i++) {
      bins.push(i / n * Math.PI);
    }
    return bins;
  }
});
// node_modules/mathjs/lib/esm/json/reviver.js
var name288 = "reviver";
var dependencies289 = ["classes"];
var createReviver = /* @__PURE__ */ factory(name288, dependencies289, (_ref) => {
  var {
    classes
  } = _ref;
  return function reviver(key, value) {
    var constructor = classes[value && value.mathjs];
    if (constructor && typeof constructor.fromJSON === "function") {
      return constructor.fromJSON(value);
    }
    return value;
  };
});
// node_modules/mathjs/lib/esm/json/replacer.js
var name289 = "replacer";
var dependencies290 = [];
var createReplacer = /* @__PURE__ */ factory(name289, dependencies290, () => {
  return function replacer(key, value) {
    if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
      return {
        mathjs: "number",
        value: String(value)
      };
    }
    if (typeof value === "bigint") {
      return {
        mathjs: "bigint",
        value: String(value)
      };
    }
    return value;
  };
});
// node_modules/mathjs/lib/esm/version.js
var version = "14.2.1";

// node_modules/mathjs/lib/esm/constants.js
var createTrue = /* @__PURE__ */ factory("true", [], () => true);
var createFalse = /* @__PURE__ */ factory("false", [], () => false);
var createNull = /* @__PURE__ */ factory("null", [], () => null);
var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
  var {
    config: config4,
    BigNumber
  } = _ref;
  return config4.number === "BigNumber" ? new BigNumber(Infinity) : Infinity;
});
var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
  var {
    config: config4,
    BigNumber
  } = _ref2;
  return config4.number === "BigNumber" ? new BigNumber(NaN) : NaN;
});
var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
  var {
    config: config4,
    BigNumber
  } = _ref3;
  return config4.number === "BigNumber" ? createBigNumberPi(BigNumber) : pi;
});
var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
  var {
    config: config4,
    BigNumber
  } = _ref4;
  return config4.number === "BigNumber" ? createBigNumberTau(BigNumber) : tau;
});
var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
  var {
    config: config4,
    BigNumber
  } = _ref5;
  return config4.number === "BigNumber" ? createBigNumberE(BigNumber) : e;
});
var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
  var {
    config: config4,
    BigNumber
  } = _ref6;
  return config4.number === "BigNumber" ? createBigNumberPhi(BigNumber) : phi;
});
var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
  var {
    config: config4,
    BigNumber
  } = _ref7;
  return config4.number === "BigNumber" ? new BigNumber(2).ln() : Math.LN2;
});
var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
  var {
    config: config4,
    BigNumber
  } = _ref8;
  return config4.number === "BigNumber" ? new BigNumber(10).ln() : Math.LN10;
});
var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
  var {
    config: config4,
    BigNumber
  } = _ref9;
  return config4.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E;
});
var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
  var {
    config: config4,
    BigNumber
  } = _ref10;
  return config4.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E;
});
var createSQRT1_2 = /* @__PURE__ */ recreateFactory("SQRT1_2", ["config", "?BigNumber"], (_ref11) => {
  var {
    config: config4,
    BigNumber
  } = _ref11;
  return config4.number === "BigNumber" ? new BigNumber("0.5").sqrt() : Math.SQRT1_2;
});
var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
  var {
    config: config4,
    BigNumber
  } = _ref12;
  return config4.number === "BigNumber" ? new BigNumber(2).sqrt() : Math.SQRT2;
});
var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
  var {
    Complex: Complex2
  } = _ref13;
  return Complex2.I;
});
var createVersion = /* @__PURE__ */ factory("version", [], () => version);
function recreateFactory(name290, dependencies291, create) {
  return factory(name290, dependencies291, create, {
    recreateOnConfigChange: true
  });
}
// node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
function unitFactory(name290, valueStr, unitStr) {
  var dependencies291 = ["config", "Unit", "BigNumber"];
  return factory(name290, dependencies291, (_ref) => {
    var {
      config: config4,
      Unit,
      BigNumber
    } = _ref;
    var value = config4.number === "BigNumber" ? new BigNumber(valueStr) : parseFloat(valueStr);
    var unit = new Unit(value, unitStr);
    unit.fixPrefix = true;
    return unit;
  });
}
function numberFactory(name290, value) {
  var dependencies291 = ["config", "BigNumber"];
  return factory(name290, dependencies291, (_ref2) => {
    var {
      config: config4,
      BigNumber
    } = _ref2;
    return config4.number === "BigNumber" ? new BigNumber(value) : value;
  });
}
// node_modules/mathjs/lib/esm/expression/transform/mapSlices.transform.js
function ownKeys4(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e2) {
  for (var r = 1;r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name290 = "mapSlices";
var dependencies291 = ["typed", "isInteger"];
var createMapSlicesTransform = /* @__PURE__ */ factory(name290, dependencies291, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  var mapSlices = createMapSlices({
    typed: typed2,
    isInteger: isInteger2
  });
  return typed2("mapSlices", {
    "...any": function any(args) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
      try {
        return mapSlices.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, _objectSpread4({
  isTransformFunction: true
}, createMapSlices.meta));
// node_modules/mathjs/lib/esm/expression/transform/column.transform.js
var name291 = "column";
var dependencies292 = ["typed", "Index", "matrix", "range"];
var createColumnTransform = /* @__PURE__ */ factory(name291, dependencies292, (_ref) => {
  var {
    typed: typed2,
    Index,
    matrix,
    range
  } = _ref;
  var column = createColumn({
    typed: typed2,
    Index,
    matrix,
    range
  });
  return typed2("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return column.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
function compileInlineExpression(expression, math, scope) {
  var symbol = expression.filter(function(node) {
    return isSymbolNode(node) && !(node.name in math) && !scope.has(node.name);
  })[0];
  if (!symbol) {
    throw new Error('No undefined variable found in inline expression "' + expression + '"');
  }
  var name292 = symbol.name;
  var argsScope = new Map;
  var subScope = new PartitionedMap(scope, argsScope, new Set([name292]));
  var eq = expression.compile();
  return function inlineExpression(x) {
    argsScope.set(name292, x);
    return eq.evaluate(subScope);
  };
}

// node_modules/mathjs/lib/esm/expression/transform/utils/transformCallback.js
var name292 = "transformCallback";
var dependencies293 = ["typed"];
var createTransformCallback = /* @__PURE__ */ factory(name292, dependencies293, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function(callback, numberOfArrays) {
    if (typed2.isTypedFunction(callback)) {
      return _transformTypedCallbackFunction(callback, numberOfArrays);
    } else {
      return _transformCallbackFunction(callback, callback.length, numberOfArrays);
    }
  };
  function _transformTypedCallbackFunction(typedFunction2, numberOfArrays) {
    var signatures = Object.fromEntries(Object.entries(typedFunction2.signatures).map((_ref2) => {
      var [signature, callbackFunction] = _ref2;
      var numberOfCallbackInputs = signature.split(",").length;
      if (typed2.isTypedFunction(callbackFunction)) {
        return [signature, _transformTypedCallbackFunction(callbackFunction, numberOfArrays)];
      } else {
        return [signature, _transformCallbackFunction(callbackFunction, numberOfCallbackInputs, numberOfArrays)];
      }
    }));
    if (typeof typedFunction2.name === "string") {
      return typed2(typedFunction2.name, signatures);
    } else {
      return typed2(signatures);
    }
  }
});
function _transformCallbackFunction(callbackFunction, numberOfCallbackInputs, numberOfArrays) {
  if (numberOfCallbackInputs === numberOfArrays) {
    return callbackFunction;
  } else if (numberOfCallbackInputs === numberOfArrays + 1) {
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var vals = args.slice(0, numberOfArrays);
      var idx = _transformDims(args[numberOfArrays]);
      return callbackFunction(...vals, idx);
    };
  } else if (numberOfCallbackInputs > numberOfArrays + 1) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;_key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var vals = args.slice(0, numberOfArrays);
      var idx = _transformDims(args[numberOfArrays]);
      var rest = args.slice(numberOfArrays + 1);
      return callbackFunction(...vals, idx, ...rest);
    };
  } else {
    return callbackFunction;
  }
}
function _transformDims(dims) {
  return dims.map((dim) => dim + 1);
}

// node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
var name293 = "filter";
var dependencies294 = ["typed"];
var createFilterTransform = /* @__PURE__ */ factory(name293, dependencies294, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function filterTransform(args, math, scope) {
    var filter2 = createFilter({
      typed: typed2
    });
    var transformCallback = createTransformCallback({
      typed: typed2
    });
    if (args.length === 0) {
      return filter2();
    }
    var x = args[0];
    if (args.length === 1) {
      return filter2(x);
    }
    var N = args.length - 1;
    var callback = args[N];
    if (x) {
      x = _compileAndEvaluate(x, scope);
    }
    if (callback) {
      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {
        callback = _compileAndEvaluate(callback, scope);
      } else {
        callback = compileInlineExpression(callback, math, scope);
      }
    }
    return filter2(x, transformCallback(callback, N));
  }
  filterTransform.rawArgs = true;
  function _compileAndEvaluate(arg, scope) {
    return arg.compile().evaluate(scope);
  }
  return filterTransform;
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
var name294 = "forEach";
var dependencies295 = ["typed"];
var createForEachTransform = /* @__PURE__ */ factory(name294, dependencies295, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var forEach2 = createForEach({
    typed: typed2
  });
  var transformCallback = createTransformCallback({
    typed: typed2
  });
  function forEachTransform(args, math, scope) {
    if (args.length === 0) {
      return forEach2();
    }
    var x = args[0];
    if (args.length === 1) {
      return forEach2(x);
    }
    var N = args.length - 1;
    var callback = args[N];
    if (x) {
      x = _compileAndEvaluate(x, scope);
    }
    if (callback) {
      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {
        callback = _compileAndEvaluate(callback, scope);
      } else {
        callback = compileInlineExpression(callback, math, scope);
      }
    }
    return forEach2(x, transformCallback(callback, N));
  }
  forEachTransform.rawArgs = true;
  function _compileAndEvaluate(arg, scope) {
    return arg.compile().evaluate(scope);
  }
  return forEachTransform;
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/index.transform.js
var name295 = "index";
var dependencies296 = ["Index", "getMatrixDataType"];
var createIndexTransform = /* @__PURE__ */ factory(name295, dependencies296, (_ref) => {
  var {
    Index,
    getMatrixDataType
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i = 0, ii = arguments.length;i < ii; i++) {
      var arg = arguments[i];
      if (isRange(arg)) {
        arg.start--;
        arg.end -= arg.step > 0 ? 0 : 2;
      } else if (arg && arg.isSet === true) {
        arg = arg.map(function(v) {
          return v - 1;
        });
      } else if (isArray(arg) || isMatrix(arg)) {
        if (getMatrixDataType(arg) !== "boolean") {
          arg = arg.map(function(v) {
            return v - 1;
          });
        }
      } else if (isNumber(arg) || isBigInt(arg)) {
        arg--;
      } else if (isBigNumber(arg)) {
        arg = arg.toNumber() - 1;
      } else if (typeof arg === "string") {
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, bigint, string, or Range");
      }
      args[i] = arg;
    }
    var res = new Index;
    Index.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/map.transform.js
var name296 = "map";
var dependencies297 = ["typed"];
var createMapTransform = /* @__PURE__ */ factory(name296, dependencies297, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var map2 = createMap2({
    typed: typed2
  });
  var transformCallback = createTransformCallback({
    typed: typed2
  });
  function mapTransform(args, math, scope) {
    if (args.length === 0) {
      return map2();
    }
    if (args.length === 1) {
      return map2(args[0]);
    }
    var N = args.length - 1;
    var X = args.slice(0, N);
    var callback = args[N];
    X = X.map((arg) => _compileAndEvaluate(arg, scope));
    if (callback) {
      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {
        callback = _compileAndEvaluate(callback, scope);
      } else {
        callback = compileInlineExpression(callback, math, scope);
      }
    }
    return map2(...X, transformCallback(callback, N));
    function _compileAndEvaluate(arg, scope2) {
      return arg.compile().evaluate(scope2);
    }
  }
  mapTransform.rawArgs = true;
  return mapTransform;
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/utils/dimToZeroBase.js
function dimToZeroBase(dim) {
  if (isNumber(dim)) {
    return dim - 1;
  } else if (isBigNumber(dim)) {
    return dim.minus(1);
  } else {
    return dim;
  }
}
function isNumberOrBigNumber(n) {
  return isNumber(n) || isBigNumber(n);
}

// node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection(args[0])) {
    args = args.slice();
    var dim = args[1];
    if (isNumberOrBigNumber(dim)) {
      args[1] = dimToZeroBase(dim);
    }
  }
  return args;
}

// node_modules/mathjs/lib/esm/expression/transform/max.transform.js
var name297 = "max";
var dependencies298 = ["typed", "config", "numeric", "larger"];
var createMaxTransform = /* @__PURE__ */ factory(name297, dependencies298, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    numeric: numeric2,
    larger
  } = _ref;
  var max2 = createMax({
    typed: typed2,
    config: config4,
    numeric: numeric2,
    larger
  });
  return typed2("max", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return max2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
var name298 = "mean";
var dependencies299 = ["typed", "add", "divide"];
var createMeanTransform = /* @__PURE__ */ factory(name298, dependencies299, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2
  } = _ref;
  var mean = createMean({
    typed: typed2,
    add: add2,
    divide: divide2
  });
  return typed2("mean", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return mean.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/min.transform.js
var name299 = "min";
var dependencies300 = ["typed", "config", "numeric", "smaller"];
var createMinTransform = /* @__PURE__ */ factory(name299, dependencies300, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    numeric: numeric2,
    smaller
  } = _ref;
  var min2 = createMin({
    typed: typed2,
    config: config4,
    numeric: numeric2,
    smaller
  });
  return typed2("min", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return min2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/range.transform.js
var name300 = "range";
var dependencies301 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRangeTransform = /* @__PURE__ */ factory(name300, dependencies301, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add: add2,
    isPositive
  } = _ref;
  var range = createRange({
    typed: typed2,
    config: config4,
    matrix,
    bignumber,
    smaller,
    smallerEq,
    larger,
    largerEq,
    add: add2,
    isPositive
  });
  return typed2("range", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== "boolean") {
        args.push(true);
      }
      return range.apply(null, args);
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/row.transform.js
var name301 = "row";
var dependencies302 = ["typed", "Index", "matrix", "range"];
var createRowTransform = /* @__PURE__ */ factory(name301, dependencies302, (_ref) => {
  var {
    typed: typed2,
    Index,
    matrix,
    range
  } = _ref;
  var row = createRow({
    typed: typed2,
    Index,
    matrix,
    range
  });
  return typed2("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return row.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
var name302 = "subset";
var dependencies303 = ["typed", "matrix", "zeros", "add"];
var createSubsetTransform = /* @__PURE__ */ factory(name302, dependencies303, (_ref) => {
  var {
    typed: typed2,
    matrix,
    zeros: zeros2,
    add: add2
  } = _ref;
  var subset = createSubset({
    typed: typed2,
    matrix,
    zeros: zeros2,
    add: add2
  });
  return typed2("subset", {
    "...any": function any(args) {
      try {
        return subset.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
var name303 = "concat";
var dependencies304 = ["typed", "matrix", "isInteger"];
var createConcatTransform = /* @__PURE__ */ factory(name303, dependencies304, (_ref) => {
  var {
    typed: typed2,
    matrix,
    isInteger: isInteger2
  } = _ref;
  var concat2 = createConcat({
    typed: typed2,
    matrix,
    isInteger: isInteger2
  });
  return typed2("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      } else if (isBigNumber(last)) {
        args[lastIndex] = last.minus(1);
      }
      try {
        return concat2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
var name304 = "diff";
var dependencies305 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = /* @__PURE__ */ factory(name304, dependencies305, (_ref) => {
  var {
    typed: typed2,
    matrix,
    subtract,
    number,
    bignumber
  } = _ref;
  var diff = createDiff({
    typed: typed2,
    matrix,
    subtract,
    number,
    bignumber
  });
  return typed2(name304, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/std.transform.js
var name305 = "std";
var dependencies306 = ["typed", "map", "sqrt", "variance"];
var createStdTransform = /* @__PURE__ */ factory(name305, dependencies306, (_ref) => {
  var {
    typed: typed2,
    map: map2,
    sqrt: sqrt2,
    variance
  } = _ref;
  var std = createStd({
    typed: typed2,
    map: map2,
    sqrt: sqrt2,
    variance
  });
  return typed2("std", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return std.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
var name306 = "sum";
var dependencies307 = ["typed", "config", "add", "numeric"];
var createSumTransform = /* @__PURE__ */ factory(name306, dependencies307, (_ref) => {
  var {
    typed: typed2,
    config: config4,
    add: add2,
    numeric: numeric2
  } = _ref;
  var sum2 = createSum({
    typed: typed2,
    config: config4,
    add: add2,
    numeric: numeric2
  });
  return typed2(name306, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return sum2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/quantileSeq.transform.js
var name307 = "quantileSeq";
var dependencies308 = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger", "mapSlices"];
var createQuantileSeqTransform = /* @__PURE__ */ factory(name307, dependencies308, (_ref) => {
  var {
    typed: typed2,
    bignumber,
    add: add2,
    subtract,
    divide: divide2,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger,
    mapSlices
  } = _ref;
  var quantileSeq = createQuantileSeq({
    typed: typed2,
    bignumber,
    add: add2,
    subtract,
    divide: divide2,
    multiply,
    partitionSelect,
    compare,
    isInteger: isInteger2,
    smaller,
    smallerEq,
    larger,
    mapSlices
  });
  return typed2("quantileSeq", {
    "Array | Matrix, number | BigNumber": quantileSeq,
    "Array | Matrix, number | BigNumber, number": (arr, prob, dim) => quantileSeq(arr, prob, dimToZeroBase2(dim)),
    "Array | Matrix, number | BigNumber, boolean": quantileSeq,
    "Array | Matrix, number | BigNumber, boolean, number": (arr, prob, sorted, dim) => quantileSeq(arr, prob, sorted, dimToZeroBase2(dim)),
    "Array | Matrix, Array | Matrix": quantileSeq,
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => quantileSeq(data, prob, dimToZeroBase2(dim)),
    "Array | Matrix, Array | Matrix, boolean": quantileSeq,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => quantileSeq(data, prob, sorted, dimToZeroBase2(dim))
  });
  function dimToZeroBase2(dim) {
    return lastDimToZeroBase([[], dim])[1];
  }
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
var name308 = "cumsum";
var dependencies309 = ["typed", "add", "unaryPlus"];
var createCumSumTransform = /* @__PURE__ */ factory(name308, dependencies309, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    unaryPlus
  } = _ref;
  var cumsum = createCumSum({
    typed: typed2,
    add: add2,
    unaryPlus
  });
  return typed2(name308, {
    "...any": function any(args) {
      if (args.length === 2 && isCollection(args[0])) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
      }
      try {
        return cumsum.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
var name309 = "variance";
var dependencies310 = ["typed", "add", "subtract", "multiply", "divide", "mapSlices", "isNaN"];
var createVarianceTransform = /* @__PURE__ */ factory(name309, dependencies310, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    mapSlices,
    isNaN: isNaN2
  } = _ref;
  var variance = createVariance({
    typed: typed2,
    add: add2,
    subtract,
    multiply,
    divide: divide2,
    mapSlices,
    isNaN: isNaN2
  });
  return typed2(name309, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return variance.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/print.transform.js
var name310 = "print";
var dependencies311 = ["typed", "matrix", "zeros", "add"];
var createPrintTransform = /* @__PURE__ */ factory(name310, dependencies311, (_ref) => {
  var {
    typed: typed2,
    matrix,
    zeros: zeros2,
    add: add2
  } = _ref;
  var print = createPrint({
    typed: typed2,
    matrix,
    zeros: zeros2,
    add: add2
  });
  return typed2(name310, {
    "string, Object | Array": function string_Object__Array(template, values) {
      return print(_convertTemplateToZeroBasedIndex(template), values);
    },
    "string, Object | Array, number | Object": function string_Object__Array_number__Object(template, values, options) {
      return print(_convertTemplateToZeroBasedIndex(template), values, options);
    }
  });
  function _convertTemplateToZeroBasedIndex(template) {
    return template.replace(printTemplate, (x) => {
      var parts = x.slice(1).split(".");
      var result = parts.map(function(part) {
        if (!isNaN(part) && part.length > 0) {
          return parseInt(part) - 1;
        } else {
          return part;
        }
      });
      return "$" + result.join(".");
    });
  }
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/and.transform.js
var name311 = "and";
var dependencies312 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createAndTransform = /* @__PURE__ */ factory(name311, dependencies312, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    not,
    concat: concat2
  } = _ref;
  var and = createAnd({
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    not,
    concat: concat2
  });
  function andTransform(args, math, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && !and(condition1, true)) {
      return false;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return and(condition1, condition2);
  }
  andTransform.rawArgs = true;
  return andTransform;
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/or.transform.js
var name312 = "or";
var dependencies313 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOrTransform = /* @__PURE__ */ factory(name312, dependencies313, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var or2 = createOr({
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: concat2
  });
  function orTransform(args, math, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && or2(condition1, false)) {
      return true;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return or2(condition1, condition2);
  }
  orTransform.rawArgs = true;
  return orTransform;
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/bitAnd.transform.js
var name313 = "bitAnd";
var dependencies314 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createBitAndTransform = /* @__PURE__ */ factory(name313, dependencies314, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    not,
    concat: concat2
  } = _ref;
  var bitAnd = createBitAnd({
    typed: typed2,
    matrix,
    equalScalar,
    zeros: zeros2,
    not,
    concat: concat2
  });
  function bitAndTransform(args, math, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === 0 || condition1 === false) {
        return 0;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitAnd(condition1, condition2);
  }
  bitAndTransform.rawArgs = true;
  return bitAndTransform;
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/expression/transform/bitOr.transform.js
var name314 = "bitOr";
var dependencies315 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOrTransform = /* @__PURE__ */ factory(name314, dependencies315, (_ref) => {
  var {
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: concat2
  } = _ref;
  var bitOr = createBitOr({
    typed: typed2,
    matrix,
    equalScalar,
    DenseMatrix,
    concat: concat2
  });
  function bitOrTransform(args, math, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === -1) {
        return -1;
      }
      if (condition1 === true) {
        return 1;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitOr(condition1, condition2);
  }
  bitOrTransform.rawArgs = true;
  return bitOrTransform;
}, {
  isTransformFunction: true
});
// node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
var BigNumber = /* @__PURE__ */ createBigNumberClass({
  config
});
var Complex2 = /* @__PURE__ */ createComplexClass({});
var e2 = /* @__PURE__ */ createE({
  BigNumber,
  config
});
var _false = /* @__PURE__ */ createFalse({});
var fineStructure = /* @__PURE__ */ createFineStructure({
  BigNumber,
  config
});
var Fraction2 = /* @__PURE__ */ createFractionClass({});
var i = /* @__PURE__ */ createI({
  Complex: Complex2
});
var _Infinity = /* @__PURE__ */ createInfinity({
  BigNumber,
  config
});
var LN102 = /* @__PURE__ */ createLN10({
  BigNumber,
  config
});
var LOG10E = /* @__PURE__ */ createLOG10E({
  BigNumber,
  config
});
var Matrix = /* @__PURE__ */ createMatrixClass({});
var _NaN = /* @__PURE__ */ createNaN({
  BigNumber,
  config
});
var _null = /* @__PURE__ */ createNull({});
var phi2 = /* @__PURE__ */ createPhi({
  BigNumber,
  config
});
var Range = /* @__PURE__ */ createRangeClass({});
var ResultSet = /* @__PURE__ */ createResultSet({});
var SQRT1_2 = /* @__PURE__ */ createSQRT1_2({
  BigNumber,
  config
});
var sackurTetrode = /* @__PURE__ */ createSackurTetrode({
  BigNumber,
  config
});
var tau2 = /* @__PURE__ */ createTau({
  BigNumber,
  config
});
var _true = /* @__PURE__ */ createTrue({});
var version2 = /* @__PURE__ */ createVersion({});
var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
  Matrix
});
var efimovFactor = /* @__PURE__ */ createEfimovFactor({
  BigNumber,
  config
});
var LN2 = /* @__PURE__ */ createLN2({
  BigNumber,
  config
});
var pi2 = /* @__PURE__ */ createPi({
  BigNumber,
  config
});
var replacer = /* @__PURE__ */ createReplacer({});
var SQRT2 = /* @__PURE__ */ createSQRT2({
  BigNumber,
  config
});
var typed2 = /* @__PURE__ */ createTyped({
  BigNumber,
  Complex: Complex2,
  DenseMatrix,
  Fraction: Fraction2
});
var weakMixingAngle = /* @__PURE__ */ createWeakMixingAngle({
  BigNumber,
  config
});
var abs2 = /* @__PURE__ */ createAbs({
  typed: typed2
});
var acos2 = /* @__PURE__ */ createAcos({
  Complex: Complex2,
  config,
  typed: typed2
});
var acot = /* @__PURE__ */ createAcot({
  BigNumber,
  typed: typed2
});
var acsc = /* @__PURE__ */ createAcsc({
  BigNumber,
  Complex: Complex2,
  config,
  typed: typed2
});
var addScalar = /* @__PURE__ */ createAddScalar({
  typed: typed2
});
var arg = /* @__PURE__ */ createArg({
  typed: typed2
});
var asech = /* @__PURE__ */ createAsech({
  BigNumber,
  Complex: Complex2,
  config,
  typed: typed2
});
var asinh3 = /* @__PURE__ */ createAsinh({
  typed: typed2
});
var atan3 = /* @__PURE__ */ createAtan({
  typed: typed2
});
var atanh3 = /* @__PURE__ */ createAtanh({
  Complex: Complex2,
  config,
  typed: typed2
});
var bigint = /* @__PURE__ */ createBigint({
  typed: typed2
});
var bitNot = /* @__PURE__ */ createBitNot({
  typed: typed2
});
var boolean = /* @__PURE__ */ createBoolean({
  typed: typed2
});
var clone4 = /* @__PURE__ */ createClone({
  typed: typed2
});
var combinations = /* @__PURE__ */ createCombinations({
  typed: typed2
});
var complex = /* @__PURE__ */ createComplex({
  Complex: Complex2,
  typed: typed2
});
var conj = /* @__PURE__ */ createConj({
  typed: typed2
});
var cos2 = /* @__PURE__ */ createCos({
  typed: typed2
});
var cot = /* @__PURE__ */ createCot({
  BigNumber,
  typed: typed2
});
var csc = /* @__PURE__ */ createCsc({
  BigNumber,
  typed: typed2
});
var cube = /* @__PURE__ */ createCube({
  typed: typed2
});
var equalScalar = /* @__PURE__ */ createEqualScalar({
  config,
  typed: typed2
});
var erf = /* @__PURE__ */ createErf({
  typed: typed2
});
var exp2 = /* @__PURE__ */ createExp({
  typed: typed2
});
var expm13 = /* @__PURE__ */ createExpm1({
  Complex: Complex2,
  typed: typed2
});
var filter2 = /* @__PURE__ */ createFilter({
  typed: typed2
});
var flatten2 = /* @__PURE__ */ createFlatten({
  typed: typed2
});
var forEach2 = /* @__PURE__ */ createForEach({
  typed: typed2
});
var format4 = /* @__PURE__ */ createFormat({
  typed: typed2
});
var getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
  typed: typed2
});
var hex = /* @__PURE__ */ createHex({
  format: format4,
  typed: typed2
});
var im2 = /* @__PURE__ */ createIm({
  typed: typed2
});
var isInteger2 = /* @__PURE__ */ createIsInteger({
  typed: typed2
});
var isNegative = /* @__PURE__ */ createIsNegative({
  config,
  typed: typed2
});
var isPositive = /* @__PURE__ */ createIsPositive({
  config,
  typed: typed2
});
var isZero = /* @__PURE__ */ createIsZero({
  equalScalar,
  typed: typed2
});
var LOG2E = /* @__PURE__ */ createLOG2E({
  BigNumber,
  config
});
var lgamma = /* @__PURE__ */ createLgamma({
  Complex: Complex2,
  typed: typed2
});
var log104 = /* @__PURE__ */ createLog10({
  Complex: Complex2,
  config,
  typed: typed2
});
var log24 = /* @__PURE__ */ createLog2({
  Complex: Complex2,
  config,
  typed: typed2
});
var map2 = /* @__PURE__ */ createMap2({
  typed: typed2
});
var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
  typed: typed2
});
var not = /* @__PURE__ */ createNot({
  typed: typed2
});
var number = /* @__PURE__ */ createNumber({
  typed: typed2
});
var oct = /* @__PURE__ */ createOct({
  format: format4,
  typed: typed2
});
var pickRandom = /* @__PURE__ */ createPickRandom({
  config,
  typed: typed2
});
var print = /* @__PURE__ */ createPrint({
  typed: typed2
});
var random2 = /* @__PURE__ */ createRandom({
  config,
  typed: typed2
});
var re = /* @__PURE__ */ createRe({
  typed: typed2
});
var sec = /* @__PURE__ */ createSec({
  BigNumber,
  typed: typed2
});
var sign3 = /* @__PURE__ */ createSign({
  BigNumber,
  Fraction: Fraction2,
  complex,
  typed: typed2
});
var sin2 = /* @__PURE__ */ createSin({
  typed: typed2
});
var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed: typed2
});
var splitUnit = /* @__PURE__ */ createSplitUnit({
  typed: typed2
});
var square = /* @__PURE__ */ createSquare({
  typed: typed2
});
var string = /* @__PURE__ */ createString({
  typed: typed2
});
var subtractScalar = /* @__PURE__ */ createSubtractScalar({
  typed: typed2
});
var tan2 = /* @__PURE__ */ createTan({
  typed: typed2
});
var typeOf2 = /* @__PURE__ */ createTypeOf({
  typed: typed2
});
var acosh3 = /* @__PURE__ */ createAcosh({
  Complex: Complex2,
  config,
  typed: typed2
});
var acsch = /* @__PURE__ */ createAcsch({
  BigNumber,
  typed: typed2
});
var asec = /* @__PURE__ */ createAsec({
  BigNumber,
  Complex: Complex2,
  config,
  typed: typed2
});
var bignumber = /* @__PURE__ */ createBignumber({
  BigNumber,
  typed: typed2
});
var combinationsWithRep = /* @__PURE__ */ createCombinationsWithRep({
  typed: typed2
});
var cosh4 = /* @__PURE__ */ createCosh({
  typed: typed2
});
var csch = /* @__PURE__ */ createCsch({
  BigNumber,
  typed: typed2
});
var isNaN2 = /* @__PURE__ */ createIsNaN({
  typed: typed2
});
var isPrime = /* @__PURE__ */ createIsPrime({
  typed: typed2
});
var mapSlices = /* @__PURE__ */ createMapSlices({
  isInteger: isInteger2,
  typed: typed2
});
var matrix = /* @__PURE__ */ createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed: typed2
});
var matrixFromFunction = /* @__PURE__ */ createMatrixFromFunction({
  isZero,
  matrix,
  typed: typed2
});
var ones = /* @__PURE__ */ createOnes({
  BigNumber,
  config,
  matrix,
  typed: typed2
});
var randomInt = /* @__PURE__ */ createRandomInt({
  config,
  log2: log24,
  typed: typed2
});
var reshape2 = /* @__PURE__ */ createReshape({
  isInteger: isInteger2,
  matrix,
  typed: typed2
});
var sech = /* @__PURE__ */ createSech({
  BigNumber,
  typed: typed2
});
var sinh4 = /* @__PURE__ */ createSinh({
  typed: typed2
});
var sparse = /* @__PURE__ */ createSparse({
  SparseMatrix,
  typed: typed2
});
var sqrt2 = /* @__PURE__ */ createSqrt({
  Complex: Complex2,
  config,
  typed: typed2
});
var squeeze2 = /* @__PURE__ */ createSqueeze({
  typed: typed2
});
var tanh3 = /* @__PURE__ */ createTanh({
  typed: typed2
});
var transpose = /* @__PURE__ */ createTranspose({
  matrix,
  typed: typed2
});
var xgcd = /* @__PURE__ */ createXgcd({
  BigNumber,
  config,
  matrix,
  typed: typed2
});
var zeros2 = /* @__PURE__ */ createZeros({
  BigNumber,
  config,
  matrix,
  typed: typed2
});
var acoth = /* @__PURE__ */ createAcoth({
  BigNumber,
  Complex: Complex2,
  config,
  typed: typed2
});
var asin2 = /* @__PURE__ */ createAsin({
  Complex: Complex2,
  config,
  typed: typed2
});
var bin = /* @__PURE__ */ createBin({
  format: format4,
  typed: typed2
});
var concat2 = /* @__PURE__ */ createConcat({
  isInteger: isInteger2,
  matrix,
  typed: typed2
});
var coth = /* @__PURE__ */ createCoth({
  BigNumber,
  typed: typed2
});
var ctranspose = /* @__PURE__ */ createCtranspose({
  conj,
  transpose,
  typed: typed2
});
var diag = /* @__PURE__ */ createDiag({
  DenseMatrix,
  SparseMatrix,
  matrix,
  typed: typed2
});
var dotMultiply = /* @__PURE__ */ createDotMultiply({
  concat: concat2,
  equalScalar,
  matrix,
  multiplyScalar,
  typed: typed2
});
var equal = /* @__PURE__ */ createEqual({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var fraction = /* @__PURE__ */ createFraction({
  Fraction: Fraction2,
  typed: typed2
});
var identity = /* @__PURE__ */ createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config,
  matrix,
  typed: typed2
});
var isNumeric = /* @__PURE__ */ createIsNumeric({
  typed: typed2
});
var kron = /* @__PURE__ */ createKron({
  matrix,
  multiplyScalar,
  typed: typed2
});
var largerEq = /* @__PURE__ */ createLargerEq({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  config,
  matrix,
  typed: typed2
});
var leftShift = /* @__PURE__ */ createLeftShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var mode = /* @__PURE__ */ createMode({
  isNaN: isNaN2,
  isNumeric,
  typed: typed2
});
var nthRoot = /* @__PURE__ */ createNthRoot({
  BigNumber,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var numeric2 = /* @__PURE__ */ createNumeric({
  bignumber,
  fraction,
  number
});
var prod = /* @__PURE__ */ createProd({
  config,
  multiplyScalar,
  numeric: numeric2,
  typed: typed2
});
var resize2 = /* @__PURE__ */ createResize({
  config,
  matrix
});
var rightArithShift = /* @__PURE__ */ createRightArithShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var round2 = /* @__PURE__ */ createRound({
  BigNumber,
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var size = /* @__PURE__ */ createSize({
  matrix,
  config,
  typed: typed2
});
var smaller = /* @__PURE__ */ createSmaller({
  DenseMatrix,
  SparseMatrix,
  bignumber,
  concat: concat2,
  config,
  matrix,
  typed: typed2
});
var to = /* @__PURE__ */ createTo({
  concat: concat2,
  matrix,
  typed: typed2
});
var unaryMinus = /* @__PURE__ */ createUnaryMinus({
  typed: typed2
});
var unequal = /* @__PURE__ */ createUnequal({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  typed: typed2
});
var xor = /* @__PURE__ */ createXor({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  matrix,
  typed: typed2
});
var add2 = /* @__PURE__ */ createAdd({
  DenseMatrix,
  SparseMatrix,
  addScalar,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var atan22 = /* @__PURE__ */ createAtan2({
  BigNumber,
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var bitAnd = /* @__PURE__ */ createBitAnd({
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var bitOr = /* @__PURE__ */ createBitOr({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var bitXor2 = /* @__PURE__ */ createBitXor({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  matrix,
  typed: typed2
});
var cbrt4 = /* @__PURE__ */ createCbrt({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  config,
  isNegative,
  matrix,
  typed: typed2,
  unaryMinus
});
var compare = /* @__PURE__ */ createCompare({
  BigNumber,
  DenseMatrix,
  Fraction: Fraction2,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  typed: typed2
});
var compareText2 = /* @__PURE__ */ createCompareText({
  concat: concat2,
  matrix,
  typed: typed2
});
var count = /* @__PURE__ */ createCount({
  prod,
  size,
  typed: typed2
});
var deepEqual = /* @__PURE__ */ createDeepEqual({
  equal,
  typed: typed2
});
var divideScalar = /* @__PURE__ */ createDivideScalar({
  numeric: numeric2,
  typed: typed2
});
var dotDivide = /* @__PURE__ */ createDotDivide({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  divideScalar,
  equalScalar,
  matrix,
  typed: typed2
});
var equalText = /* @__PURE__ */ createEqualText({
  compareText: compareText2,
  isZero,
  typed: typed2
});
var floor2 = /* @__PURE__ */ createFloor({
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var gcd2 = /* @__PURE__ */ createGcd({
  BigNumber,
  DenseMatrix,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var hasNumericValue = /* @__PURE__ */ createHasNumericValue({
  isNumeric,
  typed: typed2
});
var hypot3 = /* @__PURE__ */ createHypot({
  abs: abs2,
  addScalar,
  divideScalar,
  isPositive,
  multiplyScalar,
  smaller,
  sqrt: sqrt2,
  typed: typed2
});
var ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller
});
var Index = /* @__PURE__ */ createIndexClass({
  ImmutableDenseMatrix,
  getMatrixDataType
});
var larger = /* @__PURE__ */ createLarger({
  DenseMatrix,
  SparseMatrix,
  bignumber,
  concat: concat2,
  config,
  matrix,
  typed: typed2
});
var log3 = /* @__PURE__ */ createLog({
  Complex: Complex2,
  config,
  divideScalar,
  typeOf: typeOf2,
  typed: typed2
});
var lsolve = /* @__PURE__ */ createLsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
  flatten: flatten2,
  matrix,
  size,
  typed: typed2
});
var max2 = /* @__PURE__ */ createMax({
  config,
  larger,
  numeric: numeric2,
  typed: typed2
});
var min2 = /* @__PURE__ */ createMin({
  config,
  numeric: numeric2,
  smaller,
  typed: typed2
});
var mod2 = /* @__PURE__ */ createMod({
  DenseMatrix,
  concat: concat2,
  config,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var nthRoots = /* @__PURE__ */ createNthRoots({
  Complex: Complex2,
  config,
  divideScalar,
  typed: typed2
});
var or2 = /* @__PURE__ */ createOr({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var partitionSelect = /* @__PURE__ */ createPartitionSelect({
  compare,
  isNaN: isNaN2,
  isNumeric,
  typed: typed2
});
var qr = /* @__PURE__ */ createQr({
  addScalar,
  complex,
  conj,
  divideScalar,
  equal,
  identity,
  isZero,
  matrix,
  multiplyScalar,
  sign: sign3,
  sqrt: sqrt2,
  subtractScalar,
  typed: typed2,
  unaryMinus,
  zeros: zeros2
});
var rightLogShift = /* @__PURE__ */ createRightLogShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var smallerEq = /* @__PURE__ */ createSmallerEq({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  config,
  matrix,
  typed: typed2
});
var subset = /* @__PURE__ */ createSubset({
  add: add2,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var subtract = /* @__PURE__ */ createSubtract({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  subtractScalar,
  typed: typed2,
  unaryMinus
});
var trace = /* @__PURE__ */ createTrace({
  add: add2,
  matrix,
  typed: typed2
});
var usolve = /* @__PURE__ */ createUsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var catalan = /* @__PURE__ */ createCatalan({
  addScalar,
  combinations,
  divideScalar,
  isInteger: isInteger2,
  isNegative,
  multiplyScalar,
  typed: typed2
});
var compareNatural = /* @__PURE__ */ createCompareNatural({
  compare,
  typed: typed2
});
var composition = /* @__PURE__ */ createComposition({
  addScalar,
  combinations,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  larger,
  typed: typed2
});
var diff = /* @__PURE__ */ createDiff({
  matrix,
  number,
  subtract,
  typed: typed2
});
var distance = /* @__PURE__ */ createDistance({
  abs: abs2,
  addScalar,
  deepEqual,
  divideScalar,
  multiplyScalar,
  sqrt: sqrt2,
  subtractScalar,
  typed: typed2
});
var dot = /* @__PURE__ */ createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed: typed2
});
var FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
  larger,
  smaller
});
var index = /* @__PURE__ */ createIndex({
  Index,
  typed: typed2
});
var invmod = /* @__PURE__ */ createInvmod({
  BigNumber,
  add: add2,
  config,
  equal,
  isInteger: isInteger2,
  mod: mod2,
  smaller,
  typed: typed2,
  xgcd
});
var lcm = /* @__PURE__ */ createLcm({
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var log1p2 = /* @__PURE__ */ createLog1p({
  Complex: Complex2,
  config,
  divideScalar,
  log: log3,
  typed: typed2
});
var lsolveAll = /* @__PURE__ */ createLsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var matrixFromRows = /* @__PURE__ */ createMatrixFromRows({
  flatten: flatten2,
  matrix,
  size,
  typed: typed2
});
var multiply = /* @__PURE__ */ createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed: typed2
});
var range = /* @__PURE__ */ createRange({
  bignumber,
  matrix,
  add: add2,
  config,
  isPositive,
  larger,
  largerEq,
  smaller,
  smallerEq,
  typed: typed2
});
var row = /* @__PURE__ */ createRow({
  Index,
  matrix,
  range,
  typed: typed2
});
var setCartesian = /* @__PURE__ */ createSetCartesian({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setDistinct = /* @__PURE__ */ createSetDistinct({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setIsSubset = /* @__PURE__ */ createSetIsSubset({
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setPowerset = /* @__PURE__ */ createSetPowerset({
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var slu = /* @__PURE__ */ createSlu({
  SparseMatrix,
  abs: abs2,
  add: add2,
  divideScalar,
  larger,
  largerEq,
  multiply,
  subtract,
  transpose,
  typed: typed2
});
var sort = /* @__PURE__ */ createSort({
  compare,
  compareNatural,
  matrix,
  typed: typed2
});
var unaryPlus = /* @__PURE__ */ createUnaryPlus({
  config,
  numeric: numeric2,
  typed: typed2
});
var usolveAll = /* @__PURE__ */ createUsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var zpk2tf = /* @__PURE__ */ createZpk2tf({
  Complex: Complex2,
  add: add2,
  multiply,
  number,
  typed: typed2
});
var and = /* @__PURE__ */ createAnd({
  concat: concat2,
  equalScalar,
  matrix,
  not,
  typed: typed2,
  zeros: zeros2
});
var ceil2 = /* @__PURE__ */ createCeil({
  DenseMatrix,
  config,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var column = /* @__PURE__ */ createColumn({
  Index,
  matrix,
  range,
  typed: typed2
});
var cross = /* @__PURE__ */ createCross({
  matrix,
  multiply,
  subtract,
  typed: typed2
});
var det = /* @__PURE__ */ createDet({
  divideScalar,
  isZero,
  matrix,
  multiply,
  subtractScalar,
  typed: typed2,
  unaryMinus
});
var fix = /* @__PURE__ */ createFix({
  Complex: Complex2,
  DenseMatrix,
  ceil: ceil2,
  equalScalar,
  floor: floor2,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var inv = /* @__PURE__ */ createInv({
  abs: abs2,
  addScalar,
  det,
  divideScalar,
  identity,
  matrix,
  multiply,
  typed: typed2,
  unaryMinus
});
var pinv = /* @__PURE__ */ createPinv({
  Complex: Complex2,
  add: add2,
  ctranspose,
  deepEqual,
  divideScalar,
  dot,
  dotDivide,
  equal,
  inv,
  matrix,
  multiply,
  typed: typed2
});
var pow2 = /* @__PURE__ */ createPow({
  Complex: Complex2,
  config,
  fraction,
  identity,
  inv,
  matrix,
  multiply,
  number,
  typed: typed2
});
var setDifference = /* @__PURE__ */ createSetDifference({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setMultiplicity = /* @__PURE__ */ createSetMultiplicity({
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setSymDifference = /* @__PURE__ */ createSetSymDifference({
  Index,
  concat: concat2,
  setDifference,
  size,
  subset,
  typed: typed2
});
var Spa = /* @__PURE__ */ createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var sqrtm = /* @__PURE__ */ createSqrtm({
  abs: abs2,
  add: add2,
  identity,
  inv,
  map: map2,
  max: max2,
  multiply,
  size,
  sqrt: sqrt2,
  subtract,
  typed: typed2
});
var sum2 = /* @__PURE__ */ createSum({
  add: add2,
  config,
  numeric: numeric2,
  typed: typed2
});
var Unit = /* @__PURE__ */ createUnitClass({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  abs: abs2,
  addScalar,
  config,
  divideScalar,
  equal,
  fix,
  format: format4,
  isNumeric,
  multiplyScalar,
  number,
  pow: pow2,
  round: round2,
  subtractScalar
});
var vacuumImpedance = /* @__PURE__ */ createVacuumImpedance({
  BigNumber,
  Unit,
  config
});
var wienDisplacement = /* @__PURE__ */ createWienDisplacement({
  BigNumber,
  Unit,
  config
});
var atomicMass = /* @__PURE__ */ createAtomicMass({
  BigNumber,
  Unit,
  config
});
var bohrMagneton = /* @__PURE__ */ createBohrMagneton({
  BigNumber,
  Unit,
  config
});
var boltzmann = /* @__PURE__ */ createBoltzmann({
  BigNumber,
  Unit,
  config
});
var conductanceQuantum = /* @__PURE__ */ createConductanceQuantum({
  BigNumber,
  Unit,
  config
});
var coulomb = /* @__PURE__ */ createCoulomb({
  BigNumber,
  Unit,
  config
});
var cumsum = /* @__PURE__ */ createCumSum({
  add: add2,
  typed: typed2,
  unaryPlus
});
var deuteronMass = /* @__PURE__ */ createDeuteronMass({
  BigNumber,
  Unit,
  config
});
var dotPow = /* @__PURE__ */ createDotPow({
  DenseMatrix,
  SparseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  pow: pow2,
  typed: typed2
});
var electricConstant = /* @__PURE__ */ createElectricConstant({
  BigNumber,
  Unit,
  config
});
var elementaryCharge = /* @__PURE__ */ createElementaryCharge({
  BigNumber,
  Unit,
  config
});
var expm = /* @__PURE__ */ createExpm({
  abs: abs2,
  add: add2,
  identity,
  inv,
  multiply,
  typed: typed2
});
var faraday = /* @__PURE__ */ createFaraday({
  BigNumber,
  Unit,
  config
});
var fft = /* @__PURE__ */ createFft({
  addScalar,
  ceil: ceil2,
  conj,
  divideScalar,
  dotDivide,
  exp: exp2,
  i,
  log2: log24,
  matrix,
  multiplyScalar,
  pow: pow2,
  tau: tau2,
  typed: typed2
});
var gamma = /* @__PURE__ */ createGamma({
  BigNumber,
  Complex: Complex2,
  config,
  multiplyScalar,
  pow: pow2,
  typed: typed2
});
var gravitationConstant = /* @__PURE__ */ createGravitationConstant({
  BigNumber,
  Unit,
  config
});
var hartreeEnergy = /* @__PURE__ */ createHartreeEnergy({
  BigNumber,
  Unit,
  config
});
var ifft = /* @__PURE__ */ createIfft({
  conj,
  dotDivide,
  fft,
  typed: typed2
});
var inverseConductanceQuantum = /* @__PURE__ */ createInverseConductanceQuantum({
  BigNumber,
  Unit,
  config
});
var klitzing = /* @__PURE__ */ createKlitzing({
  BigNumber,
  Unit,
  config
});
var loschmidt = /* @__PURE__ */ createLoschmidt({
  BigNumber,
  Unit,
  config
});
var magneticConstant = /* @__PURE__ */ createMagneticConstant({
  BigNumber,
  Unit,
  config
});
var molarMass = /* @__PURE__ */ createMolarMass({
  BigNumber,
  Unit,
  config
});
var molarPlanckConstant = /* @__PURE__ */ createMolarPlanckConstant({
  BigNumber,
  Unit,
  config
});
var neutronMass = /* @__PURE__ */ createNeutronMass({
  BigNumber,
  Unit,
  config
});
var nuclearMagneton = /* @__PURE__ */ createNuclearMagneton({
  BigNumber,
  Unit,
  config
});
var planckCharge = /* @__PURE__ */ createPlanckCharge({
  BigNumber,
  Unit,
  config
});
var planckLength = /* @__PURE__ */ createPlanckLength({
  BigNumber,
  Unit,
  config
});
var planckTemperature = /* @__PURE__ */ createPlanckTemperature({
  BigNumber,
  Unit,
  config
});
var protonMass = /* @__PURE__ */ createProtonMass({
  BigNumber,
  Unit,
  config
});
var quantumOfCirculation = /* @__PURE__ */ createQuantumOfCirculation({
  BigNumber,
  Unit,
  config
});
var reducedPlanckConstant = /* @__PURE__ */ createReducedPlanckConstant({
  BigNumber,
  Unit,
  config
});
var rydberg = /* @__PURE__ */ createRydberg({
  BigNumber,
  Unit,
  config
});
var secondRadiation = /* @__PURE__ */ createSecondRadiation({
  BigNumber,
  Unit,
  config
});
var setSize = /* @__PURE__ */ createSetSize({
  compareNatural,
  typed: typed2
});
var speedOfLight = /* @__PURE__ */ createSpeedOfLight({
  BigNumber,
  Unit,
  config
});
var stefanBoltzmann = /* @__PURE__ */ createStefanBoltzmann({
  BigNumber,
  Unit,
  config
});
var thomsonCrossSection = /* @__PURE__ */ createThomsonCrossSection({
  BigNumber,
  Unit,
  config
});
var avogadro = /* @__PURE__ */ createAvogadro({
  BigNumber,
  Unit,
  config
});
var bohrRadius = /* @__PURE__ */ createBohrRadius({
  BigNumber,
  Unit,
  config
});
var createUnit = /* @__PURE__ */ createCreateUnit({
  Unit,
  typed: typed2
});
var divide2 = /* @__PURE__ */ createDivide({
  divideScalar,
  equalScalar,
  inv,
  matrix,
  multiply,
  typed: typed2
});
var electronMass = /* @__PURE__ */ createElectronMass({
  BigNumber,
  Unit,
  config
});
var factorial = /* @__PURE__ */ createFactorial({
  gamma,
  typed: typed2
});
var firstRadiation = /* @__PURE__ */ createFirstRadiation({
  BigNumber,
  Unit,
  config
});
var gravity = /* @__PURE__ */ createGravity({
  BigNumber,
  Unit,
  config
});
var intersect = /* @__PURE__ */ createIntersect({
  abs: abs2,
  add: add2,
  addScalar,
  config,
  divideScalar,
  equalScalar,
  flatten: flatten2,
  isNumeric,
  isZero,
  matrix,
  multiply,
  multiplyScalar,
  smaller,
  subtract,
  typed: typed2
});
var lup = /* @__PURE__ */ createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs: abs2,
  addScalar,
  divideScalar,
  equalScalar,
  larger,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2,
  unaryMinus
});
var magneticFluxQuantum = /* @__PURE__ */ createMagneticFluxQuantum({
  BigNumber,
  Unit,
  config
});
var molarMassC12 = /* @__PURE__ */ createMolarMassC12({
  BigNumber,
  Unit,
  config
});
var multinomial = /* @__PURE__ */ createMultinomial({
  add: add2,
  divide: divide2,
  factorial,
  isInteger: isInteger2,
  isPositive,
  multiply,
  typed: typed2
});
var permutations = /* @__PURE__ */ createPermutations({
  factorial,
  typed: typed2
});
var planckMass = /* @__PURE__ */ createPlanckMass({
  BigNumber,
  Unit,
  config
});
var polynomialRoot = /* @__PURE__ */ createPolynomialRoot({
  add: add2,
  cbrt: cbrt4,
  divide: divide2,
  equalScalar,
  im: im2,
  isZero,
  multiply,
  re,
  sqrt: sqrt2,
  subtract,
  typeOf: typeOf2,
  typed: typed2,
  unaryMinus
});
var setIntersect = /* @__PURE__ */ createSetIntersect({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var solveODE = /* @__PURE__ */ createSolveODE({
  abs: abs2,
  add: add2,
  bignumber,
  divide: divide2,
  isNegative,
  isPositive,
  larger,
  map: map2,
  matrix,
  max: max2,
  multiply,
  smaller,
  subtract,
  typed: typed2,
  unaryMinus
});
var stirlingS2 = /* @__PURE__ */ createStirlingS2({
  bignumber,
  addScalar,
  combinations,
  divideScalar,
  factorial,
  isInteger: isInteger2,
  isNegative,
  larger,
  multiplyScalar,
  number,
  pow: pow2,
  subtractScalar,
  typed: typed2
});
var unit = /* @__PURE__ */ createUnitFunction({
  Unit,
  typed: typed2
});
var bellNumbers = /* @__PURE__ */ createBellNumbers({
  addScalar,
  isInteger: isInteger2,
  isNegative,
  stirlingS2,
  typed: typed2
});
var eigs = /* @__PURE__ */ createEigs({
  abs: abs2,
  add: add2,
  addScalar,
  atan: atan3,
  bignumber,
  column,
  complex,
  config,
  cos: cos2,
  diag,
  divideScalar,
  dot,
  equal,
  flatten: flatten2,
  im: im2,
  inv,
  larger,
  matrix,
  matrixFromColumns,
  multiply,
  multiplyScalar,
  number,
  qr,
  re,
  reshape: reshape2,
  sin: sin2,
  size,
  smaller,
  sqrt: sqrt2,
  subtract,
  typed: typed2,
  usolve,
  usolveAll
});
var fermiCoupling = /* @__PURE__ */ createFermiCoupling({
  BigNumber,
  Unit,
  config
});
var gasConstant = /* @__PURE__ */ createGasConstant({
  BigNumber,
  Unit,
  config
});
var kldivergence = /* @__PURE__ */ createKldivergence({
  divide: divide2,
  dotDivide,
  isNumeric,
  log: log3,
  map: map2,
  matrix,
  multiply,
  sum: sum2,
  typed: typed2
});
var lusolve = /* @__PURE__ */ createLusolve({
  DenseMatrix,
  lsolve,
  lup,
  matrix,
  slu,
  typed: typed2,
  usolve
});
var mean = /* @__PURE__ */ createMean({
  add: add2,
  divide: divide2,
  typed: typed2
});
var molarVolume = /* @__PURE__ */ createMolarVolume({
  BigNumber,
  Unit,
  config
});
var planckConstant = /* @__PURE__ */ createPlanckConstant({
  BigNumber,
  Unit,
  config
});
var quantileSeq = /* @__PURE__ */ createQuantileSeq({
  bignumber,
  add: add2,
  compare,
  divide: divide2,
  isInteger: isInteger2,
  larger,
  mapSlices,
  multiply,
  partitionSelect,
  smaller,
  smallerEq,
  subtract,
  typed: typed2
});
var setUnion = /* @__PURE__ */ createSetUnion({
  Index,
  concat: concat2,
  setIntersect,
  setSymDifference,
  size,
  subset,
  typed: typed2
});
var variance = /* @__PURE__ */ createVariance({
  add: add2,
  divide: divide2,
  isNaN: isNaN2,
  mapSlices,
  multiply,
  subtract,
  typed: typed2
});
var classicalElectronRadius = /* @__PURE__ */ createClassicalElectronRadius({
  BigNumber,
  Unit,
  config
});
var median = /* @__PURE__ */ createMedian({
  add: add2,
  compare,
  divide: divide2,
  partitionSelect,
  typed: typed2
});
var corr = /* @__PURE__ */ createCorr({
  add: add2,
  divide: divide2,
  matrix,
  mean,
  multiply,
  pow: pow2,
  sqrt: sqrt2,
  subtract,
  sum: sum2,
  typed: typed2
});
var freqz = /* @__PURE__ */ createFreqz({
  Complex: Complex2,
  add: add2,
  divide: divide2,
  matrix,
  multiply,
  typed: typed2
});
var mad = /* @__PURE__ */ createMad({
  abs: abs2,
  map: map2,
  median,
  subtract,
  typed: typed2
});
var std = /* @__PURE__ */ createStd({
  map: map2,
  sqrt: sqrt2,
  typed: typed2,
  variance
});
var zeta = /* @__PURE__ */ createZeta({
  BigNumber,
  Complex: Complex2,
  add: add2,
  config,
  divide: divide2,
  equal,
  factorial,
  gamma,
  isNegative,
  multiply,
  pi: pi2,
  pow: pow2,
  sin: sin2,
  smallerEq,
  subtract,
  typed: typed2
});
var norm = /* @__PURE__ */ createNorm({
  abs: abs2,
  add: add2,
  conj,
  ctranspose,
  eigs,
  equalScalar,
  larger,
  matrix,
  multiply,
  pow: pow2,
  smaller,
  sqrt: sqrt2,
  typed: typed2
});
var rotationMatrix = /* @__PURE__ */ createRotationMatrix({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  addScalar,
  config,
  cos: cos2,
  matrix,
  multiplyScalar,
  norm,
  sin: sin2,
  typed: typed2,
  unaryMinus
});
var planckTime = /* @__PURE__ */ createPlanckTime({
  BigNumber,
  Unit,
  config
});
var schur = /* @__PURE__ */ createSchur({
  identity,
  matrix,
  multiply,
  norm,
  qr,
  subtract,
  typed: typed2
});
var rotate = /* @__PURE__ */ createRotate({
  multiply,
  rotationMatrix,
  typed: typed2
});
var sylvester = /* @__PURE__ */ createSylvester({
  abs: abs2,
  add: add2,
  concat: concat2,
  identity,
  index,
  lusolve,
  matrix,
  matrixFromColumns,
  multiply,
  range,
  schur,
  subset,
  subtract,
  transpose,
  typed: typed2
});
var lyap = /* @__PURE__ */ createLyap({
  matrix,
  multiply,
  sylvester,
  transpose,
  typed: typed2
});

// node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
var math = {};
var mathWithTransform = {};
var classes = {};
var Node = createNode({
  mathWithTransform
});
var ObjectNode = createObjectNode({
  Node
});
var OperatorNode = createOperatorNode({
  Node
});
var ParenthesisNode = createParenthesisNode({
  Node
});
var RelationalNode = createRelationalNode({
  Node
});
var ArrayNode = createArrayNode({
  Node
});
var BlockNode = createBlockNode({
  Node,
  ResultSet
});
var ConditionalNode = createConditionalNode({
  Node
});
var ConstantNode = createConstantNode({
  Node
});
var RangeNode = createRangeNode({
  Node
});
var reviver = createReviver({
  classes
});
var Chain = createChainClass({
  math,
  typed: typed2
});
var FunctionAssignmentNode = createFunctionAssignmentNode({
  Node,
  typed: typed2
});
var chain = createChain({
  Chain,
  typed: typed2
});
var AccessorNode = createAccessorNode({
  Node,
  subset
});
var AssignmentNode = createAssignmentNode({
  matrix,
  Node,
  subset
});
var IndexNode = createIndexNode({
  Node,
  size
});
var SymbolNode = createSymbolNode({
  Unit,
  Node,
  math
});
var FunctionNode = createFunctionNode({
  Node,
  SymbolNode,
  math
});
var parse3 = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config,
  numeric: numeric2,
  typed: typed2
});
var resolve = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse: parse3,
  typed: typed2
});
var simplifyConstant = createSimplifyConstant({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config,
  mathWithTransform,
  matrix,
  typed: typed2
});
var compile = createCompile({
  parse: parse3,
  typed: typed2
});
var simplifyCore = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add2,
  divide: divide2,
  equal,
  isZero,
  multiply,
  parse: parse3,
  pow: pow2,
  subtract,
  typed: typed2
});
var evaluate = createEvaluate({
  parse: parse3,
  typed: typed2
});
var Help = createHelpClass({
  evaluate
});
var Parser = createParserClass({
  evaluate,
  parse: parse3
});
var simplify = createSimplify({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  equal,
  parse: parse3,
  replacer,
  resolve,
  simplifyConstant,
  simplifyCore,
  typed: typed2
});
var symbolicEqual = createSymbolicEqual({
  OperatorNode,
  parse: parse3,
  simplify,
  typed: typed2
});
var leafCount = createLeafCount({
  parse: parse3,
  typed: typed2
});
var parser = createParser({
  Parser,
  typed: typed2
});
var rationalize = createRationalize({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add2,
  config,
  divide: divide2,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse: parse3,
  pow: pow2,
  simplify,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed: typed2
});
var derivative = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config,
  equal,
  isZero,
  numeric: numeric2,
  parse: parse3,
  simplify,
  typed: typed2
});
var help = createHelp({
  Help,
  mathWithTransform,
  typed: typed2
});
_extends(math, {
  e: e2,
  false: _false,
  fineStructure,
  i,
  Infinity: _Infinity,
  LN10: LN102,
  LOG10E,
  NaN: _NaN,
  null: _null,
  phi: phi2,
  SQRT1_2,
  sackurTetrode,
  tau: tau2,
  true: _true,
  E: e2,
  version: version2,
  efimovFactor,
  LN2,
  pi: pi2,
  replacer,
  reviver,
  SQRT2,
  typed: typed2,
  PI: pi2,
  weakMixingAngle,
  abs: abs2,
  acos: acos2,
  acot,
  acsc,
  addScalar,
  arg,
  asech,
  asinh: asinh3,
  atan: atan3,
  atanh: atanh3,
  bigint,
  bitNot,
  boolean,
  clone: clone4,
  combinations,
  complex,
  conj,
  cos: cos2,
  cot,
  csc,
  cube,
  equalScalar,
  erf,
  exp: exp2,
  expm1: expm13,
  filter: filter2,
  flatten: flatten2,
  forEach: forEach2,
  format: format4,
  getMatrixDataType,
  hex,
  im: im2,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  lgamma,
  log10: log104,
  log2: log24,
  map: map2,
  multiplyScalar,
  not,
  number,
  oct,
  pickRandom,
  print,
  random: random2,
  re,
  sec,
  sign: sign3,
  sin: sin2,
  splitUnit,
  square,
  string,
  subtractScalar,
  tan: tan2,
  typeOf: typeOf2,
  acosh: acosh3,
  acsch,
  asec,
  bignumber,
  chain,
  combinationsWithRep,
  cosh: cosh4,
  csch,
  isNaN: isNaN2,
  isPrime,
  mapSlices,
  matrix,
  matrixFromFunction,
  ones,
  randomInt,
  reshape: reshape2,
  sech,
  sinh: sinh4,
  sparse,
  sqrt: sqrt2,
  squeeze: squeeze2,
  tanh: tanh3,
  transpose,
  xgcd,
  zeros: zeros2,
  acoth,
  asin: asin2,
  bin,
  concat: concat2,
  coth,
  ctranspose,
  diag,
  dotMultiply,
  equal,
  fraction,
  identity,
  isNumeric,
  kron,
  largerEq,
  leftShift,
  mode,
  nthRoot,
  numeric: numeric2,
  prod,
  resize: resize2,
  rightArithShift,
  round: round2,
  size,
  smaller,
  to,
  unaryMinus,
  unequal,
  xor,
  add: add2,
  atan2: atan22,
  bitAnd,
  bitOr,
  bitXor: bitXor2,
  cbrt: cbrt4,
  compare,
  compareText: compareText2,
  count,
  deepEqual,
  divideScalar,
  dotDivide,
  equalText,
  floor: floor2,
  gcd: gcd2,
  hasNumericValue,
  hypot: hypot3,
  larger,
  log: log3,
  lsolve,
  matrixFromColumns,
  max: max2,
  min: min2,
  mod: mod2,
  nthRoots,
  or: or2,
  partitionSelect,
  qr,
  rightLogShift,
  smallerEq,
  subset,
  subtract,
  trace,
  usolve,
  catalan,
  compareNatural,
  composition,
  diff,
  distance,
  dot,
  index,
  invmod,
  lcm,
  log1p: log1p2,
  lsolveAll,
  matrixFromRows,
  multiply,
  range,
  row,
  setCartesian,
  setDistinct,
  setIsSubset,
  setPowerset,
  slu,
  sort,
  unaryPlus,
  usolveAll,
  zpk2tf,
  and,
  ceil: ceil2,
  column,
  cross,
  det,
  fix,
  inv,
  pinv,
  pow: pow2,
  setDifference,
  setMultiplicity,
  setSymDifference,
  sqrtm,
  sum: sum2,
  vacuumImpedance,
  wienDisplacement,
  atomicMass,
  bohrMagneton,
  boltzmann,
  conductanceQuantum,
  coulomb,
  cumsum,
  deuteronMass,
  dotPow,
  electricConstant,
  elementaryCharge,
  expm,
  faraday,
  fft,
  gamma,
  gravitationConstant,
  hartreeEnergy,
  ifft,
  inverseConductanceQuantum,
  klitzing,
  loschmidt,
  magneticConstant,
  molarMass,
  molarPlanckConstant,
  neutronMass,
  nuclearMagneton,
  planckCharge,
  planckLength,
  planckTemperature,
  protonMass,
  quantumOfCirculation,
  reducedPlanckConstant,
  rydberg,
  secondRadiation,
  setSize,
  speedOfLight,
  stefanBoltzmann,
  thomsonCrossSection,
  avogadro,
  bohrRadius,
  createUnit,
  divide: divide2,
  electronMass,
  factorial,
  firstRadiation,
  gravity,
  intersect,
  lup,
  magneticFluxQuantum,
  molarMassC12,
  multinomial,
  parse: parse3,
  permutations,
  planckMass,
  polynomialRoot,
  resolve,
  setIntersect,
  simplifyConstant,
  solveODE,
  stirlingS2,
  unit,
  bellNumbers,
  compile,
  eigs,
  fermiCoupling,
  gasConstant,
  kldivergence,
  lusolve,
  mean,
  molarVolume,
  planckConstant,
  quantileSeq,
  setUnion,
  simplifyCore,
  variance,
  classicalElectronRadius,
  evaluate,
  median,
  simplify,
  symbolicEqual,
  corr,
  freqz,
  leafCount,
  mad,
  parser,
  rationalize,
  std,
  zeta,
  derivative,
  norm,
  rotationMatrix,
  help,
  planckTime,
  schur,
  rotate,
  sylvester,
  lyap,
  config
});
_extends(mathWithTransform, math, {
  mapSlices: createMapSlicesTransform({
    isInteger: isInteger2,
    typed: typed2
  }),
  filter: createFilterTransform({
    typed: typed2
  }),
  forEach: createForEachTransform({
    typed: typed2
  }),
  map: createMapTransform({
    typed: typed2
  }),
  or: createOrTransform({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  }),
  and: createAndTransform({
    add: add2,
    concat: concat2,
    equalScalar,
    matrix,
    not,
    typed: typed2,
    zeros: zeros2
  }),
  concat: createConcatTransform({
    isInteger: isInteger2,
    matrix,
    typed: typed2
  }),
  index: createIndexTransform({
    Index,
    getMatrixDataType
  }),
  print: createPrintTransform({
    add: add2,
    matrix,
    typed: typed2,
    zeros: zeros2
  }),
  sum: createSumTransform({
    add: add2,
    config,
    numeric: numeric2,
    typed: typed2
  }),
  bitAnd: createBitAndTransform({
    add: add2,
    concat: concat2,
    equalScalar,
    matrix,
    not,
    typed: typed2,
    zeros: zeros2
  }),
  min: createMinTransform({
    config,
    numeric: numeric2,
    smaller,
    typed: typed2
  }),
  subset: createSubsetTransform({
    add: add2,
    matrix,
    typed: typed2,
    zeros: zeros2
  }),
  bitOr: createBitOrTransform({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  }),
  cumsum: createCumSumTransform({
    add: add2,
    typed: typed2,
    unaryPlus
  }),
  diff: createDiffTransform({
    bignumber,
    matrix,
    number,
    subtract,
    typed: typed2
  }),
  max: createMaxTransform({
    config,
    larger,
    numeric: numeric2,
    typed: typed2
  }),
  range: createRangeTransform({
    bignumber,
    matrix,
    add: add2,
    config,
    isPositive,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed: typed2
  }),
  row: createRowTransform({
    Index,
    matrix,
    range,
    typed: typed2
  }),
  column: createColumnTransform({
    Index,
    matrix,
    range,
    typed: typed2
  }),
  mean: createMeanTransform({
    add: add2,
    divide: divide2,
    typed: typed2
  }),
  quantileSeq: createQuantileSeqTransform({
    add: add2,
    bignumber,
    compare,
    divide: divide2,
    isInteger: isInteger2,
    larger,
    mapSlices,
    multiply,
    partitionSelect,
    smaller,
    smallerEq,
    subtract,
    typed: typed2
  }),
  variance: createVarianceTransform({
    add: add2,
    divide: divide2,
    isNaN: isNaN2,
    mapSlices,
    multiply,
    subtract,
    typed: typed2
  }),
  std: createStdTransform({
    map: map2,
    sqrt: sqrt2,
    typed: typed2,
    variance
  })
});
_extends(classes, {
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  Matrix,
  Node,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  Range,
  RelationalNode,
  ResultSet,
  ArrayNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  DenseMatrix,
  RangeNode,
  Chain,
  FunctionAssignmentNode,
  SparseMatrix,
  ImmutableDenseMatrix,
  Index,
  AccessorNode,
  AssignmentNode,
  FibonacciHeap,
  IndexNode,
  Spa,
  Unit,
  SymbolNode,
  FunctionNode,
  Help,
  Parser
});
Chain.createProxy(math);

// src/main.ts
var input = document.getElementById("input");
var output = document.getElementById("output");
input.addEventListener("input", () => {
  let res = "";
  const scope = {};
  input.value.split(`
`).forEach((line) => {
    if (line === "")
      return res += `
`;
    let output2 = "";
    try {
      let evaluation = evaluate(line, scope).toString();
      if (evaluation.trim().includes(`
`))
        output2 = "error";
      else
        output2 = evaluation;
    } catch (e3) {
      output2 = "error";
    }
    res += " ".repeat(line.length + 1) + output2 + `
`;
  });
  output.innerHTML = res;
});
</script>
  </head>
  <body class="h-full p-10">
    <div class="relative w-full h-full p-5">
      <pre
        id="output"
        class="absolute inset-0 border border-white resize-none rounded-lg p-5 text-lime-400"
      ></pre>
      <textarea
        id="input"
        class="absolute inset-0 bg-transparent border border-white resize-none rounded-lg p-5"
      ></textarea>
    </div>
  </body>
</html>
